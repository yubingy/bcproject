(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define("Debugger", [], factory);
	else if(typeof exports === 'object')
		exports["Debugger"] = factory();
	else
		root["Debugger"] = factory();
})(typeof self !== 'undefined' ? self : this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 37);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports) {

module.exports = require("debug");

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends2 = __webpack_require__(2);

var _extends3 = _interopRequireDefault(_extends2);

exports.isDeliberatelySkippedNodeType = isDeliberatelySkippedNodeType;
exports.isSkippedNodeType = isSkippedNodeType;
exports.prefixName = prefixName;
exports.extractPrimarySource = extractPrimarySource;
exports.keccak256 = keccak256;
exports.stableKeccak256 = stableKeccak256;
exports.makeAssignment = makeAssignment;
exports.isCallMnemonic = isCallMnemonic;
exports.isShortCallMnemonic = isShortCallMnemonic;
exports.isDelegateCallMnemonicBroad = isDelegateCallMnemonicBroad;
exports.isDelegateCallMnemonicStrict = isDelegateCallMnemonicStrict;
exports.isStaticCallMnemonic = isStaticCallMnemonic;
exports.isCreateMnemonic = isCreateMnemonic;
exports.isNormalHaltingMnemonic = isNormalHaltingMnemonic;

var _truffleDecodeUtils = __webpack_require__(4);

var utils = _interopRequireWildcard(_truffleDecodeUtils);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const stringify = __webpack_require__(47);

/** AST node types that are skipped by stepNext() to filter out some noise */
function isDeliberatelySkippedNodeType(node) {
  const skippedTypes = ["ContractDefinition", "VariableDeclaration"];
  return skippedTypes.includes(node.nodeType);
}

//HACK
//these aren't the only types of skipped nodes, but determining all skipped
//nodes would be too difficult
function isSkippedNodeType(node) {
  const otherSkippedTypes = ["VariableDeclarationStatement", "Mapping"];
  return isDeliberatelySkippedNodeType(node) || otherSkippedTypes.includes(node.nodeType) || node.nodeType.includes("TypeName") || //HACK
  //skip string literals too -- we'll handle that manually
  node.typeDescriptions !== undefined && //seems this sometimes happens?
  utils.Definition.typeClass(node) === "stringliteral";
}

function prefixName(prefix, fn) {
  Object.defineProperty(fn, "name", {
    value: `${prefix}.${fn.name}`,
    configurable: true
  });

  return fn;
}

/*
 * extract the primary source from a source map
 * (i.e., the source for the first instruction, found
 * between the second and third colons)
 * (this is something of a HACK)
 */
function extractPrimarySource(sourceMap) {
  return parseInt(sourceMap.match(/^[^:]+:[^:]+:([^:]+):/)[1]);
}

/**
 * @return 0x-prefix string of keccak256 hash
 */
function keccak256(...args) {
  return utils.Conversion.toHexString(utils.EVM.keccak256(...args));
}

/**
 * Given an object, return a stable hash by first running it through a stable
 * stringify operation before hashing
 */
function stableKeccak256(obj) {
  return keccak256({ type: "string", value: stringify(obj) });
}

/*
 * used by data; takes an id object and a ref (pointer) and returns a full
 * corresponding assignment object
 */
function makeAssignment(idObj, ref) {
  let id = stableKeccak256(idObj);
  return (0, _extends3.default)({}, idObj, { id, ref });
}

/*
 * Given a mmemonic, determine whether it's the mnemonic of a calling
 * instruction (does NOT include creation instructions)
 */
function isCallMnemonic(op) {
  const calls = ["CALL", "DELEGATECALL", "STATICCALL", "CALLCODE"];
  return calls.includes(op);
}

/*
 * returns true for mnemonics for calls that take only 6 args instead of 7
 */
function isShortCallMnemonic(op) {
  const shortCalls = ["DELEGATECALL", "STATICCALL"];
  return shortCalls.includes(op);
}

/*
 * returns true for mnemonics for calls that delegate storage
 */
function isDelegateCallMnemonicBroad(op) {
  const delegateCalls = ["DELEGATECALL", "CALLCODE"];
  return delegateCalls.includes(op);
}

/*
 * returns true for mnemonics for calls that delegate everything
 */
function isDelegateCallMnemonicStrict(op) {
  const delegateCalls = ["DELEGATECALL"];
  return delegateCalls.includes(op);
}

/*
 * returns true for mnemonics for static calls
 */
function isStaticCallMnemonic(op) {
  const delegateCalls = ["STATICCALL"];
  return delegateCalls.includes(op);
}

/*
 * Given a mmemonic, determine whether it's the mnemonic of a creation
 * instruction
 */
function isCreateMnemonic(op) {
  const creates = ["CREATE", "CREATE2"];
  return creates.includes(op);
}

/*
 * Given a mmemonic, determine whether it's the mnemonic of a normal
 * halting instruction
 */
function isNormalHaltingMnemonic(op) {
  const halts = ["STOP", "RETURN", "SELFDESTRUCT", "SUICIDE"];
  //the mnemonic SUICIDE is no longer used, but just in case, I'm including it
  return halts.includes(op);
}

/***/ }),
/* 2 */
/***/ (function(module, exports) {

module.exports = require("babel-runtime/helpers/extends");

/***/ }),
/* 3 */
/***/ (function(module, exports) {

module.exports = require("reselect-tree");

/***/ }),
/* 4 */
/***/ (function(module, exports) {

module.exports = require("truffle-decode-utils");

/***/ }),
/* 5 */
/***/ (function(module, exports) {

module.exports = require("redux-saga/effects");

/***/ }),
/* 6 */
/***/ (function(module, exports) {

module.exports = require("babel-runtime/core-js/object/entries");

/***/ }),
/* 7 */
/***/ (function(module, exports) {

module.exports = require("redux");

/***/ }),
/* 8 */
/***/ (function(module, exports) {

module.exports = require("babel-runtime/core-js/object/assign");

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _entries = __webpack_require__(6);

var _entries2 = _interopRequireDefault(_entries);

var _extends2 = __webpack_require__(2);

var _extends3 = _interopRequireDefault(_extends2);

var _assign = __webpack_require__(8);

var _assign2 = _interopRequireDefault(_assign);

var _debug = __webpack_require__(0);

var _debug2 = _interopRequireDefault(_debug);

var _reselectTree = __webpack_require__(3);

var _bn = __webpack_require__(15);

var _bn2 = _interopRequireDefault(_bn);

var _selectors = __webpack_require__(10);

var _selectors2 = _interopRequireDefault(_selectors);

var _truffleDecodeUtils = __webpack_require__(4);

var DecodeUtils = _interopRequireWildcard(_truffleDecodeUtils);

var _helpers = __webpack_require__(1);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const debug = (0, _debug2.default)("debugger:evm:selectors"); // eslint-disable-line no-unused-vars

/**
 * create EVM-level selectors for a given trace step selector
 * may specify additional selectors to include
 */
function createStepSelectors(step, state = null) {
  let base = {
    /**
     * .trace
     *
     * trace step info related to operation
     */
    trace: (0, _reselectTree.createLeaf)([step], step => {
      if (!step) {
        return null;
      }
      let { gasCost, op, pc } = step;
      return { gasCost, op, pc };
    }),

    /**
     * .programCounter
     */
    programCounter: (0, _reselectTree.createLeaf)(["./trace"], step => step ? step.pc : null),

    /**
     * .isJump
     */
    isJump: (0, _reselectTree.createLeaf)(["./trace"], step => step.op != "JUMPDEST" && step.op.indexOf("JUMP") == 0),

    /**
     * .isCall
     *
     * whether the opcode will switch to another calling context
     */
    isCall: (0, _reselectTree.createLeaf)(["./trace"], step => (0, _helpers.isCallMnemonic)(step.op)),

    /**
     * .isShortCall
     *
     * for calls that only take 6 arguments instead of 7
     */
    isShortCall: (0, _reselectTree.createLeaf)(["./trace"], step => (0, _helpers.isShortCallMnemonic)(step.op)),

    /**
     * .isDelegateCallBroad
     *
     * for calls that delegate storage
     */
    isDelegateCallBroad: (0, _reselectTree.createLeaf)(["./trace"], step => (0, _helpers.isDelegateCallMnemonicBroad)(step.op)),

    /**
     * .isDelegateCallStrict
     *
     * for calls that additionally delegate sender and value
     */
    isDelegateCallStrict: (0, _reselectTree.createLeaf)(["./trace"], step => (0, _helpers.isDelegateCallMnemonicStrict)(step.op)),

    /**
     * .isStaticCall
     */
    isStaticCall: (0, _reselectTree.createLeaf)(["./trace"], step => (0, _helpers.isStaticCallMnemonic)(step.op)),

    /**
     * .isCreate
     */
    isCreate: (0, _reselectTree.createLeaf)(["./trace"], step => (0, _helpers.isCreateMnemonic)(step.op)),

    /**
     * .isHalting
     *
     * whether the instruction halts or returns from a calling context
     * NOTE: this covers only ordinary halts, not exceptional halts;
     * but it doesn't check the return status, so any normal halting
     * instruction will qualify here
     */
    isHalting: (0, _reselectTree.createLeaf)(["./trace"], step => (0, _helpers.isNormalHaltingMnemonic)(step.op)),

    /*
     * .isStore
     */
    isStore: (0, _reselectTree.createLeaf)(["./trace"], step => step.op == "SSTORE"),

    /*
     * .isLoad
     */
    isLoad: (0, _reselectTree.createLeaf)(["./trace"], step => step.op == "SLOAD"),

    /*
     * .touchesStorage
     *
     * whether the instruction involves storage
     */
    touchesStorage: (0, _reselectTree.createLeaf)(["./isStore", "isLoad"], (stores, loads) => stores || loads)
  };

  if (state) {
    const isRelative = path => typeof path == "string" && (path.startsWith("./") || path.startsWith("../"));

    if (isRelative(state)) {
      state = `../${state}`;
    }

    (0, _assign2.default)(base, {
      /**
       * .callAddress
       *
       * address transferred to by call operation
       */
      callAddress: (0, _reselectTree.createLeaf)(["./isCall", state], (isCall, { stack }) => {
        if (!isCall) {
          return null;
        }

        let address = stack[stack.length - 2];
        return DecodeUtils.Conversion.toAddress(address);
      }),

      /**
       * .createBinary
       *
       * binary code to execute via create operation
       */
      createBinary: (0, _reselectTree.createLeaf)(["./isCreate", state], (isCreate, { stack, memory }) => {
        if (!isCreate) {
          return null;
        }

        // Get the code that's going to be created from memory.
        // Note we multiply by 2 because these offsets are in bytes.
        const offset = parseInt(stack[stack.length - 2], 16) * 2;
        const length = parseInt(stack[stack.length - 3], 16) * 2;

        return "0x" + memory.join("").substring(offset, offset + length);
      }),

      /**
       * .callData
       *
       * data passed to EVM call
       */
      callData: (0, _reselectTree.createLeaf)(["./isCall", "./isShortCall", state], (isCall, short, { stack, memory }) => {
        if (!isCall) {
          return null;
        }

        //if it's 6-argument call, the data start and offset will be one spot
        //higher in the stack than they would be for a 7-argument call, so
        //let's introduce an offset to handle this
        let argOffset = short ? 1 : 0;

        // Get the data from memory.
        // Note we multiply by 2 because these offsets are in bytes.
        const offset = parseInt(stack[stack.length - 4 + argOffset], 16) * 2;
        const length = parseInt(stack[stack.length - 5 + argOffset], 16) * 2;

        return "0x" + memory.join("").substring(offset, offset + length);
      }),

      /**
       * .callValue
       *
       * value for the call (not create); returns null for DELEGATECALL
       */
      callValue: (0, _reselectTree.createLeaf)(["./isCall", "./isDelegateCallStrict", "./isStaticCall", state], (calls, delegates, isStatic, { stack }) => {
        if (!calls || delegates) {
          return null;
        }

        if (isStatic) {
          return new _bn2.default(0);
        }

        //otherwise, for CALL and CALLCODE, it's the 3rd argument
        let value = stack[stack.length - 3];
        return DecodeUtils.Conversion.toBN(value);
      }),

      /**
       * .createValue
       *
       * value for the create
       */
      createValue: (0, _reselectTree.createLeaf)(["./isCreate", state], (isCreate, { stack }) => {
        if (!isCreate) {
          return null;
        }

        //creates have the value as the first argument
        let value = stack[stack.length - 1];
        return DecodeUtils.Conversion.toBN(value);
      }),

      /**
       * .storageAffected
       *
       * storage slot being stored to or loaded from
       * we do NOT prepend "0x"
       */
      storageAffected: (0, _reselectTree.createLeaf)(["./touchesStorage", state], (touchesStorage, { stack }) => {
        if (!touchesStorage) {
          return null;
        }

        return stack[stack.length - 1];
      }),

      /*
       * .returnValue
       *
       * for a RETURN instruction, the value returned
       * we DO prepend "0x"
       * (will also return "0x" for STOP or SELFDESTRUCT but
       * null otherwise)
       */
      returnValue: (0, _reselectTree.createLeaf)(["./trace", "./isHalting", state], (step, isHalting, { stack, memory }) => {
        if (!isHalting) {
          return null;
        }
        if (step.op !== "RETURN") {
          //STOP and SELFDESTRUCT return empty value
          return "0x";
        }
        // Get the data from memory.
        // Note we multiply by 2 because these offsets are in bytes.
        const offset = parseInt(stack[stack.length - 1], 16) * 2;
        const length = parseInt(stack[stack.length - 2], 16) * 2;

        return "0x" + memory.join("").substring(offset, offset + length);
      })
    });
  }

  return base;
}

const evm = (0, _reselectTree.createSelectorTree)({
  /**
   * evm.state
   */
  state: state => state.evm,

  /**
   * evm.info
   */
  info: {
    /**
     * evm.info.contexts
     */
    contexts: (0, _reselectTree.createLeaf)(["/state"], state => state.info.contexts.byContext),

    /**
     * evm.info.binaries
     */
    binaries: {
      /**
       * evm.info.binaries.search
       *
       * returns function (binary) => context (returns the *ID* of the context)
       * (returns null on no match)
       */
      search: (0, _reselectTree.createLeaf)(["/info/contexts"], contexts => binary => DecodeUtils.Contexts.findDebuggerContext(contexts, binary))
    }
  },

  /**
   * evm.transaction
   */
  transaction: {
    /*
     * evm.transaction.globals
     */
    globals: {
      /*
       * evm.transaction.globals.tx
       */
      tx: (0, _reselectTree.createLeaf)(["/state"], state => state.transaction.globals.tx),
      /*
       * evm.transaction.globals.block
       */
      block: (0, _reselectTree.createLeaf)(["/state"], state => state.transaction.globals.block)
    },

    /*
     * evm.transaction.status
     */
    status: (0, _reselectTree.createLeaf)(["/state"], state => state.transaction.status),

    /*
     * evm.transaction.initialCall
     */
    initialCall: (0, _reselectTree.createLeaf)(["/state"], state => state.transaction.initialCall)
  },

  /**
   * evm.current
   */
  current: {
    /**
     * evm.current.callstack
     */
    callstack: state => state.evm.proc.callstack,

    /**
     * evm.current.call
     */
    call: (0, _reselectTree.createLeaf)(["./callstack"], stack => stack.length ? stack[stack.length - 1] : {}),

    /**
     * evm.current.context
     */
    context: (0, _reselectTree.createLeaf)(["./call", "./codex/instances", "/info/binaries/search", "/info/contexts"], ({ address, binary }, instances, search, contexts) => {
      let contextId;
      if (address) {
        //if we're in a call to a deployed contract, we must have recorded
        //the context in the codex, so we don't need to do any further
        //searching
        ({ context: contextId, binary } = instances[address]);
      } else if (binary) {
        //otherwise, if we're in a constructor, we'll need to actually do a
        //search
        contextId = search(binary);
      } else {
        //exceptional case: no transaction is loaded
        return null;
      }

      if (contextId != undefined) {
        //if we found the context, use it
        let context = contexts[contextId];
        return (0, _extends3.default)({}, context, {
          binary
        });
      } else {
        //otherwise we'll construct something default
        return {
          binary,
          isConstructor: address === undefined
          //WARNING: we've mutated binary here, so
          //instead we go by whether address is undefined
        };
      }
    }),

    /**
     * evm.current.state
     *
     * evm state info: as of last operation, before op defined in step
     */
    state: (0, _assign2.default)({}, ...["depth", "error", "gas", "memory", "stack", "storage"].map(param => ({
      [param]: (0, _reselectTree.createLeaf)([_selectors2.default.step], step => step[param])
    }))),

    /**
     * evm.current.step
     */
    step: (0, _extends3.default)({}, createStepSelectors(_selectors2.default.step, "./state"), {

      //the following step selectors only exist for current, not next or any
      //other step

      /*
       * evm.current.step.createdAddress
       *
       * address created by the current create step
       */
      createdAddress: (0, _reselectTree.createLeaf)(["./isCreate", "/nextOfSameDepth/state/stack"], (isCreate, stack) => {
        if (!isCreate) {
          return null;
        }
        let address = stack[stack.length - 1];
        return DecodeUtils.Conversion.toAddress(address);
      }),

      /**
       * evm.current.step.callsPrecompileOrExternal
       *
       * are we calling a precompiled contract or an externally-owned account,
       * rather than a contract account that isn't precompiled?
       */
      callsPrecompileOrExternal: (0, _reselectTree.createLeaf)(["./isCall", "/current/state/depth", "/next/state/depth"], (calls, currentDepth, nextDepth) => calls && currentDepth === nextDepth),

      /**
       * evm.current.step.isContextChange
       * groups together calls, creates, halts, and exceptional halts
       */
      isContextChange: (0, _reselectTree.createLeaf)(["/current/state/depth", "/next/state/depth"], (currentDepth, nextDepth) => currentDepth !== nextDepth),

      /**
       * evm.current.step.isExceptionalHalting
       */
      isExceptionalHalting: (0, _reselectTree.createLeaf)(["./isHalting", "/current/state/depth", "/next/state/depth", "./returnStatus"], (halting, currentDepth, nextDepth, status) => halting ? !status //if deliberately halting, check the return status
      : nextDepth < currentDepth //if not on a deliberate halt, any halt
      //is an exceptional halt
      ),

      /**
       * evm.current.step.returnStatus
       * checks the return status of the *current* halting instruction (for
       * normal halts only)
       * (returns a boolean -- true for success, false for failure)
       */
      returnStatus: (0, _reselectTree.createLeaf)(["./isHalting", "/next/state", _selectors2.default.stepsRemaining, "/transaction/status"], (isHalting, { stack }, remaining, finalStatus) => {
        if (!isHalting) {
          return null; //not clear this'll do much good since this may get
          //read as false, but, oh well, may as well
        }
        if (remaining <= 1) {
          return finalStatus;
        } else {
          const ZERO_WORD = "00".repeat(DecodeUtils.EVM.WORD_SIZE);
          return stack[stack.length - 1] !== ZERO_WORD;
        }
      })
    }),

    /**
     * evm.current.codex (namespace)
     */
    codex: {
      /**
       * evm.current.codex (selector)
       * the whole codex! not that that's very much at the moment
       */
      _: (0, _reselectTree.createLeaf)(["/state"], state => state.proc.codex),

      /**
       * evm.current.codex.storage
       * the current storage, as fetched from the codex... unless we're in a
       * failed creation call, then we just fall back on the state (which will
       * work, since nothing else can interfere with the storage of a failed
       * creation call!)
       */
      storage: (0, _reselectTree.createLeaf)(["./_", "../state/storage", "../call"], (codex, rawStorage, { storageAddress }) => storageAddress === DecodeUtils.EVM.ZERO_ADDRESS ? rawStorage //HACK -- if zero address ignore the codex
      : codex[codex.length - 1].accounts[storageAddress].storage),

      /*
       * evm.current.codex.instances
       */
      instances: (0, _reselectTree.createLeaf)(["./_"], codex => (0, _assign2.default)({}, ...(0, _entries2.default)(codex[codex.length - 1].accounts).map(([address, { code, context }]) => ({
        [address]: { address, binary: code, context }
      }))))
    }
  },

  /**
   * evm.next
   */
  next: {
    /**
     * evm.next.state
     *
     * evm state as a result of next step operation
     */
    state: (0, _assign2.default)({}, ...["depth", "error", "gas", "memory", "stack", "storage"].map(param => ({
      [param]: (0, _reselectTree.createLeaf)([_selectors2.default.next], step => step[param])
    }))),

    /*
     * evm.next.step
     */
    step: createStepSelectors(_selectors2.default.next, "./state")
  },

  /**
   * evm.nextOfSameDepth
   */
  nextOfSameDepth: {
    /**
     * evm.nextOfSameDepth.state
     *
     * evm state at the next step of same depth
     */
    state: (0, _assign2.default)({}, ...["depth", "error", "gas", "memory", "stack", "storage"].map(param => ({
      [param]: (0, _reselectTree.createLeaf)([_selectors2.default.nextOfSameDepth], step => step[param])
    })))
  }
});

exports.default = evm;

/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _reselectTree = __webpack_require__(3);

const PAST_END_OF_TRACE = {
  depth: -1, //this is the part that matters!
  //the rest of this is just to look like a trace step
  error: "",
  gas: 0,
  memory: [],
  stack: [],
  storage: {},
  gasCost: 0,
  op: "STOP",
  pc: -1 //this is not at all valid but that's fine
};

let trace = (0, _reselectTree.createSelectorTree)({
  /**
   * trace.index
   *
   * current step index
   */
  index: state => state.trace.proc.index,

  /*
   * trace.loaded
   * is a trace loaded?
   */
  loaded: (0, _reselectTree.createLeaf)(["/steps"], steps => steps !== null),

  /**
   * trace.finished
   * is the trace finished?
   */
  finished: state => state.trace.proc.finished,

  /**
   * trace.finishedOrUnloaded
   *
   * is the trace finished, including if it's unloaded?
   */
  finishedOrUnloaded: (0, _reselectTree.createLeaf)(["/finished", "/loaded"], (finished, loaded) => finished || !loaded),

  /**
   * trace.steps
   *
   * all trace steps
   */
  steps: state => state.trace.transaction.steps,

  /**
   * trace.stepsRemaining
   *
   * number of steps remaining in trace
   */
  stepsRemaining: (0, _reselectTree.createLeaf)(["./steps", "./index"], (steps, index) => steps.length - index),

  /**
   * trace.step
   *
   * current trace step
   */
  step: (0, _reselectTree.createLeaf)(["./steps", "./index"], (steps, index) => steps ? steps[index] : null //null if no tx loaded
  ),

  /**
   * trace.next
   *
   * next trace step
   * HACK: if at the end,
   * we will return a spoofed "past end" step
   */
  next: (0, _reselectTree.createLeaf)(["./steps", "./index"], (steps, index) => index < steps.length - 1 ? steps[index + 1] : PAST_END_OF_TRACE),

  /*
   * trace.nextOfSameDepth
   * next trace step that's at the same depth as this one
   * NOTE: if there is none, will return undefined
   * (should not be used in such cases)
   */
  nextOfSameDepth: (0, _reselectTree.createLeaf)(["./steps", "./index"], (steps, index) => {
    let depth = steps[index].depth;
    return steps.slice(index + 1).find(step => step.depth === depth);
  })
});

exports.default = trace;

/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _entries = __webpack_require__(6);

var _entries2 = _interopRequireDefault(_entries);

var _assign = __webpack_require__(8);

var _assign2 = _interopRequireDefault(_assign);

var _extends2 = __webpack_require__(2);

var _extends3 = _interopRequireDefault(_extends2);

var _debug = __webpack_require__(0);

var _debug2 = _interopRequireDefault(_debug);

var _reselectTree = __webpack_require__(3);

var _truffleSolidityUtils = __webpack_require__(51);

var _truffleSolidityUtils2 = _interopRequireDefault(_truffleSolidityUtils);

var _truffleCodeUtils = __webpack_require__(52);

var _truffleCodeUtils2 = _interopRequireDefault(_truffleCodeUtils);

var _map = __webpack_require__(25);

var _jsonPointer = __webpack_require__(22);

var _jsonPointer2 = _interopRequireDefault(_jsonPointer);

var _selectors = __webpack_require__(9);

var _selectors2 = _interopRequireDefault(_selectors);

var _selectors3 = __webpack_require__(10);

var _selectors4 = _interopRequireDefault(_selectors3);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const debug = (0, _debug2.default)("debugger:solidity:selectors");

function getSourceRange(instruction = {}) {
  return {
    start: instruction.start || 0,
    length: instruction.length || 0,
    lines: instruction.range || {
      start: {
        line: 0,
        column: 0
      },
      end: {
        line: 0,
        column: 0
      }
    }
  };
}

//function to create selectors that need both a current and next version
function createMultistepSelectors(stepSelector) {
  return {
    /**
     * .instruction
     */
    instruction: (0, _reselectTree.createLeaf)(["/current/instructionAtProgramCounter", stepSelector.programCounter],
    //HACK: we use solidity.current.instructionAtProgramCounter
    //even if we're looking at solidity.next.
    //This is harmless... so long as the current instruction isn't a context
    //change.  So, don't use solidity.next when it is.

    (map, pc) => map[pc] || {}),

    /**
     * .source
     */
    source: (0, _reselectTree.createLeaf)(["/info/sources", "./instruction"], (sources, { file: id }) => sources[id] || {}),

    /**
     * .sourceRange
     */
    sourceRange: (0, _reselectTree.createLeaf)(["./instruction"], getSourceRange),

    /**
     * .pointer
     */
    pointer: (0, _reselectTree.createLeaf)(["./source", "./sourceRange"], ({ ast }, range) => (0, _map.findRange)(ast, range.start, range.length)),

    /**
     * .node
     */
    node: (0, _reselectTree.createLeaf)(["./source", "./pointer"], ({ ast }, pointer) => pointer ? _jsonPointer2.default.get(ast, pointer) : _jsonPointer2.default.get(ast, ""))
  };
}

let solidity = (0, _reselectTree.createSelectorTree)({
  /**
   * solidity.state
   */
  state: state => state.solidity,

  /**
   * solidity.info
   */
  info: {
    /**
     * solidity.info.sources
     */
    sources: (0, _reselectTree.createLeaf)(["/state"], state => state.info.sources.byId)
  },

  /**
   * solidity.current
   */
  current: (0, _extends3.default)({
    /**
     * solidity.current.sourceMap
     */
    sourceMap: (0, _reselectTree.createLeaf)([_selectors2.default.current.context], context => context ? context.sourceMap : null //null when no tx loaded
    ),

    /**
     * solidity.current.functionDepthStack
     */
    functionDepthStack: state => state.solidity.proc.functionDepthStack,

    /**
     * solidity.current.functionDepth
     */
    functionDepth: (0, _reselectTree.createLeaf)(["./functionDepthStack"], stack => stack[stack.length - 1]),

    /**
     * solidity.current.instructions
     */
    instructions: (0, _reselectTree.createLeaf)(["/info/sources", _selectors2.default.current.context, "./sourceMap"], (sources, context, sourceMap) => {
      if (!context) {
        return [];
      }
      let binary = context.binary;
      if (!binary) {
        return [];
      }

      let numInstructions;
      if (sourceMap) {
        numInstructions = sourceMap.split(";").length;
      } else {
        //HACK
        numInstructions = (binary.length - 2) / 2;
        //this is actually an overestimate, but that's OK
      }

      //because we might be dealing with a constructor with arguments, we do
      //*not* remove metadata manually
      let instructions = _truffleCodeUtils2.default.parseCode(binary, numInstructions);

      if (!sourceMap) {
        // HACK
        // Let's create a source map to use since none exists. This source
        // map maps just as many ranges as there are instructions (or
        // possibly more), and marks them all as being Solidity-internal and
        // not jumps.
        sourceMap = binary !== "0x" ? "0:0:-1:-".concat(";".repeat(instructions.length - 1)) : "";
      }

      var lineAndColumnMappings = (0, _assign2.default)({}, ...(0, _entries2.default)(sources).map(([id, { source }]) => ({
        [id]: _truffleSolidityUtils2.default.getCharacterOffsetToLineAndColumnMapping(source || "")
      })));
      var humanReadableSourceMap = _truffleSolidityUtils2.default.getHumanReadableSourceMap(sourceMap);

      let primaryFile = humanReadableSourceMap[0].file;
      debug("primaryFile %o", primaryFile);

      return instructions.map((instruction, index) => {
        // lookup source map by index and add `index` property to
        // instruction
        //

        const sourceMap = humanReadableSourceMap[index] || {};

        return {
          instruction: (0, _extends3.default)({}, instruction, { index }),
          sourceMap
        };
      }).map(({ instruction, sourceMap }) => {
        // add source map information to instruction, or defaults
        //

        const {
          jump,
          start = 0,
          length = 0,
          file = primaryFile
        } = sourceMap;
        const lineAndColumnMapping = lineAndColumnMappings[file] || {};
        const range = {
          start: lineAndColumnMapping[start] || {
            line: null,
            column: null
          },
          end: lineAndColumnMapping[start + length] || {
            line: null,
            column: null
          }
        };

        if (range.start.line === null) {
          debug("sourceMap %o", sourceMap);
        }

        return (0, _extends3.default)({}, instruction, {

          jump,
          start,
          length,
          file,
          range
        });
      });
    }),

    /**
     * solidity.current.instructionAtProgramCounter
     */
    instructionAtProgramCounter: (0, _reselectTree.createLeaf)(["./instructions"], instructions => (0, _assign2.default)({}, ...instructions.map(instruction => ({
      [instruction.pc]: instruction
    }))))

  }, createMultistepSelectors(_selectors2.default.current.step), {

    /**
     * solidity.current.isSourceRangeFinal
     */
    isSourceRangeFinal: (0, _reselectTree.createLeaf)(["./instructionAtProgramCounter", _selectors2.default.current.step.programCounter, _selectors2.default.next.step.programCounter], (map, current, next) => {
      if (!map[next]) {
        return true;
      }

      current = map[current];
      next = map[next];

      return current.start != next.start || current.length != next.length || current.file != next.file;
    }),

    /*
     * solidity.current.functionsByProgramCounter
     */
    functionsByProgramCounter: (0, _reselectTree.createLeaf)(["./instructions", "/info/sources"], (instructions, sources) => (0, _assign2.default)({}, ...instructions.filter(instruction => instruction.name === "JUMPDEST").filter(instruction => instruction.file !== -1)
    //note that the designated invalid function *does* have an associated
    //file, so it *is* safe to just filter out the ones that don't
    .map(instruction => {
      debug("instruction %O", instruction);
      let source = instruction.file;
      debug("source %O", sources[source]);
      let ast = sources[source].ast;
      let range = getSourceRange(instruction);
      let pointer = (0, _map.findRange)(ast, range.start, range.length);
      let node = pointer ? _jsonPointer2.default.get(ast, pointer) : _jsonPointer2.default.get(ast, "");
      if (!node || node.nodeType !== "FunctionDefinition") {
        //filter out JUMPDESTs that aren't function definitions...
        //except for the designated invalid function
        let nextInstruction = instructions[instruction.index + 1] || {};
        if (nextInstruction.name === "INVALID") {
          //designated invalid, include it
          return {
            [instruction.pc]: {
              isDesignatedInvalid: true
            }
          };
        } else {
          //not designated invalid, filter it out
          return {};
        }
      }
      //otherwise, we're good to go, so let's find the contract node and
      //put it all together
      //to get the contract node, we go up twice from the function node;
      //the path from one to the other should have a very specific form,
      //so this is easy
      let contractPointer = pointer.replace(/\/nodes\/\d+$/, "");
      let contractNode = _jsonPointer2.default.get(ast, contractPointer);
      return {
        [instruction.pc]: {
          source,
          pointer,
          node,
          name: node.name,
          id: node.id,
          contractPointer,
          contractNode,
          contractName: contractNode.name,
          contractId: contractNode.id,
          contractKind: contractNode.contractKind,
          isDesignatedInvalid: false
        }
      };
    }))),

    /**
     * solidity.current.isMultiline
     */
    isMultiline: (0, _reselectTree.createLeaf)(["./sourceRange"], ({ lines }) => lines.start.line != lines.end.line),

    /**
     * solidity.current.willJump
     */
    willJump: (0, _reselectTree.createLeaf)([_selectors2.default.current.step.isJump], isJump => isJump),

    /**
     * solidity.current.jumpDirection
     */
    jumpDirection: (0, _reselectTree.createLeaf)(["./instruction"], (i = {}) => i.jump || "-"),

    /**
     * solidity.current.willCall
     */
    willCall: (0, _reselectTree.createLeaf)([_selectors2.default.current.step.isCall], x => x),

    /**
     * solidity.current.willCreate
     */
    willCreate: (0, _reselectTree.createLeaf)([_selectors2.default.current.step.isCreate], x => x),

    /**
     * solidity.current.callsPrecompileOrExternal
     */
    callsPrecompileOrExternal: (0, _reselectTree.createLeaf)([_selectors2.default.current.step.callsPrecompileOrExternal], x => x),

    /**
     * solidity.current.willReturn
     */
    willReturn: (0, _reselectTree.createLeaf)([_selectors2.default.current.step.isHalting], isHalting => isHalting),

    /**
     * solidity.current.willFail
     */
    willFail: (0, _reselectTree.createLeaf)([_selectors2.default.current.step.isExceptionalHalting], x => x),

    /*
     * solidity.current.nextMapped
     * returns the next trace step after this one which is sourcemapped
     * HACK: this assumes we're not about to change context! don't use this if
     * we are!
     * ALSO, this may return undefined, so be prepared for that
     */
    nextMapped: (0, _reselectTree.createLeaf)(["./instructionAtProgramCounter", _selectors4.default.steps, _selectors4.default.index], (map, steps, index) => steps.slice(index + 1).find(({ pc }) => map[pc] && map[pc].file !== -1))
  }),

  /**
   * solidity.next
   * HACK WARNING: do not use these selectors when the current instruction is a
   * context change! (evm call or evm return)
   */
  next: createMultistepSelectors(_selectors2.default.next.step)
});

exports.default = solidity;

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.saveSteps = saveSteps;
exports.next = next;
exports.tick = tick;
exports.tock = tock;
exports.endTrace = endTrace;
exports.reset = reset;
exports.unloadTransaction = unloadTransaction;
exports.backtick = backtick;
const SAVE_STEPS = exports.SAVE_STEPS = "SAVE_STEPS";
function saveSteps(steps) {
  return {
    type: SAVE_STEPS,
    steps
  };
}

const NEXT = exports.NEXT = "NEXT";
function next() {
  return { type: NEXT };
}

const TICK = exports.TICK = "TICK";
function tick() {
  return { type: TICK };
}

const TOCK = exports.TOCK = "TOCK";
function tock() {
  return { type: TOCK };
}

const END_OF_TRACE = exports.END_OF_TRACE = "EOT";
function endTrace() {
  return { type: END_OF_TRACE };
}

const RESET = exports.RESET = "TRACE_RESET";
function reset() {
  return { type: RESET };
}

const UNLOAD_TRANSACTION = exports.UNLOAD_TRANSACTION = "TRACE_UNLOAD_TRANSACTION";
function unloadTransaction() {
  return { type: UNLOAD_TRANSACTION };
}

const BACKTICK = exports.BACKTICK = "BACKTICK";
function backtick() {
  return { type: BACKTICK };
}

/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _set = __webpack_require__(28);

var _set2 = _interopRequireDefault(_set);

exports.advance = advance;
exports.signalTickSagaCompletion = signalTickSagaCompletion;
exports.processTrace = processTrace;
exports.reset = reset;
exports.unload = unload;
exports.saga = saga;

var _debug = __webpack_require__(0);

var _debug2 = _interopRequireDefault(_debug);

var _effects = __webpack_require__(5);

var _helpers = __webpack_require__(1);

var _truffleDecodeUtils = __webpack_require__(4);

var DecodeUtils = _interopRequireWildcard(_truffleDecodeUtils);

var _actions = __webpack_require__(12);

var actions = _interopRequireWildcard(_actions);

var _selectors = __webpack_require__(10);

var _selectors2 = _interopRequireDefault(_selectors);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const debug = (0, _debug2.default)("debugger:trace:sagas");

function* advance() {
  yield (0, _effects.put)(actions.next());

  debug("TOCK to take");
  yield (0, _effects.take)([actions.TOCK, actions.END_OF_TRACE]);
  debug("TOCK taken");
}

const SUBMODULE_COUNT = 3; //data, evm, solidity

function* next() {
  let remaining = yield (0, _effects.select)(_selectors2.default.stepsRemaining);
  debug("remaining: %o", remaining);
  let steps = yield (0, _effects.select)(_selectors2.default.steps);
  debug("total steps: %o", steps.length);
  let waitingForSubmodules = 0;

  if (remaining > 0) {
    debug("putting TICK");
    // updates state for current step
    waitingForSubmodules = SUBMODULE_COUNT;
    yield (0, _effects.put)(actions.tick());
    debug("put TICK");

    //wait for all backticks before continuing
    while (waitingForSubmodules > 0) {
      yield (0, _effects.take)(actions.BACKTICK);
      debug("got BACKTICK");
      waitingForSubmodules--;
    }

    remaining--; // local update, just for convenience
  }

  if (remaining) {
    debug("putting TOCK");
    // updates step to next step in trace
    yield (0, _effects.put)(actions.tock());
    debug("put TOCK");
  } else {
    debug("putting END_OF_TRACE");
    yield (0, _effects.put)(actions.endTrace());
    debug("put END_OF_TRACE");
  }
}

function* signalTickSagaCompletion() {
  yield (0, _effects.put)(actions.backtick());
}

function* processTrace(steps) {
  yield (0, _effects.put)(actions.saveSteps(steps));

  let addresses = [...new _set2.default(steps.map(({ op, stack }) => (0, _helpers.isCallMnemonic)(op) ? //if it's a call, just fetch the address off the stack
  DecodeUtils.Conversion.toAddress(stack[stack.length - 2]) : //if it's not a call, just return undefined (we've gone back to
  //skipping creates)
  undefined)
  //filter out zero addresses from failed creates (as well as undefineds)
  .filter(address => address !== undefined && address !== DecodeUtils.EVM.ZERO_ADDRESS))];

  return addresses;
}

function* reset() {
  yield (0, _effects.put)(actions.reset());
}

function* unload() {
  yield (0, _effects.put)(actions.unloadTransaction());
}

function* saga() {
  yield (0, _effects.takeEvery)(actions.NEXT, next);
}

exports.default = (0, _helpers.prefixName)("trace", saga);

/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.start = start;
exports.loadTransaction = loadTransaction;
exports.interrupt = interrupt;
exports.unloadTransaction = unloadTransaction;
exports.ready = ready;
exports.wait = wait;
exports.error = error;
exports.clearError = clearError;
exports.recordContracts = recordContracts;
exports.saveTransaction = saveTransaction;
exports.saveReceipt = saveReceipt;
exports.saveBlock = saveBlock;
const START = exports.START = "SESSION_START";
function start(provider, txHash) {
  return {
    type: START,
    provider,
    txHash //OPTIONAL
  };
}

const LOAD_TRANSACTION = exports.LOAD_TRANSACTION = "LOAD_TRANSACTION";
function loadTransaction(txHash) {
  return {
    type: LOAD_TRANSACTION,
    txHash
  };
}

const INTERRUPT = exports.INTERRUPT = "SESSION_INTERRUPT";
function interrupt() {
  return { type: INTERRUPT };
}

const UNLOAD_TRANSACTION = exports.UNLOAD_TRANSACTION = "UNLOAD_TRANSACTION";
function unloadTransaction() {
  return {
    type: UNLOAD_TRANSACTION
  };
}

const READY = exports.READY = "SESSION_READY";
function ready() {
  return {
    type: READY
  };
}

const WAIT = exports.WAIT = "SESSION_WAIT";
function wait() {
  return {
    type: WAIT
  };
}

const ERROR = exports.ERROR = "SESSION_ERROR";
function error(error) {
  return {
    type: ERROR,
    error
  };
}

const CLEAR_ERROR = exports.CLEAR_ERROR = "CLEAR_ERROR";
function clearError() {
  return {
    type: CLEAR_ERROR
  };
}

const RECORD_CONTRACTS = exports.RECORD_CONTRACTS = "RECORD_CONTRACTS";
function recordContracts(contexts, sources) {
  return {
    type: RECORD_CONTRACTS,
    contexts,
    sources
  };
}

const SAVE_TRANSACTION = exports.SAVE_TRANSACTION = "SAVE_TRANSACTION";
function saveTransaction(transaction) {
  return {
    type: SAVE_TRANSACTION,
    transaction
  };
}

const SAVE_RECEIPT = exports.SAVE_RECEIPT = "SAVE_RECEIPT";
function saveReceipt(receipt) {
  return {
    type: SAVE_RECEIPT,
    receipt
  };
}

const SAVE_BLOCK = exports.SAVE_BLOCK = "SAVE_BLOCK";
function saveBlock(block) {
  return {
    type: SAVE_BLOCK,
    block
  };
}

/***/ }),
/* 15 */
/***/ (function(module, exports) {

module.exports = require("bn.js");

/***/ }),
/* 16 */
/***/ (function(module, exports) {

module.exports = require("babel-runtime/core-js/object/keys");

/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends2 = __webpack_require__(2);

var _extends3 = _interopRequireDefault(_extends2);

exports.scope = scope;
exports.declare = declare;
exports.defineType = defineType;
exports.decode = decode;
exports.reset = reset;
exports.recordAllocations = recordAllocations;
exports.saga = saga;

var _debug = __webpack_require__(0);

var _debug2 = _interopRequireDefault(_debug);

var _effects = __webpack_require__(5);

var _helpers = __webpack_require__(1);

var _actions = __webpack_require__(12);

var _actions2 = __webpack_require__(27);

var actions = _interopRequireWildcard(_actions2);

var _sagas = __webpack_require__(13);

var trace = _interopRequireWildcard(_sagas);

var _sagas2 = __webpack_require__(23);

var evm = _interopRequireWildcard(_sagas2);

var _sagas3 = __webpack_require__(30);

var web3 = _interopRequireWildcard(_sagas3);

var _selectors = __webpack_require__(21);

var _selectors2 = _interopRequireDefault(_selectors);

var _lodash = __webpack_require__(58);

var _lodash2 = _interopRequireDefault(_lodash);

var _truffleDecodeUtils = __webpack_require__(4);

var DecodeUtils = _interopRequireWildcard(_truffleDecodeUtils);

var _truffleDecoder = __webpack_require__(32);

var _bn = __webpack_require__(15);

var _bn2 = _interopRequireDefault(_bn);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const debug = (0, _debug2.default)("debugger:data:sagas");

function* scope(nodeId, pointer, parentId, sourceId) {
  yield (0, _effects.put)(actions.scope(nodeId, pointer, parentId, sourceId));
}

function* declare(node) {
  yield (0, _effects.put)(actions.declare(node));
}

function* defineType(node) {
  yield (0, _effects.put)(actions.defineType(node));
}

function* tickSaga() {
  debug("got TICK");

  yield* variablesAndMappingsSaga();
  debug("about to SUBTOCK");
  yield* trace.signalTickSagaCompletion();
}

function* decode(definition, ref) {
  let referenceDeclarations = yield (0, _effects.select)(_selectors2.default.views.referenceDeclarations);
  let state = yield (0, _effects.select)(_selectors2.default.current.state);
  let mappingKeys = yield (0, _effects.select)(_selectors2.default.views.mappingKeys);
  let allocations = yield (0, _effects.select)(_selectors2.default.info.allocations);
  let instances = yield (0, _effects.select)(_selectors2.default.views.instances);
  let contexts = yield (0, _effects.select)(_selectors2.default.views.contexts);
  let currentContext = yield (0, _effects.select)(_selectors2.default.current.context);
  let internalFunctionsTable = yield (0, _effects.select)(_selectors2.default.current.functionsByProgramCounter);
  let blockNumber = yield (0, _effects.select)(_selectors2.default.views.blockNumber);

  let ZERO_WORD = new Uint8Array(DecodeUtils.EVM.WORD_SIZE);
  ZERO_WORD.fill(0);
  let NO_CODE = new Uint8Array(); //empty array

  let decoder = (0, _truffleDecoder.forEvmState)(definition, ref, {
    referenceDeclarations,
    state,
    mappingKeys,
    storageAllocations: allocations.storage,
    memoryAllocations: allocations.memory,
    calldataAllocations: allocations.calldata,
    contexts,
    currentContext,
    internalFunctionsTable
  });

  let result = decoder.next();
  while (!result.done) {
    let request = result.value;
    let response;
    switch (request.type) {
      case "storage":
        //the debugger supplies all storage it knows at the beginning.
        //any storage it does not know is presumed to be zero.
        response = ZERO_WORD;
        break;
      case "code":
        let address = request.address;
        if (address in instances) {
          response = instances[address];
        } else if (address === DecodeUtils.EVM.ZERO_ADDRESS) {
          //HACK: to avoid displaying the zero address to the user as an
          //affected address just because they decoded a contract or external
          //function variable that hadn't been initialized yet, we give the
          //zero address's codelessness its own private cache :P
          response = NO_CODE;
        } else {
          //I don't want to write a new web3 saga, so let's just use
          //obtainBinaries with a one-element array
          debug("fetching binary");
          let binary = (yield* web3.obtainBinaries([address], blockNumber))[0];
          debug("adding instance");
          yield* evm.addInstance(address, binary);
          response = DecodeUtils.Conversion.toBytes(binary);
        }
        break;
      default:
        debug("unrecognized request type!");
    }
    result = decoder.next(response);
  }
  //at this point, result.value holds the final value
  //note: we're still using the old decoder output format, so we need to clean
  //containers before returning something the debugger can use
  return DecodeUtils.Conversion.cleanContainers(result.value);
}

function* variablesAndMappingsSaga() {
  let node = yield (0, _effects.select)(_selectors2.default.current.node);
  let scopes = yield (0, _effects.select)(_selectors2.default.views.scopes.inlined);
  let referenceDeclarations = yield (0, _effects.select)(_selectors2.default.views.referenceDeclarations);
  let allocations = yield (0, _effects.select)(_selectors2.default.info.allocations.storage);
  let currentAssignments = yield (0, _effects.select)(_selectors2.default.proc.assignments);
  let mappedPaths = yield (0, _effects.select)(_selectors2.default.proc.mappedPaths);
  let currentDepth = yield (0, _effects.select)(_selectors2.default.current.functionDepth);
  let address = yield (0, _effects.select)(_selectors2.default.current.address);
  //storage address, not code address

  let stack = yield (0, _effects.select)(_selectors2.default.next.state.stack); //note the use of next!
  //in this saga we are interested in the *results* of the current instruction
  //note that the decoder is still based on data.current.state; that's fine
  //though.  There's already a delay between when we record things off the
  //stack and when we decode them, after all.  Basically, nothing serious
  //should happen after an index node but before the index access node that
  //would cause storage, memory, or calldata to change, meaning that even if
  //the literal we recorded was a pointer, it will still be valid at the time
  //we use it.  (The other literals we make use of, for the base expressions,
  //are not decoded, so no potential mismatch there would be relevant anyway.)

  let alternateStack = yield (0, _effects.select)(_selectors2.default.nextMapped.state.stack);
  //HACK: unfortunately, in some cases, data.next.state.stack gets the wrong
  //results due to unmapped instructions intervening.  So, we get the stack at
  //the next *mapped* stack instead.  This is something of a hack and won't
  //work if we're about to change context, but it should work in the cases that
  //need it.

  if (!stack) {
    return;
  }

  let top = stack.length - 1;
  var assignment, assignments, preambleAssignments, baseExpression, slot, path;

  if (!node) {
    return;
  }

  // stack is only ready for interpretation after the last step of each
  // source range
  //
  // the data module always looks at the result of a particular opcode
  // (i.e., the following trace step's stack/memory/storage), so this
  // asserts that the _current_ operation is the final one before
  // proceeding
  if (!(yield (0, _effects.select)(_selectors2.default.views.atLastInstructionForSourceRange))) {
    return;
  }

  //HACK: modifier preamble
  //modifier definitions are typically skipped (this includes constructor
  //definitions when called as a base constructor); as such I've added this
  //"modifier preamble" to catch them
  if (yield (0, _effects.select)(_selectors2.default.current.aboutToModify)) {
    let modifier = yield (0, _effects.select)(_selectors2.default.current.modifierBeingInvoked);
    //may be either a modifier or base constructor
    let currentIndex = yield (0, _effects.select)(_selectors2.default.current.modifierArgumentIndex);
    debug("currentIndex %d", currentIndex);
    let parameters = modifier.parameters.parameters;
    //now: look at the parameters *after* the current index.  we'll need to
    //adjust for those.
    let parametersLeft = parameters.slice(currentIndex + 1);
    let adjustment = (0, _lodash2.default)(parametersLeft.map(DecodeUtils.Definition.stackSize));
    debug("adjustment %d", adjustment);
    preambleAssignments = assignParameters(parameters, top + adjustment, currentDepth);
  } else {
    preambleAssignments = {};
  }

  switch (node.nodeType) {
    case "FunctionDefinition":
    case "ModifierDefinition":
      //NOTE: this will *not* catch most modifier definitions!
      //the rest hopefully will be caught by the modifier preamble
      //(in fact they won't all be, but...)

      //HACK: filter out some garbage
      //this filters out the case where we're really in an invocation of a
      //modifier or base constructor, but have temporarily hit the definition
      //node for some reason.  However this obviously can have a false positive
      //in the case where a function has the same modifier twice.
      let nextModifier = yield (0, _effects.select)(_selectors2.default.next.modifierBeingInvoked);
      if (nextModifier && nextModifier.id === node.id) {
        break;
      }

      let parameters = node.parameters.parameters;
      //note that we do *not* include return parameters, since those are
      //handled by the VariableDeclaration case (no, I don't know why it
      //works out that way)

      //we can skip preambleAssignments here, that isn't used in this case
      assignments = assignParameters(parameters, top, currentDepth);

      debug("Function definition case");
      debug("assignments %O", assignments);

      yield (0, _effects.put)(actions.assign(assignments));
      break;

    case "ContractDefinition":
      let allocation = allocations[node.id];

      debug("Contract definition case");
      debug("allocations %O", allocations);
      debug("allocation %O", allocation);
      assignments = {};
      for (let id in allocation.members) {
        id = Number(id); //not sure why we're getting them as strings, but...
        let idObj = { astId: id, address };
        let fullId = (0, _helpers.stableKeccak256)(idObj);
        //we don't use makeAssignment here as we had to compute the ID anyway
        assignment = (0, _extends3.default)({}, idObj, {
          id: fullId,
          ref: (0, _extends3.default)({}, (currentAssignments.byId[fullId] || {}).ref || {}, allocation.members[id].pointer)
        });
        assignments[fullId] = assignment;
      }
      debug("assignments %O", assignments);

      //this case doesn't need preambleAssignments either
      yield (0, _effects.put)(actions.assign(assignments));
      break;

    case "FunctionTypeName":
      //HACK
      //for some reasons, for declarations of local variables of function type,
      //we land on the FunctionTypeName instead of the VariableDeclaration,
      //so we replace the node with its parent (the VariableDeclaration)
      node = scopes[scopes[node.id].parentId].definition;
      //let's do a quick check that it *is* a VariableDeclaration before
      //continuing
      if (node.nodeType !== "VariableDeclaration") {
        break;
      }
    //otherwise, deliberately fall through to the VariableDeclaration case
    //NOTE: DELIBERATE FALL-THROUGH
    case "VariableDeclaration":
      let varId = node.id;
      debug("Variable declaration case");
      debug("currentDepth %d varId %d", currentDepth, varId);

      //NOTE: We're going to make the assignment conditional here; here's why.
      //There's a bug where calling the autogenerated accessor for a public
      //contract variable causes the debugger to see two additional
      //declarations for that variable... which this code reads as local
      //variable declarations.  Rather than prevent this at the source, we're
      //just going to check for it here, by not adding a local variable if said
      //variable is already a contract variable.

      if (currentAssignments.byAstId[varId] !== undefined && currentAssignments.byAstId[varId].some(id => currentAssignments.byId[id].address !== undefined)) {
        debug("already a contract variable!");
        break;
      }

      //otherwise, go ahead and make the assignment
      assignment = (0, _helpers.makeAssignment)({ astId: varId, stackframe: currentDepth }, {
        stack: {
          from: top - DecodeUtils.Definition.stackSize(node) + 1,
          to: top
        }
      });
      assignments = { [assignment.id]: assignment };
      //this case doesn't need preambleAssignments either
      debug("assignments: %O", assignments);
      yield (0, _effects.put)(actions.assign(assignments));
      break;

    case "IndexAccess":
      // to track `mapping` types known indices
      // (and also *some* known indices for arrays)

      //HACK: we use the alternate stack in this case

      debug("Index access case");

      //we're going to start by doing the same thing as in the default case
      //(see below) -- getting things ready for an assignment.  Then we're
      //going to forget this for a bit while we handle the rest...
      assignments = (0, _extends3.default)({}, preambleAssignments, literalAssignments(node, alternateStack, currentDepth));

      //we'll need this
      baseExpression = node.baseExpression;

      //but first, a diversion -- is this something that could not *possibly*
      //lead to a mapping?  i.e., either a bytes, or an array of non-reference
      //types, or a non-storage array?
      //if so, we'll just do the assign and quit out early
      //(note: we write it this way because mappings aren't caught by
      //isReference)
      if (DecodeUtils.Definition.typeClass(baseExpression) === "bytes" || DecodeUtils.Definition.typeClass(baseExpression) === "array" && (DecodeUtils.Definition.isReference(node) ? DecodeUtils.Definition.referenceType(baseExpression) !== "storage" : !DecodeUtils.Definition.isMapping(node))) {
        debug("Index case bailed out early");
        debug("typeClass %s", DecodeUtils.Definition.typeClass(baseExpression));
        debug("referenceType %s", DecodeUtils.Definition.referenceType(baseExpression));
        debug("isReference(node) %o", DecodeUtils.Definition.isReference(node));
        yield (0, _effects.put)(actions.assign(assignments));
        break;
      }

      let keyDefinition = DecodeUtils.Definition.keyDefinition(baseExpression, scopes);
      //if we're dealing with an array, this will just hack up a uint definition
      //:)

      //begin subsection: key decoding
      //(I tried factoring this out into its own saga but it didn't work when I
      //did :P )

      let indexValue;
      let indexDefinition = node.indexExpression;

      //why the loop? see the end of the block it heads for an explanatory
      //comment
      while (indexValue === undefined) {
        let indexId = indexDefinition.id;
        //indices need to be identified by stackframe
        let indexIdObj = { astId: indexId, stackframe: currentDepth };
        let fullIndexId = (0, _helpers.stableKeccak256)(indexIdObj);

        const indexReference = (currentAssignments.byId[fullIndexId] || {}).ref;

        if (DecodeUtils.Definition.isSimpleConstant(indexDefinition)) {
          //while the main case is the next one, where we look for a prior
          //assignment, we need this case (and need it first) for two reasons:
          //1. some constant expressions (specifically, string and hex literals)
          //aren't sourcemapped to and so won't have a prior assignment
          //2. if the key type is bytesN but the expression is constant, the
          //value will go on the stack *left*-padded instead of right-padded,
          //so looking for a prior assignment will read the wrong value.
          //so instead it's preferable to use the constant directly.
          debug("about to decode simple literal");
          indexValue = yield* decode(keyDefinition, {
            definition: indexDefinition
          });
        } else if (indexReference) {
          //if a prior assignment is found
          let splicedDefinition;
          //in general, we want to decode using the key definition, not the index
          //definition. however, the key definition may have the wrong location
          //on it.  so, when applicable, we splice the index definition location
          //onto the key definition location.
          if (DecodeUtils.Definition.isReference(indexDefinition)) {
            splicedDefinition = DecodeUtils.Definition.spliceLocation(keyDefinition, DecodeUtils.Definition.referenceType(indexDefinition));
            //we could put code here to add on the "_ptr" ending when absent,
            //but we presently ignore that ending, so we'll skip that
          } else {
            splicedDefinition = keyDefinition;
          }
          debug("about to decode");
          indexValue = yield* decode(splicedDefinition, indexReference);
        } else if (indexDefinition.referencedDeclaration && scopes[indexDefinition.referenceDeclaration]) {
          //there's one more reason we might have failed to decode it: it might be a
          //constant state variable.  Unfortunately, we don't know how to decode all
          //those at the moment, but we can handle the ones we do know how to decode.
          //In the future hopefully we will decode all of them
          debug("referencedDeclaration %d", indexDefinition.referencedDeclaration);
          let indexConstantDeclaration = scopes[indexDefinition.referencedDeclaration].definition;
          debug("indexConstantDeclaration %O", indexConstantDeclaration);
          if (indexConstantDeclaration.constant) {
            let indexConstantDefinition = indexConstantDeclaration.value;
            //next line filters out constants we don't know how to handle
            if (DecodeUtils.Definition.isSimpleConstant(indexConstantDefinition)) {
              debug("about to decode simple constant");
              indexValue = yield* decode(keyDefinition, {
                definition: indexConstantDeclaration.value
              });
            }
          }
        }
        //there's still one more reason we might have failed to decode it:
        //certain (silent) type conversions aren't sourcemapped either.
        //(thankfully, any type conversion that actually *does* something seems
        //to be sourcemapped.)  So if we've failed to decode it, we try again
        //with the argument of the type conversion, if it is one; we leave
        //indexValue undefined so the loop will continue
        //(note that this case is last for a reason; if this were earlier, it
        //would catch *non*-silent type conversions, which we want to just read
        //off the stack)
        else if (indexDefinition.kind === "typeConversion") {
            indexDefinition = indexDefinition.arguments[0];
          }
          //otherwise, we've just totally failed to decode it, so we mark
          //indexValue as null (as distinct from undefined) to indicate this.  In
          //the future, we should be able to decode all mapping keys, but we're
          //not quite there yet, sorry (because we can't yet handle all constant
          //state variables)
          else {
              indexValue = null;
            }
        //now, as mentioned, retry in the typeConversion case
      }

      //end subsection: key decoding

      debug("index value %O", indexValue);
      debug("keyDefinition %o", keyDefinition);

      //whew! But we're not done yet -- we need to turn this decoded key into
      //an actual path (assuming we *did* decode it)
      //OK, not an actual path -- we're just going to use a simple offset for
      //the path.  But that's OK, because the mappedPaths reducer will turn
      //it into an actual path.
      if (indexValue !== null) {
        path = fetchBasePath(baseExpression, mappedPaths, currentAssignments, currentDepth);

        let slot = { path };

        //we need to do things differently depending on whether we're dealing
        //with an array or mapping
        switch (DecodeUtils.Definition.typeClass(baseExpression)) {
          case "array":
            slot.hashPath = DecodeUtils.Definition.isDynamicArray(baseExpression);
            slot.offset = indexValue.muln((0, _truffleDecoder.storageSize)(node, referenceDeclarations, allocations).words);
            break;
          case "mapping":
            slot.key = indexValue;
            slot.keyEncoding = DecodeUtils.Definition.keyEncoding(keyDefinition);
            slot.offset = new _bn2.default(0);
            break;
          default:
            debug("unrecognized index access!");
        }
        debug("slot %O", slot);

        //now, map it! (and do the assign as well)
        yield (0, _effects.put)(actions.mapPathAndAssign(address, slot, assignments, DecodeUtils.Definition.typeIdentifier(node), DecodeUtils.Definition.typeIdentifier(baseExpression)));
      } else {
        //if we failed to decode, just do the assign from above
        debug("failed to decode, just assigning");
        yield (0, _effects.put)(actions.assign(assignments));
      }

      break;

    case "MemberAccess":
      //HACK: we use the alternate stack in this case

      //we're going to start by doing the same thing as in the default case
      //(see below) -- getting things ready for an assignment.  Then we're
      //going to forget this for a bit while we handle the rest...
      assignments = (0, _extends3.default)({}, preambleAssignments, literalAssignments(node, alternateStack, currentDepth));

      debug("Member access case");

      //MemberAccess uses expression, not baseExpression
      baseExpression = node.expression;

      //if this isn't a storage struct, or the element isn't of reference type,
      //we'll just do the assignment and quit out (again, note that mappings
      //aren't caught by isReference)
      if (DecodeUtils.Definition.typeClass(baseExpression) !== "struct" || (DecodeUtils.Definition.isReference(node) ? DecodeUtils.Definition.referenceType(baseExpression) !== "storage" : !DecodeUtils.Definition.isMapping(node))) {
        debug("Member case bailed out early");
        yield (0, _effects.put)(actions.assign(assignments));
        break;
      }

      //but if it is a storage struct, we have to map the path as well
      path = fetchBasePath(baseExpression, mappedPaths, currentAssignments, currentDepth);

      slot = { path };

      let structId = DecodeUtils.Definition.typeId(baseExpression);
      let memberAllocation = allocations[structId].members[node.referencedDeclaration];

      slot.offset = memberAllocation.pointer.storage.from.slot.offset.clone();

      debug("slot %o", slot);
      yield (0, _effects.put)(actions.mapPathAndAssign(address, slot, assignments, DecodeUtils.Definition.typeIdentifier(node), DecodeUtils.Definition.typeIdentifier(baseExpression)));

    default:
      if (node.typeDescriptions == undefined) {
        break;
      }

      debug("decoding expression value %O", node.typeDescriptions);
      debug("default case");
      debug("currentDepth %d node.id %d", currentDepth, node.id);

      assignments = (0, _extends3.default)({}, preambleAssignments, literalAssignments(node, stack, currentDepth));
      yield (0, _effects.put)(actions.assign(assignments));
      break;
  }
}

function* reset() {
  yield (0, _effects.put)(actions.reset());
}

function* recordAllocations() {
  const contracts = yield (0, _effects.select)(_selectors2.default.views.userDefinedTypes.contractDefinitions);
  debug("contracts %O", contracts);
  const referenceDeclarations = yield (0, _effects.select)(_selectors2.default.views.referenceDeclarations);
  debug("referenceDeclarations %O", referenceDeclarations);
  const storageAllocations = (0, _truffleDecoder.getStorageAllocations)(referenceDeclarations, contracts);
  debug("storageAllocations %O", storageAllocations);
  const memoryAllocations = (0, _truffleDecoder.getMemoryAllocations)(referenceDeclarations);
  const calldataAllocations = (0, _truffleDecoder.getCalldataAllocations)(referenceDeclarations);
  yield (0, _effects.put)(actions.allocate(storageAllocations, memoryAllocations, calldataAllocations));
}

function literalAssignments(node, stack, currentDepth) {
  let top = stack.length - 1;

  let literal = (0, _truffleDecoder.readStack)(stack, top - DecodeUtils.Definition.stackSize(node) + 1, top);

  let assignment = (0, _helpers.makeAssignment)({ astId: node.id, stackframe: currentDepth }, { literal });

  return { [assignment.id]: assignment };
}

//takes a parameter list as given in the AST
function assignParameters(parameters, top, functionDepth) {
  let reverseParameters = parameters.slice().reverse();
  //reverse is in-place, so we use slice() to clone first
  debug("reverseParameters %o", parameters);

  let currentPosition = top;
  let assignments = {};

  for (let parameter of reverseParameters) {
    let words = DecodeUtils.Definition.stackSize(parameter);
    let pointer = {
      stack: {
        from: currentPosition - words + 1,
        to: currentPosition
      }
    };
    let assignment = (0, _helpers.makeAssignment)({ astId: parameter.id, stackframe: functionDepth }, pointer);
    assignments[assignment.id] = assignment;
    currentPosition -= words;
  }
  return assignments;
}

function fetchBasePath(baseNode, mappedPaths, currentAssignments, currentDepth) {
  let fullId = (0, _helpers.stableKeccak256)({
    astId: baseNode.id,
    stackframe: currentDepth
  });
  debug("astId: %d", baseNode.id);
  debug("stackframe: %d", currentDepth);
  debug("fullId: %s", fullId);
  debug("currentAssignments: %O", currentAssignments);
  //base expression is an expression, and so has a literal assigned to
  //it
  let offset = DecodeUtils.Conversion.toBN(currentAssignments.byId[fullId].ref.literal);
  return { offset };
}

function* saga() {
  yield (0, _effects.takeEvery)(_actions.TICK, tickSaga);
}

exports.default = (0, _helpers.prefixName)("data", saga);

/***/ }),
/* 18 */
/***/ (function(module, exports) {

module.exports = require("babel-runtime/helpers/asyncToGenerator");

/***/ }),
/* 19 */
/***/ (function(module, exports) {

module.exports = require("babel-runtime/core-js/object/values");

/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.advance = advance;
exports.stepNext = stepNext;
exports.stepOver = stepOver;
exports.stepInto = stepInto;
exports.stepOut = stepOut;
exports.reset = reset;
exports.interrupt = interrupt;
exports.continueUntilBreakpoint = continueUntilBreakpoint;
exports.addBreakpoint = addBreakpoint;
exports.removeBreakpoint = removeBreakpoint;
exports.removeAllBreakpoints = removeAllBreakpoints;
exports.startStepping = startStepping;
exports.doneStepping = doneStepping;
const ADVANCE = exports.ADVANCE = "ADVANCE";
function advance(count) {
  return { type: ADVANCE, count };
}

const STEP_NEXT = exports.STEP_NEXT = "STEP_NEXT";
function stepNext() {
  return { type: STEP_NEXT };
}

const STEP_OVER = exports.STEP_OVER = "STEP_OVER";
function stepOver() {
  return { type: STEP_OVER };
}

const STEP_INTO = exports.STEP_INTO = "STEP_INTO";
function stepInto() {
  return { type: STEP_INTO };
}

const STEP_OUT = exports.STEP_OUT = "STEP_OUT";
function stepOut() {
  return { type: STEP_OUT };
}

const RESET = exports.RESET = "RESET";
function reset() {
  return { type: RESET };
}

const INTERRUPT = exports.INTERRUPT = "CONTROLLER_INTERRUPT";
function interrupt() {
  return { type: INTERRUPT };
}

const CONTINUE = exports.CONTINUE = "CONTINUE";
function continueUntilBreakpoint(breakpoints) {
  //"continue" is not a legal name
  return {
    type: CONTINUE,
    breakpoints
  };
}

const ADD_BREAKPOINT = exports.ADD_BREAKPOINT = "ADD_BREAKPOINT";
function addBreakpoint(breakpoint) {
  return {
    type: ADD_BREAKPOINT,
    breakpoint
  };
}

const REMOVE_BREAKPOINT = exports.REMOVE_BREAKPOINT = "REMOVE_BREAKPOINT";
function removeBreakpoint(breakpoint) {
  return {
    type: REMOVE_BREAKPOINT,
    breakpoint
  };
}

const REMOVE_ALL_BREAKPOINTS = exports.REMOVE_ALL_BREAKPOINTS = "REMOVE_ALL_BREAKPOINTS";
function removeAllBreakpoints() {
  return {
    type: REMOVE_ALL_BREAKPOINTS
  };
}

const START_STEPPING = exports.START_STEPPING = "START_STEPPING";
function startStepping() {
  return {
    type: START_STEPPING
  };
}

const DONE_STEPPING = exports.DONE_STEPPING = "DONE_STEPPING";
function doneStepping() {
  return {
    type: DONE_STEPPING
  };
}

/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _values = __webpack_require__(19);

var _values2 = _interopRequireDefault(_values);

var _extends2 = __webpack_require__(2);

var _extends3 = _interopRequireDefault(_extends2);

var _entries = __webpack_require__(6);

var _entries2 = _interopRequireDefault(_entries);

var _assign = __webpack_require__(8);

var _assign2 = _interopRequireDefault(_assign);

var _debug = __webpack_require__(0);

var _debug2 = _interopRequireDefault(_debug);

var _reselectTree = __webpack_require__(3);

var _jsonPointer = __webpack_require__(22);

var _jsonPointer2 = _interopRequireDefault(_jsonPointer);

var _helpers = __webpack_require__(1);

var _selectors = __webpack_require__(9);

var _selectors2 = _interopRequireDefault(_selectors);

var _selectors3 = __webpack_require__(11);

var _selectors4 = _interopRequireDefault(_selectors3);

var _truffleDecodeUtils = __webpack_require__(4);

var DecodeUtils = _interopRequireWildcard(_truffleDecodeUtils);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const debug = (0, _debug2.default)("debugger:data:selectors");

/**
 * @private
 */
const identity = x => x;

function findAncestorOfType(node, types, scopes) {
  //note: I'm not including any protection against null in this function.
  //You are advised to include "SourceUnit" as a fallback type.
  while (node && !types.includes(node.nodeType)) {
    node = scopes[scopes[node.id].parentId].definition;
  }
  return node;
}

//given a modifier invocation (or inheritance specifier) node,
//get the node for the actual modifier (or constructor)
function modifierForInvocation(invocation, scopes) {
  let rawId; //raw referencedDeclaration ID extracted from the AST.
  //if it's a modifier this is what we want, but if it's base
  //constructor, we'll get the contract instead, and need to find its
  //constructor.
  switch (invocation.nodeType) {
    case "ModifierInvocation":
      rawId = invocation.modifierName.referencedDeclaration;
      break;
    case "InheritanceSpecifier":
      rawId = invocation.baseName.referencedDeclaration;
      break;
    default:
      debug("bad invocation node");
  }
  let rawNode = scopes[rawId].definition;
  switch (rawNode.nodeType) {
    case "ModifierDefinition":
      return rawNode;
    case "ContractDefinition":
      return rawNode.nodes.find(node => node.nodeType === "FunctionDefinition" && node.kind === "constructor");
    default:
      //we should never hit this case
      return undefined;
  }
}

//see data.views.contexts for an explanation
function debuggerContextToDecoderContext(context) {
  let {
    contractName,
    binary,
    contractId,
    contractKind,
    isConstructor,
    abi
  } = context;
  return {
    contractName,
    binary,
    contractId,
    contractKind,
    isConstructor,
    abi: DecodeUtils.Contexts.abiToFunctionAbiWithSignatures(abi)
  };
}

const data = (0, _reselectTree.createSelectorTree)({
  state: state => state.data,

  /**
   * data.views
   */
  views: {
    /*
     * data.views.atLastInstructionForSourceRange
     */
    atLastInstructionForSourceRange: (0, _reselectTree.createLeaf)([_selectors4.default.current.isSourceRangeFinal], final => final),

    /**
     * data.views.scopes (namespace)
     */
    scopes: {
      /**
       * data.views.scopes.inlined (namespace)
       */
      inlined: {
        /**
         * data.views.scopes.inlined (selector)
         * see data.info.scopes for how this differs from the raw version
         */
        _: (0, _reselectTree.createLeaf)(["/info/scopes", "./raw"], (scopes, inlined) => (0, _assign2.default)({}, ...(0, _entries2.default)(inlined).map(([id, info]) => {
          let newInfo = (0, _extends3.default)({}, info);
          newInfo.variables = scopes[id].variables;
          return { [id]: newInfo };
        }))),

        /**
         * data.views.scopes.inlined.raw
         */
        raw: (0, _reselectTree.createLeaf)(["/info/scopes/raw", _selectors4.default.info.sources], (scopes, sources) => (0, _assign2.default)({}, ...(0, _entries2.default)(scopes).map(([id, entry]) => ({
          [id]: (0, _extends3.default)({}, entry, {

            definition: _jsonPointer2.default.get(sources[entry.sourceId].ast, entry.pointer)
          })
        }))))
      }
    },

    /*
     * data.views.userDefinedTypes
     */
    userDefinedTypes: {
      /*
       * data.views.userDefinedTypes.contractDefinitions
       * restrict to contracts only, and get their definitions
       */
      contractDefinitions: (0, _reselectTree.createLeaf)(["/info/userDefinedTypes", "/views/scopes/inlined"], (typeIds, scopes) => typeIds.map(id => scopes[id].definition).filter(node => node.nodeType === "ContractDefinition"))
    },

    /*
     * data.views.referenceDeclarations
     */
    referenceDeclarations: (0, _reselectTree.createLeaf)(["./scopes/inlined", "/info/userDefinedTypes"], (scopes, userDefinedTypes) => (0, _assign2.default)({}, ...userDefinedTypes.map(id => ({ [id]: scopes[id].definition })))),

    /**
     * data.views.mappingKeys
     */
    mappingKeys: (0, _reselectTree.createLeaf)(["/proc/mappedPaths", "/current/address"], (mappedPaths, address) => [].concat(...(0, _values2.default)((mappedPaths.byAddress[address] || { byType: {} }).byType).map(({ bySlotAddress }) => (0, _values2.default)(bySlotAddress))).filter(slot => slot.key !== undefined)),

    /*
     * data.views.blockNumber
     * returns block number as string
     */
    blockNumber: (0, _reselectTree.createLeaf)([_selectors2.default.transaction.globals.block], block => block.number.toString()),

    /*
     * data.views.instances
     * same as evm.current.codex.instances, but we just map address => binary,
     * we don't bother with context, and also the code is a Uint8Array
     */
    instances: (0, _reselectTree.createLeaf)([_selectors2.default.current.codex.instances], instances => (0, _assign2.default)({}, ...(0, _entries2.default)(instances).map(([address, { binary }]) => ({
      [address]: DecodeUtils.Conversion.toBytes(binary)
    })))),

    /*
     * data.views.contexts
     * same as evm.info.contexts, but:
     * 0. we only include non-constructor contexts
     * 1. we now index by contract ID rather than hash
     * 2. we strip out context, sourceMap, primarySource, and compiler
     * 3. we alter abi in several ways:
     * 3a. we strip abi down to just (ordinary) functions
     * 3b. we augment these functions with signatures (here meaning selectors)
     * 3c. abi is now an object, not an array, and indexed by these signatures
     */
    contexts: (0, _reselectTree.createLeaf)([_selectors2.default.info.contexts], contexts => (0, _assign2.default)({}, ...(0, _values2.default)(contexts).filter(context => !context.isConstructor).map(context => ({
      [context.contractId]: debuggerContextToDecoderContext(context)
    }))))
  },

  /**
   * data.info
   */
  info: {
    /**
     * data.info.scopes (namespace)
     */
    scopes: {
      /**
       * data.info.scopes (selector)
       * the raw version is below; this version accounts for inheritance
       * NOTE: doesn't this selector really belong in data.views?  Yes.
       * But, since it's replacing the old data.info.scopes (which is now
       * data.info.scopes.raw), I didn't want to move it.
       */
      _: (0, _reselectTree.createLeaf)(["./raw", "/views/scopes/inlined/raw"], (scopes, inlined) => (0, _assign2.default)({}, ...(0, _entries2.default)(scopes).map(([id, scope]) => {
        let definition = inlined[id].definition;
        if (definition.nodeType !== "ContractDefinition") {
          return { [id]: scope };
        }
        //if we've reached this point, we should be dealing with a
        //contract, and specifically a contract -- not an interface or
        //library (those don't get "variables" entries in their scopes)
        debug("contract id %d", id);
        let newScope = (0, _extends3.default)({}, scope);
        //note that Solidity gives us the linearization in order from most
        //derived to most base, but we want most base to most derived;
        //annoyingly, reverse() is in-place, so we clone with slice() first
        let linearizedBaseContractsFromBase = definition.linearizedBaseContracts.slice().reverse();
        //now, we put it all together
        newScope.variables = [].concat(...linearizedBaseContractsFromBase.map(contractId => scopes[contractId].variables || []
        //we need the || [] because contracts with no state variables
        //have variables undefined rather than empty like you'd expect
        )).filter(variable => {
          //...except, HACK, let's filter out those constants we don't know
          //how to read.  they'll just clutter things up.
          debug("variable %O", variable);
          let definition = inlined[variable.id].definition;
          return !definition.constant || DecodeUtils.Definition.isSimpleConstant(definition.value);
        });

        return { [id]: newScope };
      }))),

      /*
       * data.info.scopes.raw
       */
      raw: (0, _reselectTree.createLeaf)(["/state"], state => state.info.scopes.byId)
    },

    /*
     * data.info.allocations
     */
    allocations: {
      /*
       * data.info.allocations.storage
       */
      storage: (0, _reselectTree.createLeaf)(["/state"], state => state.info.allocations.storage),

      /*
       * data.info.allocations.memory
       */
      memory: (0, _reselectTree.createLeaf)(["/state"], state => state.info.allocations.memory),

      /*
       * data.info.allocations.calldata
       */
      calldata: (0, _reselectTree.createLeaf)(["/state"], state => state.info.allocations.calldata)
    },

    /**
     * data.info.userDefinedTypes
     */
    userDefinedTypes: (0, _reselectTree.createLeaf)(["/state"], state => state.info.userDefinedTypes)
  },

  /**
   * data.proc
   */
  proc: {
    /**
     * data.proc.assignments
     */
    assignments: (0, _reselectTree.createLeaf)(["/state"], state => state.proc.assignments
    //note: this no longer fetches just the byId, but rather the whole
    //assignments object
    ),

    /*
     * data.proc.mappedPaths
     */
    mappedPaths: (0, _reselectTree.createLeaf)(["/state"], state => state.proc.mappedPaths),

    /**
     * data.proc.decodingKeys
     *
     * number of keys that are still decoding
     */
    decodingKeys: (0, _reselectTree.createLeaf)(["./mappedPaths"], mappedPaths => mappedPaths.decodingStarted)
  },

  /**
   * data.current
   */
  current: {
    /**
     * data.current.state
     */
    state: {
      /**
       * data.current.state.stack
       */
      stack: (0, _reselectTree.createLeaf)([_selectors2.default.current.state.stack], words => (words || []).map(word => DecodeUtils.Conversion.toBytes(word))),

      /**
       * data.current.state.memory
       */
      memory: (0, _reselectTree.createLeaf)([_selectors2.default.current.state.memory], words => DecodeUtils.Conversion.toBytes(words.join(""))),

      /**
       * data.current.state.calldata
       */
      calldata: (0, _reselectTree.createLeaf)([_selectors2.default.current.call], ({ data }) => DecodeUtils.Conversion.toBytes(data)),

      /**
       * data.current.state.storage
       */
      storage: (0, _reselectTree.createLeaf)([_selectors2.default.current.codex.storage], mapping => (0, _assign2.default)({}, ...(0, _entries2.default)(mapping).map(([address, word]) => ({
        [`0x${address}`]: DecodeUtils.Conversion.toBytes(word)
      })))),

      /*
       * data.current.state.specials
       * I've named these after the solidity variables they correspond to,
       * which are *mostly* the same as the corresponding EVM opcodes
       * (FWIW: this = ADDRESS, sender = CALLER, value = CALLVALUE)
       */
      specials: (0, _reselectTree.createLeaf)(["/current/address", _selectors2.default.current.call, _selectors2.default.transaction.globals], (address, { sender, value }, { tx, block }) => (0, _extends3.default)({
        this: DecodeUtils.Conversion.toBytes(address),

        sender: DecodeUtils.Conversion.toBytes(sender),

        value: DecodeUtils.Conversion.toBytes(value)

      }, (0, _assign2.default)({}, ...(0, _entries2.default)(tx).map(([variable, value]) => ({
        [variable]: DecodeUtils.Conversion.toBytes(value)
      }))), (0, _assign2.default)({}, ...(0, _entries2.default)(block).map(([variable, value]) => ({
        [variable]: DecodeUtils.Conversion.toBytes(value)
      })))))
    },

    /**
     * data.current.node
     */
    node: (0, _reselectTree.createLeaf)([_selectors4.default.current.node], identity),

    /**
     * data.current.scope
     * old alias for data.current.node (deprecated)
     */
    scope: (0, _reselectTree.createLeaf)(["./node"], identity),

    /*
     * data.current.contract
     * warning: may return null or similar, even though SourceUnit is included
     * as fallback
     */
    contract: (0, _reselectTree.createLeaf)(["./node", "/views/scopes/inlined"], (node, scopes) => {
      const types = ["ContractDefinition", "SourceUnit"];
      //SourceUnit included as fallback
      return findAncestorOfType(node, types, scopes);
    }),

    /**
     * data.current.functionDepth
     */

    functionDepth: (0, _reselectTree.createLeaf)([_selectors4.default.current.functionDepth], identity),

    /**
     * data.current.address
     * NOTE: this is the STORAGE address for the current call, not the CODE
     * address
     */

    address: (0, _reselectTree.createLeaf)([_selectors2.default.current.call], call => call.storageAddress),

    /*
     * data.current.functionsByProgramCounter
     */
    functionsByProgramCounter: (0, _reselectTree.createLeaf)([_selectors4.default.current.functionsByProgramCounter], functions => functions),

    /*
     * data.current.context
     */
    context: (0, _reselectTree.createLeaf)([_selectors2.default.current.context], debuggerContextToDecoderContext),

    /*
     * data.current.aboutToModify
     * HACK
     * This selector is used to catch those times when we go straight from a
     * modifier invocation into the modifier itself, skipping over the
     * definition node (this includes base constructor calls).  So it should
     * return true when:
     * 1. we're on the node corresponding to an argument to a modifier
     * invocation or base constructor call, or, if said argument is a type
     * conversion, its argument (or nested argument)
     * 2. the next node is not a FunctionDefinition, ModifierDefinition, or
     * in the same modifier / base constructor invocation
     */
    aboutToModify: (0, _reselectTree.createLeaf)(["./node", "./modifierInvocation", "./modifierArgumentIndex", "/next/node", "/next/modifierInvocation", _selectors2.default.current.step.isContextChange], (node, invocation, index, next, nextInvocation, isContextChange) => {
      //ensure: current instruction is not a context change (because if it is
      //we cannot rely on the data.next selectors, but also if it is we know
      //we're not about to call a modifier or base constructor!)
      //we also want to return false if we can't find things for whatever
      //reason
      if (isContextChange || !node || !next || !invocation || !nextInvocation) {
        return false;
      }

      //ensure: current position is in a ModifierInvocation or
      //InheritanceSpecifier (recall that SourceUnit was included as
      //fallback)
      if (invocation.nodeType === "SourceUnit") {
        return false;
      }

      //ensure: next node is not a function definition or modifier definition
      if (next.nodeType === "FunctionDefinition" || next.nodeType === "ModifierDefinition") {
        return false;
      }

      //ensure: next node is not in the same invocation
      if (nextInvocation.nodeType !== "SourceUnit" && nextInvocation.id === invocation.id) {
        return false;
      }

      //now: are we on the node corresponding to an argument, or, if
      //it's a type conversion, its nested argument?
      if (index === undefined) {
        return false;
      }
      let argument = invocation.arguments[index];
      while (argument.kind === "typeConversion") {
        if (node.id === argument.id) {
          return true;
        }
        argument = argument.arguments[0];
      }
      return node.id === argument.id;
    }),

    /*
     * data.current.modifierInvocation
     */
    modifierInvocation: (0, _reselectTree.createLeaf)(["./node", "/views/scopes/inlined"], (node, scopes) => {
      const types = ["ModifierInvocation", "InheritanceSpecifier", "SourceUnit"];
      //again, SourceUnit included as fallback
      return findAncestorOfType(node, types, scopes);
    }),

    /**
     * data.current.modifierArgumentIndex
     * gets the index of the current modifier argument that you're in
     * (undefined when not in a modifier argument)
     */
    modifierArgumentIndex: (0, _reselectTree.createLeaf)(["/info/scopes", "./node", "./modifierInvocation"], (scopes, node, invocation) => {
      if (invocation.nodeType === "SourceUnit") {
        return undefined;
      }

      let pointer = scopes[node.id].pointer;
      let invocationPointer = scopes[invocation.id].pointer;

      //slice the invocation pointer off the beginning
      let difference = pointer.replace(invocationPointer, "");
      debug("difference %s", difference);
      let rawIndex = difference.match(/^\/arguments\/(\d+)/);
      //note that that \d+ is greedy
      debug("rawIndex %o", rawIndex);
      if (rawIndex === null) {
        return undefined;
      }
      return parseInt(rawIndex[1]);
    }),

    /*
     * data.current.modifierBeingInvoked
     * gets the node corresponding to the modifier or base constructor
     * being invoked
     */
    modifierBeingInvoked: (0, _reselectTree.createLeaf)(["./modifierInvocation", "/views/scopes/inlined"], (invocation, scopes) => {
      if (!invocation || invocation.nodeType === "SourceUnit") {
        return undefined;
      }

      return modifierForInvocation(invocation, scopes);
    }),

    /**
     * data.current.identifiers (namespace)
     */
    identifiers: {
      /**
       * data.current.identifiers (selector)
       *
       * returns identifers and corresponding definition node ID or builtin name
       * (object entries look like [name]: {astId: id} or like [name]: {builtin: name}
       */
      _: (0, _reselectTree.createLeaf)(["/views/scopes/inlined", "/current/node"], (scopes, scope) => {
        let variables = {};
        if (scope !== undefined) {
          let cur = scope.id;

          do {
            variables = (0, _assign2.default)(variables, ...(scopes[cur].variables || []).filter(v => v.name !== "") //exclude anonymous output params
            .filter(v => variables[v.name] == undefined).map(v => ({ [v.name]: { astId: v.id } })));

            cur = scopes[cur].parentId;
          } while (cur != null);
        }

        let builtins = {
          msg: { builtin: "msg" },
          tx: { builtin: "tx" },
          block: { builtin: "block" },
          this: { builtin: "this" },
          now: { builtin: "now" }
        };

        return (0, _extends3.default)({}, variables, builtins);
      }),

      /**
       * data.current.identifiers.definitions (namespace)
       */
      definitions: {
        /* data.current.identifiers.definitions (selector)
         * definitions for current variables, by identifier
         */
        _: (0, _reselectTree.createLeaf)(["/views/scopes/inlined", "../_", "./this"], (scopes, identifiers, thisDefinition) => {
          let variables = (0, _assign2.default)({}, ...(0, _entries2.default)(identifiers).map(([identifier, { astId }]) => {
            if (astId !== undefined) {
              //will be undefined for builtins
              let { definition } = scopes[astId];
              return { [identifier]: definition };
            } else {
              return {}; //skip over builtins; we'll handle those separately
            }
          }));
          let builtins = {
            msg: DecodeUtils.Definition.MSG_DEFINITION,
            tx: DecodeUtils.Definition.TX_DEFINITION,
            block: DecodeUtils.Definition.BLOCK_DEFINITION,
            now: DecodeUtils.Definition.spoofUintDefinition("now")
          };
          //only include this when it has a proper definition
          if (thisDefinition) {
            builtins.this = thisDefinition;
          }
          return (0, _extends3.default)({}, variables, builtins);
        }),

        /*
         * data.current.identifiers.definitions.this
         *
         * returns a spoofed definition for the this variable
         */
        this: (0, _reselectTree.createLeaf)(["/current/contract"], contractNode => contractNode && contractNode.nodeType === "ContractDefinition" ? DecodeUtils.Definition.spoofThisDefinition(contractNode.name, contractNode.id) : null)
      },

      /**
       * data.current.identifiers.refs
       *
       * current variables' value refs
       */
      refs: (0, _reselectTree.createLeaf)(["/proc/assignments", "./_", "/current/functionDepth", //for pruning things too deep on stack
      "/current/address" //for contract variables
      ], (assignments, identifiers, currentDepth, address) => (0, _assign2.default)({}, ...(0, _entries2.default)(identifiers).map(([identifier, { astId, builtin }]) => {
        let id;

        //is this an ordinary variable or a builtin?
        if (astId !== undefined) {
          //if not a builtin, first check if it's a contract var
          let matchIds = (assignments.byAstId[astId] || []).filter(idHash => assignments.byId[idHash].address === address);
          if (matchIds.length > 0) {
            id = matchIds[0]; //there should only be one!
          }

          //if not contract, it's local, so find the innermost
          //(but not beyond current depth)
          if (id === undefined) {
            let matchFrames = (assignments.byAstId[astId] || []).map(id => assignments.byId[id].stackframe).filter(stackframe => stackframe !== undefined);

            if (matchFrames.length > 0) {
              //this check isn't *really*
              //necessary, but may as well prevent stupid stuff
              let maxMatch = Math.min(currentDepth, Math.max(...matchFrames));
              id = (0, _helpers.stableKeccak256)({ astId, stackframe: maxMatch });
            }
          }
        } else {
          //otherwise, it's a builtin
          //NOTE: for now we assume there is only one assignment per
          //builtin, but this will change in the future
          id = assignments.byBuiltin[builtin][0];
        }

        //if we still didn't find it, oh well

        let { ref } = assignments.byId[id] || {};
        if (!ref) {
          return undefined;
        }

        return {
          [identifier]: ref
        };
      })))
    }
  },

  /**
   * data.next
   */
  next: {
    /**
     * data.next.state
     * Yes, I'm just repeating the code for data.current.state.stack here;
     * not worth the trouble to factor out
     */
    state: {
      /**
       * data.next.state.stack
       */
      stack: (0, _reselectTree.createLeaf)([_selectors2.default.next.state.stack], words => (words || []).map(word => DecodeUtils.Conversion.toBytes(word)))
    },

    //HACK WARNING
    //the following selectors depend on solidity.next
    //do not use them when the current instruction is a context change!

    /**
     * data.next.node
     */
    node: (0, _reselectTree.createLeaf)([_selectors4.default.next.node], identity),

    /**
     * data.next.modifierInvocation
     * Note: yes, I'm just repeating the code from data.current here but with
     * invalid added
     */
    modifierInvocation: (0, _reselectTree.createLeaf)(["./node", "/views/scopes/inlined", _selectors2.default.current.step.isContextChange], (node, scopes, invalid) => {
      //don't attempt this at a context change!
      //(also don't attempt this if we can't find the node for whatever
      //reason)
      if (invalid || !node) {
        return undefined;
      }
      const types = ["ModifierInvocation", "InheritanceSpecifier", "SourceUnit"];
      //again, SourceUnit included as fallback
      return findAncestorOfType(node, types, scopes);
    }),

    /*
     * data.next.modifierBeingInvoked
     */
    modifierBeingInvoked: (0, _reselectTree.createLeaf)(["./modifierInvocation", "/views/scopes/inlined", _selectors2.default.current.step.isContextChange], (invocation, scopes, invalid) => {
      if (invalid || !invocation || invocation.nodeType === "SourceUnit") {
        return undefined;
      }

      return modifierForInvocation(invocation, scopes);
    })
    //END HACK WARNING
  },

  /**
   * data.nextMapped
   */
  nextMapped: {
    /**
     * data.nextMapped.state
     * Yes, I'm just repeating the code for data.current.state.stack here;
     * not worth the trouble to factor out
     * HACK: this assumes we're not about to change context! don't use this if we
     * are!
     */
    state: {
      /**
       * data.nextMapped.state.stack
       */
      stack: (0, _reselectTree.createLeaf)([_selectors4.default.current.nextMapped], step => ((step || {}).stack || []).map(word => DecodeUtils.Conversion.toBytes(word)))
    }
  }
});

exports.default = data;

/***/ }),
/* 22 */
/***/ (function(module, exports) {

module.exports = require("json-pointer");

/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.addContext = addContext;
exports.normalizeContexts = normalizeContexts;
exports.addInstance = addInstance;
exports.begin = begin;
exports.callstackAndCodexSaga = callstackAndCodexSaga;
exports.reset = reset;
exports.unload = unload;
exports.saga = saga;

var _debug = __webpack_require__(0);

var _debug2 = _interopRequireDefault(_debug);

var _effects = __webpack_require__(5);

var _helpers = __webpack_require__(1);

var _actions = __webpack_require__(12);

var _actions2 = __webpack_require__(29);

var actions = _interopRequireWildcard(_actions2);

var _selectors = __webpack_require__(9);

var _selectors2 = _interopRequireDefault(_selectors);

var _sagas = __webpack_require__(13);

var trace = _interopRequireWildcard(_sagas);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const debug = (0, _debug2.default)("debugger:evm:sagas");

/**
 * Adds EVM bytecode context
 *
 * @return {string} ID (0x-prefixed keccak of binary)
 */
function* addContext(context) {
  const contextHash = (0, _helpers.keccak256)({ type: "string", value: context.binary });
  //NOTE: we take hash as *string*, not as bytes, because the binary may
  //contain link references!

  debug("context %O", context);
  yield (0, _effects.put)(actions.addContext(context));

  return contextHash;
}

function* normalizeContexts() {
  yield (0, _effects.put)(actions.normalizeContexts());
}

/**
 * Adds known deployed instance of binary at address
 *
 * @param {string} binary - may be undefined (e.g. precompiles)
 * @return {string} ID (0x-prefixed keccak of binary)
 */
function* addInstance(address, binary) {
  let search = yield (0, _effects.select)(_selectors2.default.info.binaries.search);
  let context = search(binary);

  //now, whether we needed a new context or not, add the instance
  yield (0, _effects.put)(actions.addInstance(address, context, binary));

  return context;
}

function* begin({
  address,
  binary,
  data,
  storageAddress,
  status,
  sender,
  value,
  gasprice,
  block
}) {
  yield (0, _effects.put)(actions.saveGlobals(sender, gasprice, block));
  yield (0, _effects.put)(actions.saveStatus(status));
  debug("codex: %O", (yield (0, _effects.select)(_selectors2.default.current.codex)));
  if (address) {
    yield (0, _effects.put)(actions.call(address, data, storageAddress, sender, value));
  } else {
    yield (0, _effects.put)(actions.create(binary, storageAddress, sender, value));
  }
}

function* tickSaga() {
  debug("got TICK");

  yield* callstackAndCodexSaga();
  yield* trace.signalTickSagaCompletion();
}

function* callstackAndCodexSaga() {
  if (yield (0, _effects.select)(_selectors2.default.current.step.isExceptionalHalting)) {
    //let's handle this case first so we can be sure everything else is *not*
    //an exceptional halt
    debug("exceptional halt!");

    yield (0, _effects.put)(actions.fail());
  } else if (yield (0, _effects.select)(_selectors2.default.current.step.isCall)) {
    debug("got call");
    // if there is no binary (e.g. in the case of precompiled contracts or
    // externally owned accounts), then there will be no trace steps for the
    // called code, and so we shouldn't tell the debugger that we're entering
    // another execution context
    if (yield (0, _effects.select)(_selectors2.default.current.step.callsPrecompileOrExternal)) {
      return;
    }

    let address = yield (0, _effects.select)(_selectors2.default.current.step.callAddress);
    let data = yield (0, _effects.select)(_selectors2.default.current.step.callData);

    debug("calling address %s", address);

    if (yield (0, _effects.select)(_selectors2.default.current.step.isDelegateCallStrict)) {
      //if delegating, leave storageAddress, sender, and value the same
      let { storageAddress, sender, value } = yield (0, _effects.select)(_selectors2.default.current.call);
      yield (0, _effects.put)(actions.call(address, data, storageAddress, sender, value));
    } else {
      //this branch covers CALL, CALLCODE, and STATICCALL
      let currentCall = yield (0, _effects.select)(_selectors2.default.current.call);
      let storageAddress = (yield (0, _effects.select)(_selectors2.default.current.step.isDelegateCallBroad)) ? currentCall.storageAddress //for CALLCODE
      : address;
      let sender = currentCall.storageAddress; //not the code address!
      let value = yield (0, _effects.select)(_selectors2.default.current.step.callValue); //0 if static
      yield (0, _effects.put)(actions.call(address, data, storageAddress, sender, value));
    }
  } else if (yield (0, _effects.select)(_selectors2.default.current.step.isCreate)) {
    debug("got create");
    let binary = yield (0, _effects.select)(_selectors2.default.current.step.createBinary);
    let createdAddress = yield (0, _effects.select)(_selectors2.default.current.step.createdAddress);
    let value = yield (0, _effects.select)(_selectors2.default.current.step.createValue);
    let sender = (yield (0, _effects.select)(_selectors2.default.current.call)).storageAddress;
    //not the code address!

    yield (0, _effects.put)(actions.create(binary, createdAddress, sender, value));
    //as above, storageAddress handles when calling from a creation call
  } else if (yield (0, _effects.select)(_selectors2.default.current.step.isHalting)) {
    debug("got return");

    let { binary, storageAddress } = yield (0, _effects.select)(_selectors2.default.current.call);

    if (binary) {
      //if we're returning from a successful creation call, let's log the
      //result
      let returnedBinary = yield (0, _effects.select)(_selectors2.default.current.step.returnValue);
      let search = yield (0, _effects.select)(_selectors2.default.info.binaries.search);
      let returnedContext = search(returnedBinary);
      yield (0, _effects.put)(actions.returnCreate(storageAddress, returnedBinary, returnedContext));
    } else {
      yield (0, _effects.put)(actions.returnCall());
    }
  } else if (yield (0, _effects.select)(_selectors2.default.current.step.touchesStorage)) {
    let storageAddress = (yield (0, _effects.select)(_selectors2.default.current.call)).storageAddress;
    let slot = yield (0, _effects.select)(_selectors2.default.current.step.storageAffected);
    //note we get next storage, since we're updating to that
    let storage = yield (0, _effects.select)(_selectors2.default.next.state.storage);
    //normally we'd need a 0 fallback for this next line, but in this case we
    //can be sure the value will be there, since we're touching that storage
    if (yield (0, _effects.select)(_selectors2.default.current.step.isStore)) {
      yield (0, _effects.put)(actions.store(storageAddress, slot, storage[slot]));
    } else {
      //otherwise, it's a load
      yield (0, _effects.put)(actions.load(storageAddress, slot, storage[slot]));
    }
  }
}

function* reset() {
  let initialCall = yield (0, _effects.select)(_selectors2.default.transaction.initialCall);
  yield (0, _effects.put)(actions.reset());
  yield (0, _effects.put)(initialCall);
}

function* unload() {
  yield (0, _effects.put)(actions.unloadTransaction());
}

function* saga() {
  yield (0, _effects.takeEvery)(_actions.TICK, tickSaga);
}

exports.default = (0, _helpers.prefixName)("evm", saga);

/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends2 = __webpack_require__(2);

var _extends3 = _interopRequireDefault(_extends2);

var _debug = __webpack_require__(0);

var _debug2 = _interopRequireDefault(_debug);

var _reselectTree = __webpack_require__(3);

var _selectors = __webpack_require__(9);

var _selectors2 = _interopRequireDefault(_selectors);

var _selectors3 = __webpack_require__(11);

var _selectors4 = _interopRequireDefault(_selectors3);

var _selectors5 = __webpack_require__(10);

var _selectors6 = _interopRequireDefault(_selectors5);

var _map = __webpack_require__(25);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const debug = (0, _debug2.default)("debugger:controller:selectors"); //eslint-disable-line no-unused-vars

/**
 * @private
 */
const identity = x => x;

/**
 * controller
 */
const controller = (0, _reselectTree.createSelectorTree)({
  /**
   * controller.state
   */
  state: state => state.controller,
  /**
   * controller.current
   */
  current: {
    /**
     * controller.current.functionDepth
     */
    functionDepth: (0, _reselectTree.createLeaf)([_selectors4.default.current.functionDepth], identity),

    /**
     * controller.current.executionContext
     */
    executionContext: (0, _reselectTree.createLeaf)([_selectors2.default.current.call], identity),

    /**
     * controller.current.willJump
     */
    willJump: (0, _reselectTree.createLeaf)([_selectors2.default.current.step.isJump], identity),

    /**
     * controller.current.location
     */
    location: {
      /**
       * controller.current.location.sourceRange
       */
      sourceRange: (0, _reselectTree.createLeaf)([_selectors4.default.current.sourceRange, "/current/trace/loaded"], (range, loaded) => loaded ? range : null),

      /**
       * controller.current.location.source
       */
      source: (0, _reselectTree.createLeaf)([_selectors4.default.current.source, "/current/trace/loaded"], (source, loaded) => loaded ? source : null),

      /**
       * controller.current.location.node
       */
      node: (0, _reselectTree.createLeaf)([_selectors4.default.current.node, "/current/trace/loaded"], (node, loaded) => loaded ? node : null),

      /**
       * controller.current.location.isMultiline
       */
      isMultiline: (0, _reselectTree.createLeaf)([_selectors4.default.current.isMultiline, "/current/trace/loaded"], (raw, loaded) => loaded ? raw : false)
    },

    /*
     * controller.current.trace
     */
    trace: {
      /**
       * controller.current.trace.finished
       */
      finished: (0, _reselectTree.createLeaf)([_selectors6.default.finished], identity),

      /**
       * controller.current.trace.loaded
       */
      loaded: (0, _reselectTree.createLeaf)([_selectors6.default.loaded], identity)
    }
  },

  /**
   * controller.breakpoints (namespace)
   */
  breakpoints: {
    /**
     * controller.breakpoints (selector)
     */
    _: (0, _reselectTree.createLeaf)(["/state"], state => state.breakpoints),

    /**
     * controller.breakpoints.resolver (selector)
     * this selector returns a function that adjusts a given line-based
     * breakpoint (on node-based breakpoints it simply returns the input) by
     * repeatedly moving it down a line until it lands on a line where there's
     * actually somewhere to break.  if no such line exists beyond that point, it
     * returns null instead.
     */
    resolver: (0, _reselectTree.createLeaf)([_selectors4.default.info.sources], sources => breakpoint => {
      let adjustedBreakpoint;
      if (breakpoint.node === undefined) {
        let line = breakpoint.line;
        let { source, ast } = sources[breakpoint.sourceId];
        let lineLengths = source.split("\n").map(line => line.length);
        //why does neither JS nor lodash have a scan function like Haskell??
        //guess we'll have to do our scan manually
        let lineStarts = [0];
        for (let length of lineLengths) {
          lineStarts.push(lineStarts[lineStarts.length - 1] + length + 1);
          //+1 for the /n itself
        }
        debug("line: %s", source.slice(lineStarts[line], lineStarts[line] + lineLengths[line]));
        while (line < lineLengths.length && !(0, _map.anyNonSkippedInRange)(ast, lineStarts[line], lineLengths[line])) {
          debug("incrementing");
          line++;
        }
        if (line >= lineLengths.length) {
          adjustedBreakpoint = null;
        } else {
          adjustedBreakpoint = (0, _extends3.default)({}, breakpoint, { line });
        }
      } else {
        debug("node-based breakpoint");
        adjustedBreakpoint = breakpoint;
      }
      return adjustedBreakpoint;
    })
  },

  /**
   * controller.finished
   * deprecated alias for controller.current.trace.finished
   */
  finished: (0, _reselectTree.createLeaf)(["/current/finished"], finished => finished),

  /**
   * controller.isStepping
   */
  isStepping: (0, _reselectTree.createLeaf)(["./state"], state => state.isStepping)
});

exports.default = controller;

/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _keys = __webpack_require__(16);

var _keys2 = _interopRequireDefault(_keys);

exports.getRange = getRange;
exports.rangeNodes = rangeNodes;
exports.findOverlappingRange = findOverlappingRange;
exports.findRange = findRange;
exports.anyNonSkippedInRange = anyNonSkippedInRange;

var _debug = __webpack_require__(0);

var _debug2 = _interopRequireDefault(_debug);

var _nodeIntervalTree = __webpack_require__(53);

var _nodeIntervalTree2 = _interopRequireDefault(_nodeIntervalTree);

var _jsonPointer = __webpack_require__(22);

var _jsonPointer2 = _interopRequireDefault(_jsonPointer);

var _helpers = __webpack_require__(1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const debug = (0, _debug2.default)("debugger:ast:map");

/**
 * @private
 */
function getRange(node) {
  // src: "<start>:<length>:<_>"
  // returns [start, end]
  let [start, length] = node.src.split(":").slice(0, 2).map(i => parseInt(i));

  return [start, start + length];
}

/**
 * @private
 */
function rangeNodes(node, pointer = "") {
  if (node instanceof Array) {
    return [].concat(...node.map((sub, i) => rangeNodes(sub, `${pointer}/${i}`)));
  } else if (node instanceof Object) {
    let results = [];

    if (node.src !== undefined && node.id !== undefined) {
      //there are some "pseudo-nodes" with a src but no id.
      //these will cause problems, so we want to exclude them.
      //(to my knowledge this only happens with the externalReferences
      //to an InlineAssembly node, so excluding them just means we find
      //the InlineAssembly node instead, which is fine)
      results.push({ pointer, range: getRange(node) });
    }

    return results.concat(...(0, _keys2.default)(node).map(key => rangeNodes(node[key], `${pointer}/${key}`)));
  } else {
    return [];
  }
}

/**
 * @private
 */
function findOverlappingRange(node, sourceStart, sourceLength) {
  let ranges = rangeNodes(node);
  let tree = new _nodeIntervalTree2.default();

  for (let _ref of ranges) {
    let { range, pointer } = _ref;

    let [start, end] = range;
    tree.insert(start, end, { range, pointer });
  }

  let sourceEnd = sourceStart + sourceLength;

  return tree.search(sourceStart, sourceEnd);
  //returns everything overlapping the given range
}

/**
 * @private
 */
function findRange(node, sourceStart, sourceLength) {
  // find nodes that fully contain requested range,
  // return longest pointer
  let sourceEnd = sourceStart + sourceLength;
  return findOverlappingRange(node, sourceStart, sourceLength).filter(({ range }) => sourceStart >= range[0] && sourceEnd <= range[1]).map(({ pointer }) => pointer).reduce((a, b) => a.length > b.length ? a : b, "");
}

/**
 * @private
 */
function anyNonSkippedInRange(node, sourceStart, sourceLength) {
  let sourceEnd = sourceStart + sourceLength;
  return findOverlappingRange(node, sourceStart, sourceLength).some(({ range, pointer }) => sourceStart <= range[0] && //we want to go by starting line
  range[0] < sourceEnd && !(0, _helpers.isSkippedNodeType)(_jsonPointer2.default.get(node, pointer))
  //NOTE: this doesn't actually catch everything skipped!  But doing better
  //is hard
  );
}

/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _entries = __webpack_require__(6);

var _entries2 = _interopRequireDefault(_entries);

var _assign = __webpack_require__(8);

var _assign2 = _interopRequireDefault(_assign);

var _debug = __webpack_require__(0);

var _debug2 = _interopRequireDefault(_debug);

var _reselectTree = __webpack_require__(3);

var _selectors = __webpack_require__(9);

var _selectors2 = _interopRequireDefault(_selectors);

var _selectors3 = __webpack_require__(10);

var _selectors4 = _interopRequireDefault(_selectors3);

var _selectors5 = __webpack_require__(11);

var _selectors6 = _interopRequireDefault(_selectors5);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const debug = (0, _debug2.default)("debugger:session:selectors");

const session = (0, _reselectTree.createSelectorTree)({
  /*
   * session.state
   */
  state: state => state.session,

  /**
   * session.info
   */
  info: {
    /**
     * session.info.affectedInstances
     */
    affectedInstances: (0, _reselectTree.createLeaf)([_selectors2.default.current.codex.instances, _selectors2.default.info.contexts, _selectors6.default.info.sources], (instances, contexts, sources) => (0, _assign2.default)({}, ...(0, _entries2.default)(instances).map(([address, { context: contextId, binary }]) => {
      debug("instances %O", instances);
      debug("contexts %O", contexts);
      let context = contexts[contextId];
      if (!context) {
        return { [address]: { binary } };
      }
      let { contractName, primarySource } = context;

      let source = primarySource !== undefined ? sources[primarySource] : undefined;

      return {
        [address]: {
          contractName,
          source,
          binary
        }
      };
    })))
  },

  /**
   * session.transaction (namespace)
   */
  transaction: {
    /**
     * session.transaction (selector)
     * contains the web3 transaction object
     */
    _: (0, _reselectTree.createLeaf)(["/state"], state => state.transaction),

    /**
     * session.transaction.receipt
     * contains the web3 receipt object
     */
    receipt: (0, _reselectTree.createLeaf)(["/state"], state => state.receipt),

    /**
     * session.transaction.block
     * contains the web3 block object
     */
    block: (0, _reselectTree.createLeaf)(["/state"], state => state.block)
  },

  /*
   * session.status (namespace)
   */
  status: {
    /*
     * session.status.readyOrError
     */
    readyOrError: (0, _reselectTree.createLeaf)(["/state"], state => state.ready),

    /*
     * session.status.ready
     */
    ready: (0, _reselectTree.createLeaf)(["./readyOrError", "./isError"], (readyOrError, error) => readyOrError && !error),

    /*
     * session.status.waiting
     */
    waiting: (0, _reselectTree.createLeaf)(["/state"], state => !state.ready),

    /*
     * session.status.error
     */
    error: (0, _reselectTree.createLeaf)(["/state"], state => state.lastLoadingError),

    /*
     * session.status.isError
     */
    isError: (0, _reselectTree.createLeaf)(["./error"], error => error !== null),

    /*
     * session.status.success
     */
    success: (0, _reselectTree.createLeaf)(["./error"], error => error === null),

    /*
     * session.status.errored
     */
    errored: (0, _reselectTree.createLeaf)(["./readyOrError", "./isError"], (readyOrError, error) => readyOrError && error),

    /*
     * session.status.loaded
     */
    loaded: (0, _reselectTree.createLeaf)([_selectors4.default.loaded], loaded => loaded),

    /*
     * session.status.projectInfoComputed
     */
    projectInfoComputed: (0, _reselectTree.createLeaf)(["/state"], state => state.projectInfoComputed)
  }
});

exports.default = session;

/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.scope = scope;
exports.declare = declare;
exports.assign = assign;
exports.mapPathAndAssign = mapPathAndAssign;
exports.reset = reset;
exports.defineType = defineType;
exports.allocate = allocate;
const SCOPE = exports.SCOPE = "SCOPE";
function scope(id, pointer, parentId, sourceId) {
  return {
    type: SCOPE,
    id,
    pointer,
    parentId,
    sourceId
  };
}

const DECLARE = exports.DECLARE = "DECLARE_VARIABLE";
function declare(node) {
  return {
    type: DECLARE,
    node
  };
}

const ASSIGN = exports.ASSIGN = "ASSIGN";
function assign(assignments) {
  return {
    type: ASSIGN,
    assignments
  };
}

const MAP_PATH_AND_ASSIGN = exports.MAP_PATH_AND_ASSIGN = "MAP_PATH_AND_ASSIGN";
function mapPathAndAssign(address, slot, assignments, typeIdentifier, parentType) {
  return {
    type: MAP_PATH_AND_ASSIGN,
    address,
    slot,
    assignments,
    typeIdentifier,
    parentType
  };
}

const RESET = exports.RESET = "DATA_RESET";
function reset() {
  return { type: RESET };
}

const DEFINE_TYPE = exports.DEFINE_TYPE = "DEFINE_TYPE";
function defineType(node) {
  return {
    type: DEFINE_TYPE,
    node
  };
}

const ALLOCATE = exports.ALLOCATE = "ALLOCATE";
function allocate(storage, memory, calldata) {
  return {
    type: ALLOCATE,
    storage,
    memory,
    calldata
  };
}

/***/ }),
/* 28 */
/***/ (function(module, exports) {

module.exports = require("babel-runtime/core-js/set");

/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.addContext = addContext;
exports.normalizeContexts = normalizeContexts;
exports.addInstance = addInstance;
exports.saveGlobals = saveGlobals;
exports.saveStatus = saveStatus;
exports.call = call;
exports.create = create;
exports.returnCall = returnCall;
exports.returnCreate = returnCreate;
exports.fail = fail;
exports.store = store;
exports.load = load;
exports.reset = reset;
exports.unloadTransaction = unloadTransaction;
const ADD_CONTEXT = exports.ADD_CONTEXT = "EVM_ADD_CONTEXT";
function addContext({
  contractName,
  binary,
  sourceMap,
  compiler,
  abi,
  contractId,
  contractKind,
  isConstructor
}) {
  return {
    type: ADD_CONTEXT,
    contractName,
    binary,
    sourceMap,
    compiler,
    abi,
    contractId,
    contractKind,
    isConstructor
  };
}

const NORMALIZE_CONTEXTS = exports.NORMALIZE_CONTEXTS = "EVM_NORMALIZE_CONTEXTS";
function normalizeContexts() {
  return { type: NORMALIZE_CONTEXTS };
}

const ADD_INSTANCE = exports.ADD_INSTANCE = "EVM_ADD_INSTANCE";
function addInstance(address, context, binary) {
  return {
    type: ADD_INSTANCE,
    address,
    context,
    binary
  };
}

const SAVE_GLOBALS = exports.SAVE_GLOBALS = "SAVE_GLOBALS";
function saveGlobals(origin, gasprice, block) {
  return {
    type: SAVE_GLOBALS,
    origin,
    gasprice,
    block
  };
}

const SAVE_STATUS = exports.SAVE_STATUS = "SAVE_STATUS";
function saveStatus(status) {
  return {
    type: SAVE_STATUS,
    status
  };
}

const CALL = exports.CALL = "CALL";
function call(address, data, storageAddress, sender, value) {
  return {
    type: CALL,
    address,
    data,
    storageAddress,
    sender,
    value
  };
}

const CREATE = exports.CREATE = "CREATE";
function create(binary, storageAddress, sender, value) {
  return {
    type: CREATE,
    binary,
    storageAddress,
    sender,
    value
  };
}

const RETURN_CALL = exports.RETURN_CALL = "RETURN_CALL";
function returnCall() {
  return {
    type: RETURN_CALL
  };
}

const RETURN_CREATE = exports.RETURN_CREATE = "RETURN_CREATE";
function returnCreate(address, code, context) {
  return {
    type: RETURN_CREATE,
    address,
    code,
    context
  };
}

const FAIL = exports.FAIL = "FAIL";
function fail() {
  return {
    type: FAIL
  };
}

const STORE = exports.STORE = "STORE";
function store(address, slot, value) {
  return {
    type: STORE,
    address,
    slot,
    value
  };
}

const LOAD = exports.LOAD = "LOAD";
function load(address, slot, value) {
  return {
    type: LOAD,
    address,
    slot,
    value
  };
}

const RESET = exports.RESET = "EVM_RESET";
function reset(storageAddress) {
  return {
    type: RESET,
    storageAddress
  };
}

const UNLOAD_TRANSACTION = exports.UNLOAD_TRANSACTION = "EVM_UNLOAD_TRANSACTION";
function unloadTransaction() {
  return {
    type: UNLOAD_TRANSACTION
  };
}

/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.inspectTransaction = inspectTransaction;
exports.obtainBinaries = obtainBinaries;
exports.init = init;
exports.saga = saga;

var _debug = __webpack_require__(0);

var _debug2 = _interopRequireDefault(_debug);

var _effects = __webpack_require__(5);

var _helpers = __webpack_require__(1);

var _actions = __webpack_require__(55);

var actions = _interopRequireWildcard(_actions);

var _actions2 = __webpack_require__(14);

var session = _interopRequireWildcard(_actions2);

var _bn = __webpack_require__(15);

var _bn2 = _interopRequireDefault(_bn);

var _web = __webpack_require__(31);

var _web2 = _interopRequireDefault(_web);

var _truffleDecodeUtils = __webpack_require__(4);

var DecodeUtils = _interopRequireWildcard(_truffleDecodeUtils);

var _adapter = __webpack_require__(56);

var _adapter2 = _interopRequireDefault(_adapter);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const debug = (0, _debug2.default)("debugger:web3:sagas"); //just for utils!


function* fetchTransactionInfo(adapter, { txHash }) {
  debug("inspecting transaction");
  var trace;
  try {
    trace = yield (0, _effects.apply)(adapter, adapter.getTrace, [txHash]);
  } catch (e) {
    debug("putting error");
    yield (0, _effects.put)(actions.error(e));
    return;
  }

  debug("got trace");
  yield (0, _effects.put)(actions.receiveTrace(trace));

  let tx = yield (0, _effects.apply)(adapter, adapter.getTransaction, [txHash]);
  debug("tx %O", tx);
  let receipt = yield (0, _effects.apply)(adapter, adapter.getReceipt, [txHash]);
  debug("receipt %O", receipt);
  let block = yield (0, _effects.apply)(adapter, adapter.getBlock, [tx.blockNumber]);
  debug("block %O", block);

  yield (0, _effects.put)(session.saveTransaction(tx));
  yield (0, _effects.put)(session.saveReceipt(receipt));
  yield (0, _effects.put)(session.saveBlock(block));

  //these ones get grouped together for convenience
  let solidityBlock = {
    coinbase: block.miner,
    difficulty: new _bn2.default(block.difficulty),
    gaslimit: new _bn2.default(block.gasLimit),
    number: new _bn2.default(block.number),
    timestamp: new _bn2.default(block.timestamp)
  };

  if (tx.to != null) {
    yield (0, _effects.put)(actions.receiveCall({
      address: tx.to,
      data: tx.input,
      storageAddress: tx.to,
      status: receipt.status,
      sender: tx.from,
      value: new _bn2.default(tx.value),
      gasprice: new _bn2.default(tx.gasPrice),
      block: solidityBlock
    }));
  } else {
    let storageAddress = _web2.default.utils.isAddress(receipt.contractAddress) ? receipt.contractAddress : DecodeUtils.EVM.ZERO_ADDRESS;
    yield (0, _effects.put)(actions.receiveCall({
      binary: tx.input,
      storageAddress,
      status: receipt.status,
      sender: tx.from,
      value: new _bn2.default(tx.value),
      gasprice: new _bn2.default(tx.gasPrice),
      block: solidityBlock
    }));
  }
}

function* fetchBinary(adapter, { address, block }) {
  debug("fetching binary for %s", address);
  let binary = yield (0, _effects.apply)(adapter, adapter.getDeployedCode, [address, block]);

  debug("received binary for %s", address);
  yield (0, _effects.put)(actions.receiveBinary(address, binary));
}

function* inspectTransaction(txHash) {
  yield (0, _effects.put)(actions.inspect(txHash));

  let action = yield (0, _effects.take)([actions.RECEIVE_TRACE, actions.ERROR_WEB3]);
  debug("action %o", action);

  var trace;
  if (action.type == actions.RECEIVE_TRACE) {
    trace = action.trace;
    debug("received trace");
  } else {
    return { error: action.error };
  }

  let {
    address,
    binary,
    data,
    storageAddress,
    status,
    sender,
    value,
    gasprice,
    block
  } = yield (0, _effects.take)(actions.RECEIVE_CALL);
  debug("received call");

  return {
    trace,
    address,
    binary,
    data,
    storageAddress,
    status,
    sender,
    value,
    gasprice,
    block
  };
}

//NOTE: the block argument is optional
function* obtainBinaries(addresses, block) {
  let tasks = yield (0, _effects.all)(addresses.map(address => (0, _effects.fork)(receiveBinary, address)));

  debug("requesting binaries");
  yield (0, _effects.all)(addresses.map(address => (0, _effects.put)(actions.fetchBinary(address, block))));

  let binaries = [];
  binaries = yield (0, _effects.join)(tasks);

  debug("binaries %o", binaries);

  return binaries;
}

function* receiveBinary(address) {
  let { binary } = yield (0, _effects.take)(action => action.type == actions.RECEIVE_BINARY && action.address == address);
  debug("got binary for %s", address);

  return binary;
}

function* init(provider) {
  yield (0, _effects.put)(actions.init(provider));
}

function* saga() {
  // wait for web3 init signal
  let { provider } = yield (0, _effects.take)(actions.INIT_WEB3);
  let adapter = new _adapter2.default(provider);

  yield (0, _effects.takeEvery)(actions.INSPECT, fetchTransactionInfo, adapter);
  yield (0, _effects.takeEvery)(actions.FETCH_BINARY, fetchBinary, adapter);
}

exports.default = (0, _helpers.prefixName)("web3", saga);

/***/ }),
/* 31 */
/***/ (function(module, exports) {

module.exports = require("web3");

/***/ }),
/* 32 */
/***/ (function(module, exports) {

module.exports = require("truffle-decoder");

/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _keys = __webpack_require__(16);

var _keys2 = _interopRequireDefault(_keys);

exports.saga = saga;
exports.reset = reset;

var _debug = __webpack_require__(0);

var _debug2 = _interopRequireDefault(_debug);

var _effects = __webpack_require__(5);

var _helpers = __webpack_require__(1);

var _sagas = __webpack_require__(13);

var trace = _interopRequireWildcard(_sagas);

var _sagas2 = __webpack_require__(17);

var data = _interopRequireWildcard(_sagas2);

var _sagas3 = __webpack_require__(23);

var evm = _interopRequireWildcard(_sagas3);

var _sagas4 = __webpack_require__(34);

var solidity = _interopRequireWildcard(_sagas4);

var _actions = __webpack_require__(20);

var actions = _interopRequireWildcard(_actions);

var _selectors = __webpack_require__(24);

var _selectors2 = _interopRequireDefault(_selectors);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const debug = (0, _debug2.default)("debugger:controller:sagas");

const STEP_SAGAS = {
  [actions.ADVANCE]: advance,
  [actions.STEP_NEXT]: stepNext,
  [actions.STEP_OVER]: stepOver,
  [actions.STEP_INTO]: stepInto,
  [actions.STEP_OUT]: stepOut,
  [actions.CONTINUE]: continueUntilBreakpoint
};

function* saga() {
  while (true) {
    debug("waiting for control action");
    let action = yield (0, _effects.take)((0, _keys2.default)(STEP_SAGAS));
    if (!(yield (0, _effects.select)(_selectors2.default.current.trace.loaded))) {
      continue; //while no trace is loaded, step actions are ignored
    }
    debug("got control action");
    let saga = STEP_SAGAS[action.type];

    yield (0, _effects.put)(actions.startStepping());
    yield (0, _effects.race)({
      exec: (0, _effects.call)(saga, action), //not all will use this
      interrupt: (0, _effects.take)(actions.INTERRUPT)
    });
    yield (0, _effects.put)(actions.doneStepping());
  }
}

exports.default = (0, _helpers.prefixName)("controller", saga);

/*
 * Advance the state by the given number of instructions (but not past the end)
 * (if no count given, advance 1)
 */

function* advance(action) {
  let count = action !== undefined && action.count !== undefined ? action.count : 1;
  //default is, as mentioned, to advance 1
  for (let i = 0; i < count && !(yield (0, _effects.select)(_selectors2.default.current.trace.finished)); i++) {
    yield* trace.advance();
  }
}

/**
 * stepNext - step to the next logical code segment
 *
 * Note: It might take multiple instructions to express the same section of code.
 * "Stepping", then, is stepping to the next logical item, not stepping to the next
 * instruction. See advance() if you'd like to advance by one instruction.
 */
function* stepNext() {
  const startingRange = yield (0, _effects.select)(_selectors2.default.current.location.sourceRange);

  var upcoming, finished;

  do {
    // advance at least once step
    yield* advance();

    // and check the next source range
    try {
      upcoming = yield (0, _effects.select)(_selectors2.default.current.location);
    } catch (e) {
      upcoming = null;
    }

    finished = yield (0, _effects.select)(_selectors2.default.current.trace.finished);

    // if the next step's source range is still the same, keep going
  } while (!finished && (!upcoming || !upcoming.node || (0, _helpers.isDeliberatelySkippedNodeType)(upcoming.node) || upcoming.sourceRange.start == startingRange.start && upcoming.sourceRange.length == startingRange.length));
}

/**
 * stepInto - step into the current function
 *
 * Conceptually this is easy, but from a programming standpoint it's hard.
 * Code like `getBalance(msg.sender)` might be highlighted, but there could
 * be a number of different intermediate steps (like evaluating `msg.sender`)
 * before `getBalance` is stepped into. This function will step into the first
 * function available (where instruction.jump == "i"), ignoring any intermediate
 * steps that fall within the same code range. If there's a step encountered
 * that exists outside of the range, then stepInto will only execute until that
 * step.
 */
function* stepInto() {
  if (yield (0, _effects.select)(_selectors2.default.current.willJump)) {
    yield* stepNext();
    return;
  }

  if (yield (0, _effects.select)(_selectors2.default.current.location.isMultiline)) {
    yield* stepOver();
    return;
  }

  const startingDepth = yield (0, _effects.select)(_selectors2.default.current.functionDepth);
  const startingRange = yield (0, _effects.select)(_selectors2.default.current.location.sourceRange);
  var currentDepth;
  var currentRange;

  do {
    yield* stepNext();

    currentDepth = yield (0, _effects.select)(_selectors2.default.current.functionDepth);
    currentRange = yield (0, _effects.select)(_selectors2.default.current.location.sourceRange);
  } while (
  // the function stack has not increased,
  currentDepth <= startingDepth &&
  // the current source range begins on or after the starting range
  currentRange.start >= startingRange.start &&
  // and the current range ends on or before the starting range ends
  currentRange.start + currentRange.length <= startingRange.start + startingRange.length);
}

/**
 * Step out of the current function
 *
 * This will run until the debugger encounters a decrease in function depth.
 */
function* stepOut() {
  if (yield (0, _effects.select)(_selectors2.default.current.location.isMultiline)) {
    yield* stepOver();
    return;
  }

  const startingDepth = yield (0, _effects.select)(_selectors2.default.current.functionDepth);
  var currentDepth;

  do {
    yield* stepNext();

    currentDepth = yield (0, _effects.select)(_selectors2.default.current.functionDepth);
  } while (currentDepth >= startingDepth);
}

/**
 * stepOver - step over the current line
 *
 * Step over the current line. This will step to the next instruction that
 * exists on a different line of code within the same function depth.
 */
function* stepOver() {
  const startingDepth = yield (0, _effects.select)(_selectors2.default.current.functionDepth);
  const startingRange = yield (0, _effects.select)(_selectors2.default.current.location.sourceRange);
  var currentDepth;
  var currentRange;

  do {
    yield* stepNext();

    currentDepth = yield (0, _effects.select)(_selectors2.default.current.functionDepth);
    currentRange = yield (0, _effects.select)(_selectors2.default.current.location.sourceRange);
  } while (
  // keep stepping provided:
  //
  // we haven't jumped out
  !(currentDepth < startingDepth) && (
  // either: function depth is greater than starting (ignore function calls)
  // or, if we're at the same depth, keep stepping until we're on a new
  // line.
  currentDepth > startingDepth || currentRange.lines.start.line == startingRange.lines.start.line));
}

/**
 * continueUntilBreakpoint - step through execution until a breakpoint
 */
function* continueUntilBreakpoint(action) {
  var currentLocation, currentNode, currentLine, currentSourceId;
  var finished;
  var previousLine, previousSourceId;

  //if breakpoints was not specified, use the stored list from the state.
  //if it was, override that with the specified list.
  //note that explicitly specifying an empty list will advance to the end.
  let breakpoints = action !== undefined && action.breakpoints !== undefined ? action.breakpoints : yield (0, _effects.select)(_selectors2.default.breakpoints);

  let breakpointHit = false;

  currentLocation = yield (0, _effects.select)(_selectors2.default.current.location);
  currentNode = currentLocation.node.id;
  currentLine = currentLocation.sourceRange.lines.start.line;
  currentSourceId = currentLocation.source.id;

  do {
    yield* stepNext();

    previousLine = currentLine;
    previousSourceId = currentSourceId;

    currentLocation = yield (0, _effects.select)(_selectors2.default.current.location);
    finished = yield (0, _effects.select)(_selectors2.default.current.trace.finished);
    debug("finished %o", finished);

    currentNode = currentLocation.node.id;
    currentLine = currentLocation.sourceRange.lines.start.line;
    currentSourceId = currentLocation.source.id;

    breakpointHit = breakpoints.filter(({ sourceId, line, node }) => {
      if (node !== undefined) {
        debug("node %d currentNode %d", node, currentNode);
        return sourceId === currentSourceId && node === currentNode;
      }
      //otherwise, we have a line-style breakpoint; we want to stop at the
      //*first* point on the line
      return sourceId === currentSourceId && line === currentLine && (currentSourceId !== previousSourceId || currentLine !== previousLine);
    }).length > 0;
  } while (!breakpointHit && !finished);
}

/**
 * reset -- reset the state of the debugger
 */
function* reset() {
  yield* data.reset();
  yield* evm.reset();
  yield* solidity.reset();
  yield* trace.reset();
}

/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.addSource = addSource;
exports.reset = reset;
exports.saga = saga;

var _debug = __webpack_require__(0);

var _debug2 = _interopRequireDefault(_debug);

var _effects = __webpack_require__(5);

var _helpers = __webpack_require__(1);

var _actions = __webpack_require__(35);

var actions = _interopRequireWildcard(_actions);

var _actions2 = __webpack_require__(12);

var _sagas = __webpack_require__(13);

var trace = _interopRequireWildcard(_sagas);

var _selectors = __webpack_require__(11);

var _selectors2 = _interopRequireDefault(_selectors);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const debug = (0, _debug2.default)("debugger:solidity:sagas");

function* addSource(source, sourcePath, ast, compiler) {
  yield (0, _effects.put)(actions.addSource(source, sourcePath, ast, compiler));
}

function* tickSaga() {
  debug("got TICK");

  yield* functionDepthSaga();
  yield* trace.signalTickSagaCompletion();
}

function* functionDepthSaga() {
  if (yield (0, _effects.select)(_selectors2.default.current.willFail)) {
    //we do this case first so we can be sure we're not failing in any of the
    //other cases below!
    yield (0, _effects.put)(actions.externalReturn());
  } else if (yield (0, _effects.select)(_selectors2.default.current.willJump)) {
    let jumpDirection = yield (0, _effects.select)(_selectors2.default.current.jumpDirection);
    yield (0, _effects.put)(actions.jump(jumpDirection));
  } else if (yield (0, _effects.select)(_selectors2.default.current.willCall)) {
    debug("about to call");
    if (yield (0, _effects.select)(_selectors2.default.current.callsPrecompileOrExternal)) {
      //call to precompile or externally-owned account; do nothing
    } else {
      yield (0, _effects.put)(actions.externalCall());
    }
  } else if (yield (0, _effects.select)(_selectors2.default.current.willCreate)) {
    yield (0, _effects.put)(actions.externalCall());
  } else if (yield (0, _effects.select)(_selectors2.default.current.willReturn)) {
    yield (0, _effects.put)(actions.externalReturn());
  }
}

function* reset() {
  yield (0, _effects.put)(actions.reset());
}

function* saga() {
  yield (0, _effects.takeEvery)(_actions2.TICK, tickSaga);
}

exports.default = (0, _helpers.prefixName)("solidity", saga);

/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.addSource = addSource;
exports.jump = jump;
exports.externalCall = externalCall;
exports.externalReturn = externalReturn;
exports.reset = reset;
const ADD_SOURCE = exports.ADD_SOURCE = "SOLIDITY_ADD_SOURCE";
function addSource(source, sourcePath, ast, compiler) {
  return {
    type: ADD_SOURCE,
    source,
    sourcePath,
    ast,
    compiler
  };
}

const JUMP = exports.JUMP = "JUMP";
function jump(jumpDirection) {
  return {
    type: JUMP,
    jumpDirection
  };
}

const EXTERNAL_CALL = exports.EXTERNAL_CALL = "EXTERNAL_CALL";
function externalCall() {
  return { type: EXTERNAL_CALL };
}

const EXTERNAL_RETURN = exports.EXTERNAL_RETURN = "EXTERNAL_RETURN";
function externalReturn() {
  return { type: EXTERNAL_RETURN };
}

const RESET = exports.RESET = "SOLIDITY_RESET";
function reset() {
  return { type: RESET };
}

/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _debug = __webpack_require__(0);

var _debug2 = _interopRequireDefault(_debug);

var _reselectTree = __webpack_require__(3);

var _selectors = __webpack_require__(11);

var _selectors2 = _interopRequireDefault(_selectors);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const debug = (0, _debug2.default)("debugger:ast:selectors");

/**
 * ast
 */
const ast = (0, _reselectTree.createSelectorTree)({
  /**
   * ast.views
   */
  views: {
    /**
     * ast.views.sources
     */
    sources: (0, _reselectTree.createLeaf)([_selectors2.default.info.sources], sources => sources)
  }
});

exports.default = ast;

/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

var Debugger = __webpack_require__(38).default;

module.exports = Debugger;



/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _asyncToGenerator2 = __webpack_require__(18);

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

var _debug = __webpack_require__(0);

var _debug2 = _interopRequireDefault(_debug);

var _truffleExpect = __webpack_require__(39);

var _truffleExpect2 = _interopRequireDefault(_truffleExpect);

var _session = __webpack_require__(40);

var _session2 = _interopRequireDefault(_session);

var _reselectTree = __webpack_require__(3);

var _selectors = __webpack_require__(21);

var _selectors2 = _interopRequireDefault(_selectors);

var _selectors3 = __webpack_require__(36);

var _selectors4 = _interopRequireDefault(_selectors3);

var _selectors5 = __webpack_require__(10);

var _selectors6 = _interopRequireDefault(_selectors5);

var _selectors7 = __webpack_require__(9);

var _selectors8 = _interopRequireDefault(_selectors7);

var _selectors9 = __webpack_require__(11);

var _selectors10 = _interopRequireDefault(_selectors9);

var _selectors11 = __webpack_require__(26);

var _selectors12 = _interopRequireDefault(_selectors11);

var _selectors13 = __webpack_require__(24);

var _selectors14 = _interopRequireDefault(_selectors13);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const debug = (0, _debug2.default)("debugger");


/**
 * @example
 * let session = Debugger
 *   .forTx(<txHash>, {
 *     contracts: [<contract obj>, ...],
 *     provider: <provider instance>
 *   })
 *   .connect();
 */
class Debugger {
  /**
   * @param {Session} session - debugger session
   * @private
   */
  constructor(session) {
    /**
     * @private
     */
    this._session = session;
  }

  /**
   * Instantiates a Debugger for a given transaction hash.
   *
   * @param {String} txHash - transaction hash with leading "0x"
   * @param {{contracts: Array<Contract>, files: Array<String>, provider: Web3Provider}} options -
   * @return {Debugger} instance
   */
  static forTx(txHash, options = {}) {
    var _this = this;

    return (0, _asyncToGenerator3.default)(function* () {
      _truffleExpect2.default.options(options, ["contracts", "provider"]);

      let session = new _session2.default(options.contracts, options.files, options.provider, txHash);

      try {
        yield session.ready();
        debug("session ready");
      } catch (e) {
        debug("error occurred, unloaded");
        session.unload();
      }

      return new _this(session);
    })();
  }

  /*
   * Instantiates a Debugger for a given project (with no transaction loaded)
   *
   * @param {{contracts: Array<Contract>, files: Array<String>, provider: Web3Provider}} options -
   * @return {Debugger} instance
   */
  static forProject(options = {}) {
    var _this2 = this;

    return (0, _asyncToGenerator3.default)(function* () {
      _truffleExpect2.default.options(options, ["contracts", "provider"]);

      let session = new _session2.default(options.contracts, options.files, options.provider);

      yield session.ready();

      return new _this2(session);
    })();
  }

  /**
   * Connects to the instantiated Debugger.
   *
   * @return {Session} session instance
   */
  connect() {
    return this._session;
  }

  /**
   * Exported selectors
   *
   * See individual selector docs for full listing
   *
   * @example
   * Debugger.selectors.ast.current.tree
   *
   * @example
   * Debugger.selectors.solidity.current.instruction
   *
   * @example
   * Debugger.selectors.trace.steps
   */
  static get selectors() {
    return (0, _reselectTree.createNestedSelector)({
      ast: _selectors4.default,
      data: _selectors2.default,
      trace: _selectors6.default,
      evm: _selectors8.default,
      solidity: _selectors10.default,
      session: _selectors12.default,
      controller: _selectors14.default
    });
  }
}

exports.default = Debugger; /**
                             * @typedef {Object} Contract
                             * @property {string} contractName contract name
                             * @property {string} source solidity source code
                             * @property {string} sourcePath path to source file
                             * @property {string} binary 0x-prefixed hex string with create bytecode
                             * @property {string} sourceMap solidity source map for create bytecode
                             * @property {Object} ast Abstract Syntax Tree from Solidity
                             * @property {string} deployedBinary 0x-prefixed compiled binary (on chain)
                             * @property {string} deployedSourceMap solidity source map for on-chain bytecode
                             */

/***/ }),
/* 39 */
/***/ (function(module, exports) {

module.exports = require("truffle-expect");

/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _entries = __webpack_require__(6);

var _entries2 = _interopRequireDefault(_entries);

var _values = __webpack_require__(19);

var _values2 = _interopRequireDefault(_values);

var _asyncToGenerator2 = __webpack_require__(18);

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

var _promise = __webpack_require__(41);

var _promise2 = _interopRequireDefault(_promise);

var _debug = __webpack_require__(0);

var _debug2 = _interopRequireDefault(_debug);

var _store = __webpack_require__(42);

var _store2 = _interopRequireDefault(_store);

var _actions = __webpack_require__(20);

var controller = _interopRequireWildcard(_actions);

var _actions2 = __webpack_require__(14);

var actions = _interopRequireWildcard(_actions2);

var _selectors = __webpack_require__(21);

var _selectors2 = _interopRequireDefault(_selectors);

var _selectors3 = __webpack_require__(26);

var _selectors4 = _interopRequireDefault(_selectors3);

var _sagas = __webpack_require__(17);

var dataSagas = _interopRequireWildcard(_sagas);

var _sagas2 = __webpack_require__(33);

var controllerSagas = _interopRequireWildcard(_sagas2);

var _sagas3 = __webpack_require__(59);

var sagas = _interopRequireWildcard(_sagas3);

var _selectors5 = __webpack_require__(24);

var _selectors6 = _interopRequireDefault(_selectors5);

var _reducers = __webpack_require__(61);

var _reducers2 = _interopRequireDefault(_reducers);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const debug = (0, _debug2.default)("debugger:session");

/**
 * Debugger Session
 */
class Session {
  /**
   * @param {Array<Contract>} contracts - contract definitions
   * @param {Array<String>} files - array of filenames for sourceMap indexes
   * @param {Web3Provider} provider - web3 provider
   * txHash parameter is now optional!
   * @private
   */
  constructor(contracts, files, provider, txHash) {
    /**
     * @private
     */
    let { store, sagaMiddleware } = (0, _store2.default)(_reducers2.default, sagas.default);
    this._store = store;
    this._sagaMiddleware = sagaMiddleware;

    let { contexts, sources } = Session.normalize(contracts, files);

    // record contracts
    this._store.dispatch(actions.recordContracts(contexts, sources));

    //set up the ready listener
    this._ready = new _promise2.default((accept, reject) => {
      const unsubscribe = this._store.subscribe(() => {
        if (this.view(_selectors4.default.status.ready)) {
          debug("ready!");
          unsubscribe();
          accept();
        } else if (this.view(_selectors4.default.status.errored)) {
          debug("error!");
          unsubscribe();
          reject(this.view(_selectors4.default.status.error));
        }
      });
    });

    //note that txHash is now optional
    this._store.dispatch(actions.start(provider, txHash));
  }

  ready() {
    var _this = this;

    return (0, _asyncToGenerator3.default)(function* () {
      yield _this._ready;
    })();
  }

  readyAgainAfterLoading(sessionAction) {
    var _this2 = this;

    return (0, _asyncToGenerator3.default)(function* () {
      return new _promise2.default(function (accept, reject) {
        let hasStartedWaiting = false;
        debug("reready listener set up");
        const unsubscribe = _this2._store.subscribe(function () {
          debug("reready?");
          if (hasStartedWaiting) {
            if (_this2.view(_selectors4.default.status.ready)) {
              debug("reready!");
              unsubscribe();
              accept(true);
            } else if (_this2.view(_selectors4.default.status.errored)) {
              unsubscribe();
              debug("error!");
              reject(_this2.view(_selectors4.default.status.error));
            }
          } else {
            if (_this2.view(_selectors4.default.status.waiting)) {
              debug("started waiting");
              hasStartedWaiting = true;
            }
            return;
          }
        });
        _this2.dispatch(sessionAction);
      });
    })();
  }

  /**
   * Split up artifacts into "contexts" and "sources", dividing artifact
   * data into appropriate buckets.
   *
   * Multiple contracts can be defined in the same source file, but have
   * different bytecodes.
   *
   * This iterates over the contracts and collects binaries separately
   * from sources, using the optional `files` argument to force
   * source ordering.
   * @private
   */
  static normalize(contracts, files = null) {
    let sourcesByPath = {};
    let contexts = [];
    let sources;

    for (let contract of contracts) {
      let {
        contractName,
        binary,
        sourceMap,
        deployedBinary,
        deployedSourceMap,
        sourcePath,
        source,
        ast,
        abi,
        compiler
      } = contract;

      let contractNode = ast.nodes.find(node => node.nodeType === "ContractDefinition" && node.name === contractName); //ideally we'd hold this off till later, but that would break the
      //direction of the evm/solidity dependence, so we do it now

      let contractId = contractNode.id;
      let contractKind = contractNode.contractKind;

      debug("contractName %s", contractName);
      debug("sourceMap %o", sourceMap);
      debug("compiler %o", compiler);
      debug("abi %O", abi);

      sourcesByPath[sourcePath] = { sourcePath, source, ast, compiler };

      if (binary && binary != "0x") {
        contexts.push({
          contractName,
          binary,
          sourceMap,
          abi,
          compiler,
          contractId,
          contractKind,
          isConstructor: true
        });
      }

      if (deployedBinary && deployedBinary != "0x") {
        contexts.push({
          contractName,
          binary: deployedBinary,
          sourceMap: deployedSourceMap,
          abi,
          compiler,
          contractId,
          contractKind,
          isConstructor: false
        });
      }
    }

    if (!files) {
      sources = (0, _values2.default)(sourcesByPath);
    } else {
      sources = files.map(file => sourcesByPath[file]);
    }

    return { contexts, sources };
  }

  get state() {
    return this._store.getState();
  }

  view(selector) {
    return selector(this.state);
  }

  dispatch(action) {
    var _this3 = this;

    return (0, _asyncToGenerator3.default)(function* () {
      _this3._store.dispatch(action);

      return true;
    })();
  }

  /**
   * @private
   * Allows running any saga -- for internal use only!
   * Using this could seriously screw up the debugger state if you
   * don't know what you're doing!
   */
  _runSaga(saga, ...args) {
    var _this4 = this;

    return (0, _asyncToGenerator3.default)(function* () {
      return yield _this4._sagaMiddleware.run(saga, ...args).toPromise();
    })();
  }

  interrupt() {
    var _this5 = this;

    return (0, _asyncToGenerator3.default)(function* () {
      yield _this5.dispatch(actions.interrupt());
      yield _this5.dispatch(controller.interrupt());
    })();
  }

  doneStepping(stepperAction) {
    var _this6 = this;

    return (0, _asyncToGenerator3.default)(function* () {
      return new _promise2.default(function (resolve) {
        let hasStarted = false;
        const unsubscribe = _this6._store.subscribe(function () {
          const isStepping = _this6.view(_selectors6.default.isStepping);

          if (isStepping && !hasStarted) {
            hasStarted = true;
            debug("heard step start");
            return;
          }

          if (!isStepping && hasStarted) {
            debug("heard step stop");
            unsubscribe();
            resolve(true);
          }
        });
        _this6.dispatch(stepperAction);
      });
    })();
  }

  //returns true on success, false on already loaded, error object on failure
  load(txHash) {
    var _this7 = this;

    return (0, _asyncToGenerator3.default)(function* () {
      if (_this7.view(_selectors4.default.status.loaded)) {
        return false;
      }
      try {
        return yield _this7.readyAgainAfterLoading(actions.loadTransaction(txHash));
      } catch (e) {
        _this7._runSaga(sagas.unload);
        return e;
      }
    })();
  }

  //returns true on success, false on already unloaded
  unload() {
    var _this8 = this;

    return (0, _asyncToGenerator3.default)(function* () {
      if (!_this8.view(_selectors4.default.status.loaded)) {
        return false;
      }
      debug("unloading");
      yield _this8._runSaga(sagas.unload);
      return true;
    })();
  }

  //Note: count is an optional argument; default behavior is to advance 1
  advance(count) {
    var _this9 = this;

    return (0, _asyncToGenerator3.default)(function* () {
      return yield _this9.doneStepping(controller.advance(count));
    })();
  }

  stepNext() {
    var _this10 = this;

    return (0, _asyncToGenerator3.default)(function* () {
      return yield _this10.doneStepping(controller.stepNext());
    })();
  }

  stepOver() {
    var _this11 = this;

    return (0, _asyncToGenerator3.default)(function* () {
      return yield _this11.doneStepping(controller.stepOver());
    })();
  }

  stepInto() {
    var _this12 = this;

    return (0, _asyncToGenerator3.default)(function* () {
      return yield _this12.doneStepping(controller.stepInto());
    })();
  }

  stepOut() {
    var _this13 = this;

    return (0, _asyncToGenerator3.default)(function* () {
      return yield _this13.doneStepping(controller.stepOut());
    })();
  }

  reset() {
    var _this14 = this;

    return (0, _asyncToGenerator3.default)(function* () {
      let loaded = _this14.view(_selectors4.default.status.loaded);
      if (!loaded) {
        return;
      }
      return yield _this14._runSaga(controllerSagas.reset);
    })();
  }

  //NOTE: breakpoints is an OPTIONAL argument for if you want to supply your
  //own list of breakpoints; leave it out to use the internal one (as
  //controlled by the functions below)
  continueUntilBreakpoint(breakpoints) {
    var _this15 = this;

    return (0, _asyncToGenerator3.default)(function* () {
      return yield _this15.doneStepping(controller.continueUntilBreakpoint(breakpoints));
    })();
  }

  addBreakpoint(breakpoint) {
    var _this16 = this;

    return (0, _asyncToGenerator3.default)(function* () {
      return yield _this16.dispatch(controller.addBreakpoint(breakpoint));
    })();
  }

  removeBreakpoint(breakpoint) {
    var _this17 = this;

    return (0, _asyncToGenerator3.default)(function* () {
      return yield _this17.dispatch(controller.removeBreakpoint(breakpoint));
    })();
  }

  removeAllBreakpoints() {
    var _this18 = this;

    return (0, _asyncToGenerator3.default)(function* () {
      return yield _this18.dispatch(controller.removeAllBreakpoints());
    })();
  }

  //deprecated -- decode is now *always* ready!
  decodeReady() {
    return (0, _asyncToGenerator3.default)(function* () {
      return true;
    })();
  }

  variable(name) {
    var _this19 = this;

    return (0, _asyncToGenerator3.default)(function* () {
      const definitions = _this19.view(_selectors2.default.current.identifiers.definitions);
      const refs = _this19.view(_selectors2.default.current.identifiers.refs);

      return yield _this19._runSaga(dataSagas.decode, definitions[name], refs[name]);
    })();
  }

  variables() {
    var _this20 = this;

    return (0, _asyncToGenerator3.default)(function* () {
      if (!_this20.view(_selectors4.default.status.loaded)) {
        return {};
      }
      let definitions = _this20.view(_selectors2.default.current.identifiers.definitions);
      let refs = _this20.view(_selectors2.default.current.identifiers.refs);
      let decoded = {};
      for (let [identifier, ref] of (0, _entries2.default)(refs)) {
        if (identifier in definitions) {
          decoded[identifier] = yield _this20._runSaga(dataSagas.decode, definitions[identifier], ref);
        }
      }
      return decoded;
    })();
  }
}
exports.default = Session;

/***/ }),
/* 41 */
/***/ (function(module, exports) {

module.exports = require("babel-runtime/core-js/promise");

/***/ }),
/* 42 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


if (true) {
  module.exports = __webpack_require__(43);
} else if (process.env.NODE_ENV === "test") {
  module.exports = require("./test");
} else {
  module.exports = require("./development");
}

/***/ }),
/* 43 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _common = __webpack_require__(44);

var _common2 = _interopRequireDefault(_common);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = _common2.default;

/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _entries = __webpack_require__(6);

var _entries2 = _interopRequireDefault(_entries);

var _assign = __webpack_require__(8);

var _assign2 = _interopRequireDefault(_assign);

exports.abbreviateValues = abbreviateValues;
exports.default = configureStore;

var _debug = __webpack_require__(0);

var _debug2 = _interopRequireDefault(_debug);

var _redux = __webpack_require__(7);

var _reduxSaga = __webpack_require__(45);

var _reduxSaga2 = _interopRequireDefault(_reduxSaga);

var _reduxCliLogger = __webpack_require__(46);

var _reduxCliLogger2 = _interopRequireDefault(_reduxCliLogger);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const debug = (0, _debug2.default)("debugger:store:common");
const reduxDebug = (0, _debug2.default)("debugger:redux");

function abbreviateValues(value, options = {}, depth = 0) {
  options.stringLimit = options.stringLimit || 66;
  options.arrayLimit = options.arrayLimit || 8;
  options.recurseLimit = options.recurseLimit || 4;

  if (depth > options.recurseLimit) {
    return "...";
  }

  const recurse = child => abbreviateValues(child, options, depth + 1);

  if (value instanceof Array) {
    if (value.length > options.arrayLimit) {
      value = [...value.slice(0, options.arrayLimit / 2), "...", ...value.slice(value.length - options.arrayLimit / 2 + 1)];
    }

    return value.map(recurse);
  } else if (value instanceof Object) {
    return (0, _assign2.default)({}, ...(0, _entries2.default)(value).map(([k, v]) => ({ [recurse(k)]: recurse(v) })));
  } else if (typeof value === "string" && value.length > options.stringLimit) {
    let inner = "...";
    let extractAmount = (options.stringLimit - inner.length) / 2;
    let leading = value.slice(0, Math.ceil(extractAmount));
    let trailing = value.slice(value.length - Math.floor(extractAmount));
    return `${leading}${inner}${trailing}`;
  } else {
    return value;
  }
}

function configureStore(reducer, saga, initialState, composeEnhancers) {
  const sagaMiddleware = (0, _reduxSaga2.default)();

  if (!composeEnhancers) {
    composeEnhancers = _redux.compose;
  }

  const loggerMiddleware = (0, _reduxCliLogger2.default)({
    log: reduxDebug,
    stateTransformer: state => abbreviateValues(state, {
      arrayLimit: 4,
      recurseLimit: 3
    }),
    actionTransformer: abbreviateValues
  });

  let store = (0, _redux.createStore)(reducer, initialState, composeEnhancers((0, _redux.applyMiddleware)(sagaMiddleware, loggerMiddleware)));

  sagaMiddleware.run(saga);

  return { store, sagaMiddleware };
}

/***/ }),
/* 45 */
/***/ (function(module, exports) {

module.exports = require("redux-saga");

/***/ }),
/* 46 */
/***/ (function(module, exports) {

module.exports = require("redux-cli-logger");

/***/ }),
/* 47 */
/***/ (function(module, exports, __webpack_require__) {

var json = typeof JSON !== 'undefined' ? JSON : __webpack_require__(48);

module.exports = function (obj, opts) {
    if (!opts) opts = {};
    if (typeof opts === 'function') opts = { cmp: opts };
    var space = opts.space || '';
    if (typeof space === 'number') space = Array(space+1).join(' ');
    var cycles = (typeof opts.cycles === 'boolean') ? opts.cycles : false;
    var replacer = opts.replacer || function(key, value) { return value; };

    var cmp = opts.cmp && (function (f) {
        return function (node) {
            return function (a, b) {
                var aobj = { key: a, value: node[a] };
                var bobj = { key: b, value: node[b] };
                return f(aobj, bobj);
            };
        };
    })(opts.cmp);

    var seen = [];
    return (function stringify (parent, key, node, level) {
        var indent = space ? ('\n' + new Array(level + 1).join(space)) : '';
        var colonSeparator = space ? ': ' : ':';

        if (node && node.toJSON && typeof node.toJSON === 'function') {
            node = node.toJSON();
        }

        node = replacer.call(parent, key, node);

        if (node === undefined) {
            return;
        }
        if (typeof node !== 'object' || node === null) {
            return json.stringify(node);
        }
        if (isArray(node)) {
            var out = [];
            for (var i = 0; i < node.length; i++) {
                var item = stringify(node, i, node[i], level+1) || json.stringify(null);
                out.push(indent + space + item);
            }
            return '[' + out.join(',') + indent + ']';
        }
        else {
            if (seen.indexOf(node) !== -1) {
                if (cycles) return json.stringify('__cycle__');
                throw new TypeError('Converting circular structure to JSON');
            }
            else seen.push(node);

            var keys = objectKeys(node).sort(cmp && cmp(node));
            var out = [];
            for (var i = 0; i < keys.length; i++) {
                var key = keys[i];
                var value = stringify(node, key, node[key], level+1);

                if(!value) continue;

                var keyValue = json.stringify(key)
                    + colonSeparator
                    + value;
                ;
                out.push(indent + space + keyValue);
            }
            seen.splice(seen.indexOf(node), 1);
            return '{' + out.join(',') + indent + '}';
        }
    })({ '': obj }, '', obj, 0);
};

var isArray = Array.isArray || function (x) {
    return {}.toString.call(x) === '[object Array]';
};

var objectKeys = Object.keys || function (obj) {
    var has = Object.prototype.hasOwnProperty || function () { return true };
    var keys = [];
    for (var key in obj) {
        if (has.call(obj, key)) keys.push(key);
    }
    return keys;
};


/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

exports.parse = __webpack_require__(49);
exports.stringify = __webpack_require__(50);


/***/ }),
/* 49 */
/***/ (function(module, exports) {

var at, // The index of the current character
    ch, // The current character
    escapee = {
        '"':  '"',
        '\\': '\\',
        '/':  '/',
        b:    '\b',
        f:    '\f',
        n:    '\n',
        r:    '\r',
        t:    '\t'
    },
    text,

    error = function (m) {
        // Call error when something is wrong.
        throw {
            name:    'SyntaxError',
            message: m,
            at:      at,
            text:    text
        };
    },
    
    next = function (c) {
        // If a c parameter is provided, verify that it matches the current character.
        if (c && c !== ch) {
            error("Expected '" + c + "' instead of '" + ch + "'");
        }
        
        // Get the next character. When there are no more characters,
        // return the empty string.
        
        ch = text.charAt(at);
        at += 1;
        return ch;
    },
    
    number = function () {
        // Parse a number value.
        var number,
            string = '';
        
        if (ch === '-') {
            string = '-';
            next('-');
        }
        while (ch >= '0' && ch <= '9') {
            string += ch;
            next();
        }
        if (ch === '.') {
            string += '.';
            while (next() && ch >= '0' && ch <= '9') {
                string += ch;
            }
        }
        if (ch === 'e' || ch === 'E') {
            string += ch;
            next();
            if (ch === '-' || ch === '+') {
                string += ch;
                next();
            }
            while (ch >= '0' && ch <= '9') {
                string += ch;
                next();
            }
        }
        number = +string;
        if (!isFinite(number)) {
            error("Bad number");
        } else {
            return number;
        }
    },
    
    string = function () {
        // Parse a string value.
        var hex,
            i,
            string = '',
            uffff;
        
        // When parsing for string values, we must look for " and \ characters.
        if (ch === '"') {
            while (next()) {
                if (ch === '"') {
                    next();
                    return string;
                } else if (ch === '\\') {
                    next();
                    if (ch === 'u') {
                        uffff = 0;
                        for (i = 0; i < 4; i += 1) {
                            hex = parseInt(next(), 16);
                            if (!isFinite(hex)) {
                                break;
                            }
                            uffff = uffff * 16 + hex;
                        }
                        string += String.fromCharCode(uffff);
                    } else if (typeof escapee[ch] === 'string') {
                        string += escapee[ch];
                    } else {
                        break;
                    }
                } else {
                    string += ch;
                }
            }
        }
        error("Bad string");
    },

    white = function () {

// Skip whitespace.

        while (ch && ch <= ' ') {
            next();
        }
    },

    word = function () {

// true, false, or null.

        switch (ch) {
        case 't':
            next('t');
            next('r');
            next('u');
            next('e');
            return true;
        case 'f':
            next('f');
            next('a');
            next('l');
            next('s');
            next('e');
            return false;
        case 'n':
            next('n');
            next('u');
            next('l');
            next('l');
            return null;
        }
        error("Unexpected '" + ch + "'");
    },

    value,  // Place holder for the value function.

    array = function () {

// Parse an array value.

        var array = [];

        if (ch === '[') {
            next('[');
            white();
            if (ch === ']') {
                next(']');
                return array;   // empty array
            }
            while (ch) {
                array.push(value());
                white();
                if (ch === ']') {
                    next(']');
                    return array;
                }
                next(',');
                white();
            }
        }
        error("Bad array");
    },

    object = function () {

// Parse an object value.

        var key,
            object = {};

        if (ch === '{') {
            next('{');
            white();
            if (ch === '}') {
                next('}');
                return object;   // empty object
            }
            while (ch) {
                key = string();
                white();
                next(':');
                if (Object.hasOwnProperty.call(object, key)) {
                    error('Duplicate key "' + key + '"');
                }
                object[key] = value();
                white();
                if (ch === '}') {
                    next('}');
                    return object;
                }
                next(',');
                white();
            }
        }
        error("Bad object");
    };

value = function () {

// Parse a JSON value. It could be an object, an array, a string, a number,
// or a word.

    white();
    switch (ch) {
    case '{':
        return object();
    case '[':
        return array();
    case '"':
        return string();
    case '-':
        return number();
    default:
        return ch >= '0' && ch <= '9' ? number() : word();
    }
};

// Return the json_parse function. It will have access to all of the above
// functions and variables.

module.exports = function (source, reviver) {
    var result;
    
    text = source;
    at = 0;
    ch = ' ';
    result = value();
    white();
    if (ch) {
        error("Syntax error");
    }

    // If there is a reviver function, we recursively walk the new structure,
    // passing each name/value pair to the reviver function for possible
    // transformation, starting with a temporary root object that holds the result
    // in an empty key. If there is not a reviver function, we simply return the
    // result.

    return typeof reviver === 'function' ? (function walk(holder, key) {
        var k, v, value = holder[key];
        if (value && typeof value === 'object') {
            for (k in value) {
                if (Object.prototype.hasOwnProperty.call(value, k)) {
                    v = walk(value, k);
                    if (v !== undefined) {
                        value[k] = v;
                    } else {
                        delete value[k];
                    }
                }
            }
        }
        return reviver.call(holder, key, value);
    }({'': result}, '')) : result;
};


/***/ }),
/* 50 */
/***/ (function(module, exports) {

var cx = /[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
    escapable = /[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
    gap,
    indent,
    meta = {    // table of character substitutions
        '\b': '\\b',
        '\t': '\\t',
        '\n': '\\n',
        '\f': '\\f',
        '\r': '\\r',
        '"' : '\\"',
        '\\': '\\\\'
    },
    rep;

function quote(string) {
    // If the string contains no control characters, no quote characters, and no
    // backslash characters, then we can safely slap some quotes around it.
    // Otherwise we must also replace the offending characters with safe escape
    // sequences.
    
    escapable.lastIndex = 0;
    return escapable.test(string) ? '"' + string.replace(escapable, function (a) {
        var c = meta[a];
        return typeof c === 'string' ? c :
            '\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
    }) + '"' : '"' + string + '"';
}

function str(key, holder) {
    // Produce a string from holder[key].
    var i,          // The loop counter.
        k,          // The member key.
        v,          // The member value.
        length,
        mind = gap,
        partial,
        value = holder[key];
    
    // If the value has a toJSON method, call it to obtain a replacement value.
    if (value && typeof value === 'object' &&
            typeof value.toJSON === 'function') {
        value = value.toJSON(key);
    }
    
    // If we were called with a replacer function, then call the replacer to
    // obtain a replacement value.
    if (typeof rep === 'function') {
        value = rep.call(holder, key, value);
    }
    
    // What happens next depends on the value's type.
    switch (typeof value) {
        case 'string':
            return quote(value);
        
        case 'number':
            // JSON numbers must be finite. Encode non-finite numbers as null.
            return isFinite(value) ? String(value) : 'null';
        
        case 'boolean':
        case 'null':
            // If the value is a boolean or null, convert it to a string. Note:
            // typeof null does not produce 'null'. The case is included here in
            // the remote chance that this gets fixed someday.
            return String(value);
            
        case 'object':
            if (!value) return 'null';
            gap += indent;
            partial = [];
            
            // Array.isArray
            if (Object.prototype.toString.apply(value) === '[object Array]') {
                length = value.length;
                for (i = 0; i < length; i += 1) {
                    partial[i] = str(i, value) || 'null';
                }
                
                // Join all of the elements together, separated with commas, and
                // wrap them in brackets.
                v = partial.length === 0 ? '[]' : gap ?
                    '[\n' + gap + partial.join(',\n' + gap) + '\n' + mind + ']' :
                    '[' + partial.join(',') + ']';
                gap = mind;
                return v;
            }
            
            // If the replacer is an array, use it to select the members to be
            // stringified.
            if (rep && typeof rep === 'object') {
                length = rep.length;
                for (i = 0; i < length; i += 1) {
                    k = rep[i];
                    if (typeof k === 'string') {
                        v = str(k, value);
                        if (v) {
                            partial.push(quote(k) + (gap ? ': ' : ':') + v);
                        }
                    }
                }
            }
            else {
                // Otherwise, iterate through all of the keys in the object.
                for (k in value) {
                    if (Object.prototype.hasOwnProperty.call(value, k)) {
                        v = str(k, value);
                        if (v) {
                            partial.push(quote(k) + (gap ? ': ' : ':') + v);
                        }
                    }
                }
            }
            
        // Join all of the member texts together, separated with commas,
        // and wrap them in braces.

        v = partial.length === 0 ? '{}' : gap ?
            '{\n' + gap + partial.join(',\n' + gap) + '\n' + mind + '}' :
            '{' + partial.join(',') + '}';
        gap = mind;
        return v;
    }
}

module.exports = function (value, replacer, space) {
    var i;
    gap = '';
    indent = '';
    
    // If the space parameter is a number, make an indent string containing that
    // many spaces.
    if (typeof space === 'number') {
        for (i = 0; i < space; i += 1) {
            indent += ' ';
        }
    }
    // If the space parameter is a string, it will be used as the indent string.
    else if (typeof space === 'string') {
        indent = space;
    }

    // If there is a replacer, it must be a function or an array.
    // Otherwise, throw an error.
    rep = replacer;
    if (replacer && typeof replacer !== 'function'
    && (typeof replacer !== 'object' || typeof replacer.length !== 'number')) {
        throw new Error('JSON.stringify');
    }
    
    // Make a fake root object containing our value under the key of ''.
    // Return the result of stringifying the value.
    return str('', {'': value});
};


/***/ }),
/* 51 */
/***/ (function(module, exports) {

module.exports = require("truffle-solidity-utils");

/***/ }),
/* 52 */
/***/ (function(module, exports) {

module.exports = require("truffle-code-utils");

/***/ }),
/* 53 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// An augmented AVL Tree where each node maintains a list of records and their search intervals.
// Record is composed of an interval and its underlying data, sent by a client. This allows the
// interval tree to have the same interval inserted multiple times, as long its data is different.
// Both insertion and deletion require O(log n) time. Searching requires O(k*logn) time, where `k`
// is the number of intervals in the output list.
Object.defineProperty(exports, "__esModule", { value: true });
var isSame = __webpack_require__(54);
function height(node) {
    if (node === undefined) {
        return -1;
    }
    else {
        return node.height;
    }
}
var Node = /** @class */ (function () {
    function Node(intervalTree, record) {
        this.intervalTree = intervalTree;
        this.records = [];
        this.height = 0;
        this.key = record.low;
        this.max = record.high;
        // Save the array of all records with the same key for this node
        this.records.push(record);
    }
    // Gets the highest record.high value for this node
    Node.prototype.getNodeHigh = function () {
        var high = this.records[0].high;
        for (var i = 1; i < this.records.length; i++) {
            if (this.records[i].high > high) {
                high = this.records[i].high;
            }
        }
        return high;
    };
    // Updates height value of the node. Called during insertion, rebalance, removal
    Node.prototype.updateHeight = function () {
        this.height = Math.max(height(this.left), height(this.right)) + 1;
    };
    // Updates the max value of all the parents after inserting into already existing node, as well as
    // removing the node completely or removing the record of an already existing node. Starts with
    // the parent of an affected node and bubbles up to root
    Node.prototype.updateMaxOfParents = function () {
        if (this === undefined) {
            return;
        }
        var thisHigh = this.getNodeHigh();
        if (this.left !== undefined && this.right !== undefined) {
            this.max = Math.max(Math.max(this.left.max, this.right.max), thisHigh);
        }
        else if (this.left !== undefined && this.right === undefined) {
            this.max = Math.max(this.left.max, thisHigh);
        }
        else if (this.left === undefined && this.right !== undefined) {
            this.max = Math.max(this.right.max, thisHigh);
        }
        else {
            this.max = thisHigh;
        }
        if (this.parent) {
            this.parent.updateMaxOfParents();
        }
    };
    /*
    Left-Left case:
  
           z                                      y
          / \                                   /   \
         y   T4      Right Rotate (z)          x     z
        / \          - - - - - - - - ->       / \   / \
       x   T3                                T1 T2 T3 T4
      / \
    T1   T2
  
    Left-Right case:
  
         z                               z                           x
        / \                             / \                        /   \
       y   T4  Left Rotate (y)         x  T4  Right Rotate(z)     y     z
      / \      - - - - - - - - ->     / \      - - - - - - - ->  / \   / \
    T1   x                           y  T3                      T1 T2 T3 T4
        / \                         / \
      T2   T3                      T1 T2
    */
    // Handles Left-Left case and Left-Right case after rebalancing AVL tree
    Node.prototype._updateMaxAfterRightRotate = function () {
        var parent = this.parent;
        var left = parent.left;
        // Update max of left sibling (x in first case, y in second)
        var thisParentLeftHigh = left.getNodeHigh();
        if (left.left === undefined && left.right !== undefined) {
            left.max = Math.max(thisParentLeftHigh, left.right.max);
        }
        else if (left.left !== undefined && left.right === undefined) {
            left.max = Math.max(thisParentLeftHigh, left.left.max);
        }
        else if (left.left === undefined && left.right === undefined) {
            left.max = thisParentLeftHigh;
        }
        else {
            left.max = Math.max(Math.max(left.left.max, left.right.max), thisParentLeftHigh);
        }
        // Update max of itself (z)
        var thisHigh = this.getNodeHigh();
        if (this.left === undefined && this.right !== undefined) {
            this.max = Math.max(thisHigh, this.right.max);
        }
        else if (this.left !== undefined && this.right === undefined) {
            this.max = Math.max(thisHigh, this.left.max);
        }
        else if (this.left === undefined && this.right === undefined) {
            this.max = thisHigh;
        }
        else {
            this.max = Math.max(Math.max(this.left.max, this.right.max), thisHigh);
        }
        // Update max of parent (y in first case, x in second)
        parent.max = Math.max(Math.max(parent.left.max, parent.right.max), parent.getNodeHigh());
    };
    /*
    Right-Right case:
  
      z                               y
     / \                            /   \
    T1  y     Left Rotate(z)       z     x
       / \   - - - - - - - ->     / \   / \
      T2  x                      T1 T2 T3 T4
         / \
        T3 T4
  
    Right-Left case:
  
       z                            z                            x
      / \                          / \                         /   \
     T1  y   Right Rotate (y)     T1  x      Left Rotate(z)   z     y
        / \  - - - - - - - - ->      / \   - - - - - - - ->  / \   / \
       x  T4                        T2  y                   T1 T2 T3 T4
      / \                              / \
    T2   T3                           T3 T4
    */
    // Handles Right-Right case and Right-Left case in rebalancing AVL tree
    Node.prototype._updateMaxAfterLeftRotate = function () {
        var parent = this.parent;
        var right = parent.right;
        // Update max of right sibling (x in first case, y in second)
        var thisParentRightHigh = right.getNodeHigh();
        if (right.left === undefined && right.right !== undefined) {
            right.max = Math.max(thisParentRightHigh, right.right.max);
        }
        else if (right.left !== undefined && right.right === undefined) {
            right.max = Math.max(thisParentRightHigh, right.left.max);
        }
        else if (right.left === undefined && right.right === undefined) {
            right.max = thisParentRightHigh;
        }
        else {
            right.max = Math.max(Math.max(right.left.max, right.right.max), thisParentRightHigh);
        }
        // Update max of itself (z)
        var thisHigh = this.getNodeHigh();
        if (this.left === undefined && this.right !== undefined) {
            this.max = Math.max(thisHigh, this.right.max);
        }
        else if (this.left !== undefined && this.right === undefined) {
            this.max = Math.max(thisHigh, this.left.max);
        }
        else if (this.left === undefined && this.right === undefined) {
            this.max = thisHigh;
        }
        else {
            this.max = Math.max(Math.max(this.left.max, this.right.max), thisHigh);
        }
        // Update max of parent (y in first case, x in second)
        parent.max = Math.max(Math.max(parent.left.max, right.max), parent.getNodeHigh());
    };
    Node.prototype._leftRotate = function () {
        var rightChild = this.right;
        rightChild.parent = this.parent;
        if (rightChild.parent === undefined) {
            this.intervalTree.root = rightChild;
        }
        else {
            if (rightChild.parent.left === this) {
                rightChild.parent.left = rightChild;
            }
            else if (rightChild.parent.right === this) {
                rightChild.parent.right = rightChild;
            }
        }
        this.right = rightChild.left;
        if (this.right !== undefined) {
            this.right.parent = this;
        }
        rightChild.left = this;
        this.parent = rightChild;
        this.updateHeight();
        rightChild.updateHeight();
    };
    Node.prototype._rightRotate = function () {
        var leftChild = this.left;
        leftChild.parent = this.parent;
        if (leftChild.parent === undefined) {
            this.intervalTree.root = leftChild;
        }
        else {
            if (leftChild.parent.left === this) {
                leftChild.parent.left = leftChild;
            }
            else if (leftChild.parent.right === this) {
                leftChild.parent.right = leftChild;
            }
        }
        this.left = leftChild.right;
        if (this.left !== undefined) {
            this.left.parent = this;
        }
        leftChild.right = this;
        this.parent = leftChild;
        this.updateHeight();
        leftChild.updateHeight();
    };
    // Rebalances the tree if the height value between two nodes of the same parent is greater than
    // two. There are 4 cases that can happen which are outlined in the graphics above
    Node.prototype._rebalance = function () {
        if (height(this.left) >= 2 + height(this.right)) {
            var left = this.left;
            if (height(left.left) >= height(left.right)) {
                // Left-Left case
                this._rightRotate();
                this._updateMaxAfterRightRotate();
            }
            else {
                // Left-Right case
                left._leftRotate();
                this._rightRotate();
                this._updateMaxAfterRightRotate();
            }
        }
        else if (height(this.right) >= 2 + height(this.left)) {
            var right = this.right;
            if (height(right.right) >= height(right.left)) {
                // Right-Right case
                this._leftRotate();
                this._updateMaxAfterLeftRotate();
            }
            else {
                // Right-Left case
                right._rightRotate();
                this._leftRotate();
                this._updateMaxAfterLeftRotate();
            }
        }
    };
    Node.prototype.insert = function (record) {
        if (record.low < this.key) {
            // Insert into left subtree
            if (this.left === undefined) {
                this.left = new Node(this.intervalTree, record);
                this.left.parent = this;
            }
            else {
                this.left.insert(record);
            }
        }
        else {
            // Insert into right subtree
            if (this.right === undefined) {
                this.right = new Node(this.intervalTree, record);
                this.right.parent = this;
            }
            else {
                this.right.insert(record);
            }
        }
        // Update the max value of this ancestor if needed
        if (this.max < record.high) {
            this.max = record.high;
        }
        // Update height of each node
        this.updateHeight();
        // Rebalance the tree to ensure all operations are executed in O(logn) time. This is especially
        // important in searching, as the tree has a high chance of degenerating without the rebalancing
        this._rebalance();
    };
    Node.prototype._getOverlappingRecords = function (currentNode, low, high) {
        if (currentNode.key <= high && low <= currentNode.getNodeHigh()) {
            // Nodes are overlapping, check if individual records in the node are overlapping
            var tempResults = [];
            for (var i = 0; i < currentNode.records.length; i++) {
                if (currentNode.records[i].high >= low) {
                    tempResults.push(currentNode.records[i]);
                }
            }
            return tempResults;
        }
        return [];
    };
    Node.prototype.search = function (low, high) {
        // Don't search nodes that don't exist
        if (this === undefined) {
            return [];
        }
        var leftSearch = [];
        var ownSearch = [];
        var rightSearch = [];
        // If interval is to the right of the rightmost point of any interval in this node and all its
        // children, there won't be any matches
        if (low > this.max) {
            return [];
        }
        // Search left children
        if (this.left !== undefined && this.left.max >= low) {
            leftSearch = this.left.search(low, high);
        }
        // Check this node
        ownSearch = this._getOverlappingRecords(this, low, high);
        // If interval is to the left of the start of this interval, then it can't be in any child to
        // the right
        if (high < this.key) {
            return leftSearch.concat(ownSearch);
        }
        // Otherwise, search right children
        if (this.right !== undefined) {
            rightSearch = this.right.search(low, high);
        }
        // Return accumulated results, if any
        return leftSearch.concat(ownSearch, rightSearch);
    };
    // Searches for a node by a `key` value
    Node.prototype.searchExisting = function (low) {
        if (this === undefined) {
            return undefined;
        }
        if (this.key === low) {
            return this;
        }
        else if (low < this.key) {
            if (this.left !== undefined) {
                return this.left.searchExisting(low);
            }
        }
        else {
            if (this.right !== undefined) {
                return this.right.searchExisting(low);
            }
        }
        return undefined;
    };
    // Returns the smallest node of the subtree
    Node.prototype._minValue = function () {
        if (this.left === undefined) {
            return this;
        }
        else {
            return this.left._minValue();
        }
    };
    Node.prototype.remove = function (node) {
        var parent = this.parent;
        if (node.key < this.key) {
            // Node to be removed is on the left side
            if (this.left !== undefined) {
                return this.left.remove(node);
            }
            else {
                return undefined;
            }
        }
        else if (node.key > this.key) {
            // Node to be removed is on the right side
            if (this.right !== undefined) {
                return this.right.remove(node);
            }
            else {
                return undefined;
            }
        }
        else {
            if (this.left !== undefined && this.right !== undefined) {
                // Node has two children
                var minValue = this.right._minValue();
                this.key = minValue.key;
                this.records = minValue.records;
                return this.right.remove(this);
            }
            else if (parent.left === this) {
                // One child or no child case on left side
                if (this.right !== undefined) {
                    parent.left = this.right;
                    this.right.parent = parent;
                }
                else {
                    parent.left = this.left;
                    if (this.left !== undefined) {
                        this.left.parent = parent;
                    }
                }
                parent.updateMaxOfParents();
                parent.updateHeight();
                parent._rebalance();
                return this;
            }
            else if (parent.right === this) {
                // One child or no child case on right side
                if (this.right !== undefined) {
                    parent.right = this.right;
                    this.right.parent = parent;
                }
                else {
                    parent.right = this.left;
                    if (this.left !== undefined) {
                        this.left.parent = parent;
                    }
                }
                parent.updateMaxOfParents();
                parent.updateHeight();
                parent._rebalance();
                return this;
            }
        }
    };
    return Node;
}());
exports.Node = Node;
var IntervalTree = /** @class */ (function () {
    function IntervalTree() {
        this.count = 0;
    }
    IntervalTree.prototype.insert = function (record) {
        if (record.low > record.high) {
            throw new Error('`low` value must be lower or equal to `high` value');
        }
        if (this.root === undefined) {
            // Base case: Tree is empty, new node becomes root
            this.root = new Node(this, record);
            this.count++;
            return true;
        }
        else {
            // Otherwise, check if node already exists with the same key
            var node = this.root.searchExisting(record.low);
            if (node !== undefined) {
                // Check the records in this node if there already is the one with same low, high, data
                for (var i = 0; i < node.records.length; i++) {
                    if (isSame(node.records[i], record)) {
                        // This record is same as the one we're trying to insert; return false to indicate
                        // nothing has been inserted
                        return false;
                    }
                }
                // Add the record to the node
                node.records.push(record);
                // Update max of the node and its parents if necessary
                if (record.high > node.max) {
                    node.max = record.high;
                    if (node.parent) {
                        node.parent.updateMaxOfParents();
                    }
                }
                this.count++;
                return true;
            }
            else {
                // Node with this key doesn't already exist. Call insert function on root's node
                this.root.insert(record);
                this.count++;
                return true;
            }
        }
    };
    IntervalTree.prototype.search = function (low, high) {
        if (this.root === undefined) {
            // Tree is empty; return empty array
            return [];
        }
        else {
            return this.root.search(low, high);
        }
    };
    IntervalTree.prototype.remove = function (record) {
        if (this.root === undefined) {
            // Tree is empty; nothing to remove
            return false;
        }
        else {
            var node = this.root.searchExisting(record.low);
            if (node === undefined) {
                return false;
            }
            else if (node.records.length > 1) {
                var removedRecord = void 0;
                // Node with this key has 2 or more records. Find the one we need and remove it
                for (var i = 0; i < node.records.length; i++) {
                    if (isSame(node.records[i], record)) {
                        removedRecord = node.records[i];
                        node.records.splice(i, 1);
                        break;
                    }
                }
                if (removedRecord) {
                    removedRecord = undefined;
                    // Update max of that node and its parents if necessary
                    if (record.high === node.max) {
                        var nodeHigh = node.getNodeHigh();
                        if (node.left !== undefined && node.right !== undefined) {
                            node.max = Math.max(Math.max(node.left.max, node.right.max), nodeHigh);
                        }
                        else if (node.left !== undefined && node.right === undefined) {
                            node.max = Math.max(node.left.max, nodeHigh);
                        }
                        else if (node.left === undefined && node.right !== undefined) {
                            node.max = Math.max(node.right.max, nodeHigh);
                        }
                        else {
                            node.max = nodeHigh;
                        }
                        if (node.parent) {
                            node.parent.updateMaxOfParents();
                        }
                    }
                    this.count--;
                    return true;
                }
                else {
                    return false;
                }
            }
            else if (node.records.length === 1) {
                // Node with this key has only 1 record. Check if the remaining record in this node is
                // actually the one we want to remove
                if (isSame(node.records[0], record)) {
                    // The remaining record is the one we want to remove. Remove the whole node from the tree
                    if (this.root.key === node.key) {
                        // We're removing the root element. Create a dummy node that will temporarily take
                        // root's parent role
                        var rootParent = new Node(this, { low: record.low, high: record.low });
                        rootParent.left = this.root;
                        this.root.parent = rootParent;
                        var removedNode = this.root.remove(node);
                        this.root = rootParent.left;
                        if (this.root !== undefined) {
                            this.root.parent = undefined;
                        }
                        if (removedNode) {
                            removedNode = undefined;
                            this.count--;
                            return true;
                        }
                        else {
                            return false;
                        }
                    }
                    else {
                        var removedNode = this.root.remove(node);
                        if (removedNode) {
                            removedNode = undefined;
                            this.count--;
                            return true;
                        }
                        else {
                            return false;
                        }
                    }
                }
                else {
                    // The remaining record is not the one we want to remove
                    return false;
                }
            }
            else {
                // No records at all in this node?! Shouldn't happen
                return false;
            }
        }
    };
    IntervalTree.prototype.inOrder = function () {
        return new InOrder(this.root);
    };
    IntervalTree.prototype.preOrder = function () {
        return new PreOrder(this.root);
    };
    return IntervalTree;
}());
exports.IntervalTree = IntervalTree;
var DataIntervalTree = /** @class */ (function () {
    function DataIntervalTree() {
        this.tree = new IntervalTree();
    }
    DataIntervalTree.prototype.insert = function (low, high, data) {
        return this.tree.insert({ low: low, high: high, data: data });
    };
    DataIntervalTree.prototype.remove = function (low, high, data) {
        return this.tree.remove({ low: low, high: high, data: data });
    };
    DataIntervalTree.prototype.search = function (low, high) {
        return this.tree.search(low, high).map(function (v) { return v.data; });
    };
    DataIntervalTree.prototype.inOrder = function () {
        return this.tree.inOrder();
    };
    DataIntervalTree.prototype.preOrder = function () {
        return this.tree.preOrder();
    };
    Object.defineProperty(DataIntervalTree.prototype, "count", {
        get: function () {
            return this.tree.count;
        },
        enumerable: true,
        configurable: true
    });
    return DataIntervalTree;
}());
exports.default = DataIntervalTree;
var InOrder = /** @class */ (function () {
    function InOrder(startNode) {
        this.stack = [];
        if (startNode !== undefined) {
            this.push(startNode);
        }
    }
    InOrder.prototype.next = function () {
        // Will only happen if stack is empty and pop is called
        if (this.currentNode === undefined) {
            return {
                done: true,
                value: undefined,
            };
        }
        // Process this node
        if (this.i < this.currentNode.records.length) {
            return {
                done: false,
                value: this.currentNode.records[this.i++],
            };
        }
        if (this.currentNode.right !== undefined) {
            this.push(this.currentNode.right);
        }
        else {
            // Might pop the last and set this.currentNode = undefined
            this.pop();
        }
        return this.next();
    };
    InOrder.prototype.push = function (node) {
        this.currentNode = node;
        this.i = 0;
        while (this.currentNode.left !== undefined) {
            this.stack.push(this.currentNode);
            this.currentNode = this.currentNode.left;
        }
    };
    InOrder.prototype.pop = function () {
        this.currentNode = this.stack.pop();
        this.i = 0;
    };
    return InOrder;
}());
exports.InOrder = InOrder;
if (typeof Symbol === 'function') {
    InOrder.prototype[Symbol.iterator] = function () { return this; };
}
var PreOrder = /** @class */ (function () {
    function PreOrder(startNode) {
        this.stack = [];
        this.i = 0;
        this.currentNode = startNode;
    }
    PreOrder.prototype.next = function () {
        // Will only happen if stack is empty and pop is called,
        // which only happens if there is no right node (i.e we are done)
        if (this.currentNode === undefined) {
            return {
                done: true,
                value: undefined,
            };
        }
        // Process this node
        if (this.i < this.currentNode.records.length) {
            return {
                done: false,
                value: this.currentNode.records[this.i++],
            };
        }
        if (this.currentNode.right !== undefined) {
            this.push(this.currentNode.right);
        }
        if (this.currentNode.left !== undefined) {
            this.push(this.currentNode.left);
        }
        this.pop();
        return this.next();
    };
    PreOrder.prototype.push = function (node) {
        this.stack.push(node);
    };
    PreOrder.prototype.pop = function () {
        this.currentNode = this.stack.pop();
        this.i = 0;
    };
    return PreOrder;
}());
exports.PreOrder = PreOrder;
if (typeof Symbol === 'function') {
    PreOrder.prototype[Symbol.iterator] = function () { return this; };
}
//# sourceMappingURL=index.js.map

/***/ }),
/* 54 */
/***/ (function(module, exports) {

//

module.exports = function shallowEqual(objA, objB, compare, compareContext) {
  var ret = compare ? compare.call(compareContext, objA, objB) : void 0;

  if (ret !== void 0) {
    return !!ret;
  }

  if (objA === objB) {
    return true;
  }

  if (typeof objA !== "object" || !objA || typeof objB !== "object" || !objB) {
    return false;
  }

  var keysA = Object.keys(objA);
  var keysB = Object.keys(objB);

  if (keysA.length !== keysB.length) {
    return false;
  }

  var bHasOwnProperty = Object.prototype.hasOwnProperty.bind(objB);

  // Test for A's keys different from B.
  for (var idx = 0; idx < keysA.length; idx++) {
    var key = keysA[idx];

    if (!bHasOwnProperty(key)) {
      return false;
    }

    var valueA = objA[key];
    var valueB = objB[key];

    ret = compare ? compare.call(compareContext, valueA, valueB, key) : void 0;

    if (ret === false || (ret === void 0 && valueA !== valueB)) {
      return false;
    }
  }

  return true;
};


/***/ }),
/* 55 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.init = init;
exports.inspect = inspect;
exports.fetchBinary = fetchBinary;
exports.receiveBinary = receiveBinary;
exports.receiveTrace = receiveTrace;
exports.receiveCall = receiveCall;
exports.error = error;
const INIT_WEB3 = exports.INIT_WEB3 = "INIT_WEB3";
function init(provider) {
  return {
    type: INIT_WEB3,
    provider
  };
}

const INSPECT = exports.INSPECT = "INSPECT_TRANSACTION";
function inspect(txHash) {
  return {
    type: INSPECT,
    txHash
  };
}

const FETCH_BINARY = exports.FETCH_BINARY = "FETCH_BINARY";
function fetchBinary(address, block) {
  return {
    type: FETCH_BINARY,
    address,
    block //optional
  };
}

const RECEIVE_BINARY = exports.RECEIVE_BINARY = "RECEIVE_BINARY";
function receiveBinary(address, binary) {
  return {
    type: RECEIVE_BINARY,
    address,
    binary
  };
}

const RECEIVE_TRACE = exports.RECEIVE_TRACE = "RECEIVE_TRACE";
function receiveTrace(trace) {
  return {
    type: RECEIVE_TRACE,
    trace
  };
}

const RECEIVE_CALL = exports.RECEIVE_CALL = "RECEIVE_CALL";
function receiveCall({
  address,
  binary,
  data,
  storageAddress,
  status,
  sender,
  value,
  gasprice,
  block
}) {
  return {
    type: RECEIVE_CALL,
    address,
    binary,
    data,
    storageAddress,
    status, //only used for creation calls at present!
    sender,
    value,
    gasprice,
    block
  };
}

const ERROR_WEB3 = exports.ERROR_WEB3 = "ERROR_WEB3";
function error(error) {
  return {
    type: ERROR_WEB3,
    error
  };
}

/***/ }),
/* 56 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _asyncToGenerator2 = __webpack_require__(18);

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

var _debug = __webpack_require__(0);

var _debug2 = _interopRequireDefault(_debug);

var _web = __webpack_require__(31);

var _web2 = _interopRequireDefault(_web);

var _util = __webpack_require__(57);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const debug = (0, _debug2.default)("debugger:web3:adapter");

class Web3Adapter {
  constructor(provider) {
    this.web3 = new _web2.default(provider);
  }

  getTrace(txHash) {
    var _this = this;

    return (0, _asyncToGenerator3.default)(function* () {
      let result = yield (0, _util.promisify)(_this.web3.currentProvider.send)(
      //send *only* uses callbacks, so we use promsifiy to make things more
      //readable
      {
        jsonrpc: "2.0",
        method: "debug_traceTransaction",
        params: [txHash, {}],
        id: new Date().getTime()
      });
      if (result.error) {
        throw new Error(result.error.message);
      } else {
        return result.result.structLogs;
      }
    })();
  }

  getTransaction(txHash) {
    var _this2 = this;

    return (0, _asyncToGenerator3.default)(function* () {
      return yield _this2.web3.eth.getTransaction(txHash);
    })();
  }

  getReceipt(txHash) {
    var _this3 = this;

    return (0, _asyncToGenerator3.default)(function* () {
      return yield _this3.web3.eth.getTransactionReceipt(txHash);
    })();
  }

  getBlock(blockNumberOrHash) {
    var _this4 = this;

    return (0, _asyncToGenerator3.default)(function* () {
      return yield _this4.web3.eth.getBlock(blockNumberOrHash);
    })();
  }

  /**
   * getDeployedCode - get the deployed code for an address from the client
   * NOTE: the block argument is optional
   * @param  {String} address
   * @return {String}         deployedBinary
   */
  getDeployedCode(address, block) {
    var _this5 = this;

    return (0, _asyncToGenerator3.default)(function* () {
      debug("getting deployed code for %s", address);
      let code = yield _this5.web3.eth.getCode(address, block);
      return code === "0x0" ? "0x" : code;
    })();
  }
}
exports.default = Web3Adapter;

/***/ }),
/* 57 */
/***/ (function(module, exports) {

module.exports = require("util");

/***/ }),
/* 58 */
/***/ (function(module, exports) {

module.exports = require("lodash.sum");

/***/ }),
/* 59 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _keys = __webpack_require__(16);

var _keys2 = _interopRequireDefault(_keys);

exports.saga = saga;
exports.processTransaction = processTransaction;
exports.unload = unload;

var _debug = __webpack_require__(0);

var _debug2 = _interopRequireDefault(_debug);

var _effects = __webpack_require__(5);

var _helpers = __webpack_require__(1);

var _sagas = __webpack_require__(60);

var ast = _interopRequireWildcard(_sagas);

var _sagas2 = __webpack_require__(33);

var controller = _interopRequireWildcard(_sagas2);

var _sagas3 = __webpack_require__(34);

var solidity = _interopRequireWildcard(_sagas3);

var _sagas4 = __webpack_require__(23);

var evm = _interopRequireWildcard(_sagas4);

var _sagas5 = __webpack_require__(13);

var trace = _interopRequireWildcard(_sagas5);

var _sagas6 = __webpack_require__(17);

var data = _interopRequireWildcard(_sagas6);

var _sagas7 = __webpack_require__(30);

var web3 = _interopRequireWildcard(_sagas7);

var _actions = __webpack_require__(14);

var actions = _interopRequireWildcard(_actions);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const debug = (0, _debug2.default)("debugger:session:sagas");

const LOAD_SAGAS = {
  [actions.LOAD_TRANSACTION]: load
  //will also add reconstruct action/saga once it exists
};

function* listenerSaga() {
  while (true) {
    let action = yield (0, _effects.take)((0, _keys2.default)(LOAD_SAGAS));
    let saga = LOAD_SAGAS[action.type];

    yield (0, _effects.put)(actions.wait());
    yield (0, _effects.race)({
      exec: (0, _effects.call)(saga, action), //not all will use this
      interrupt: (0, _effects.take)(actions.INTERRUPT)
    });
    yield (0, _effects.put)(actions.ready());
  }
}

function* saga() {
  debug("starting listeners");
  yield* forkListeners();

  // receiving & saving contracts into state
  debug("waiting for contract information");
  let { contexts, sources } = yield (0, _effects.take)(actions.RECORD_CONTRACTS);

  debug("recording contract binaries");
  yield* recordContexts(...contexts);

  debug("recording contract sources");
  yield* recordSources(...sources);

  debug("normalizing contexts");
  yield* evm.normalizeContexts();

  debug("waiting for start");
  // wait for start signal
  let { txHash, provider } = yield (0, _effects.take)(actions.START);
  debug("starting");

  debug("visiting ASTs");
  // visit asts
  yield* ast.visitAll();

  //save allocation table
  debug("saving allocation table");
  yield* data.recordAllocations();

  //initialize web3 adapter
  yield* web3.init(provider);

  //process transaction (if there is one)
  //(note: this part may also set the error state)
  if (txHash !== undefined) {
    yield* processTransaction(txHash);
  }

  debug("readying");
  // signal that commands can begin
  yield* ready();
}

function* processTransaction(txHash) {
  // process transaction
  debug("fetching transaction info");
  let err = yield* fetchTx(txHash);
  if (err) {
    debug("error %o", err);
    yield* error(err);
  }
}

exports.default = (0, _helpers.prefixName)("session", saga);


function* forkListeners() {
  yield (0, _effects.fork)(listenerSaga); //session listener; this one is separate, sorry
  //(I didn't want to mess w/ the existing structure of defaults)
  return yield (0, _effects.all)([controller, data, evm, solidity, trace, web3].map(app => (0, _effects.fork)(app.saga)
  //ast no longer has a listener
  ));
}

function* fetchTx(txHash) {
  let result = yield* web3.inspectTransaction(txHash);
  debug("result %o", result);

  if (result.error) {
    return result.error;
  }

  //get addresses created/called during transaction
  debug("processing trace for addresses");
  let addresses = yield* trace.processTrace(result.trace);
  //add in the address of the call itself (if a call)
  if (result.address && !addresses.includes(result.address)) {
    addresses.push(result.address);
  }
  //if a create, only add in address if it was successful
  if (result.binary && result.status && !addresses.includes(result.storageAddress)) {
    addresses.push(result.storageAddress);
  }

  let blockNumber = result.block.number.toString(); //a BN is not accepted
  debug("obtaining binaries");
  let binaries = yield* web3.obtainBinaries(addresses, blockNumber);

  debug("recording instances");
  yield (0, _effects.all)(addresses.map((address, i) => (0, _effects.call)(recordInstance, address, binaries[i])));

  debug("sending initial call");
  yield* evm.begin(result);
}

function* recordContexts(...contexts) {
  for (let context of contexts) {
    yield* evm.addContext(context);
  }
}

function* recordSources(...sources) {
  for (let sourceData of sources) {
    if (sourceData !== undefined && sourceData !== null) {
      yield* solidity.addSource(sourceData.source, sourceData.sourcePath, sourceData.ast, sourceData.compiler);
    }
  }
}

function* recordInstance(address, binary) {
  yield* evm.addInstance(address, binary);
}

function* ready() {
  yield (0, _effects.put)(actions.ready());
}

function* error(err) {
  yield (0, _effects.put)(actions.error(err));
}

function* unload() {
  debug("unloading");
  yield* data.reset();
  yield* solidity.reset();
  yield* evm.unload();
  yield* trace.unload();
  yield (0, _effects.put)(actions.unloadTransaction());
}

//note that load takes an action as its argument, which is why it's separate
//from processTransaction
function* load({ txHash }) {
  yield* processTransaction(txHash);
}

/***/ }),
/* 60 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _entries = __webpack_require__(6);

var _entries2 = _interopRequireDefault(_entries);

exports.visitAll = visitAll;

var _debug = __webpack_require__(0);

var _debug2 = _interopRequireDefault(_debug);

var _effects = __webpack_require__(5);

var _sagas = __webpack_require__(17);

var data = _interopRequireWildcard(_sagas);

var _selectors = __webpack_require__(36);

var _selectors2 = _interopRequireDefault(_selectors);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const debug = (0, _debug2.default)("debugger:ast:sagas");

function* walk(sourceId, node, pointer = "", parentId = null) {
  debug("walking %o %o", pointer, node);

  yield* handleEnter(sourceId, node, pointer, parentId);

  if (node instanceof Array) {
    for (let [i, child] of node.entries()) {
      yield (0, _effects.call)(walk, sourceId, child, `${pointer}/${i}`, parentId);
    }
  } else if (node instanceof Object) {
    for (let [key, child] of (0, _entries2.default)(node)) {
      yield (0, _effects.call)(walk, sourceId, child, `${pointer}/${key}`, node.id);
    }
  }

  yield* handleExit(sourceId, node, pointer);
}

function* handleEnter(sourceId, node, pointer, parentId) {
  if (!(node instanceof Object)) {
    return;
  }

  debug("entering %s", pointer);

  if (node.id !== undefined) {
    debug("%s recording scope %s", pointer, node.id);
    yield* data.scope(node.id, pointer, parentId, sourceId);
  }

  switch (node.nodeType) {
    case "VariableDeclaration":
      debug("%s recording variable %o", pointer, node);
      yield* data.declare(node);
      break;
    case "ContractDefinition":
    case "StructDefinition":
    case "EnumDefinition":
      yield* data.defineType(node);
      break;
  }
}

function* handleExit(sourceId, node, pointer) {
  debug("exiting %s", pointer);

  // no-op right now
}

function* visitAll() {
  let sources = yield (0, _effects.select)(_selectors2.default.views.sources);

  yield (0, _effects.all)((0, _entries2.default)(sources).filter(([_, source]) => source.ast).map(([id, { ast }]) => (0, _effects.call)(walk, id, ast)));

  debug("done visiting");
}

/***/ }),
/* 61 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _debug = __webpack_require__(0);

var _debug2 = _interopRequireDefault(_debug);

var _redux = __webpack_require__(7);

var _reducers = __webpack_require__(62);

var _reducers2 = _interopRequireDefault(_reducers);

var _reducers3 = __webpack_require__(63);

var _reducers4 = _interopRequireDefault(_reducers3);

var _reducers5 = __webpack_require__(64);

var _reducers6 = _interopRequireDefault(_reducers5);

var _reducers7 = __webpack_require__(65);

var _reducers8 = _interopRequireDefault(_reducers7);

var _reducers9 = __webpack_require__(66);

var _reducers10 = _interopRequireDefault(_reducers9);

var _actions = __webpack_require__(14);

var actions = _interopRequireWildcard(_actions);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const debug = (0, _debug2.default)("debugger:session:reducers");

function ready(state = false, action) {
  switch (action.type) {
    case actions.READY:
      debug("readying");
      return true;

    case actions.WAIT:
      return false;

    default:
      return state;
  }
}

function projectInfoComputed(state = false, action) {
  switch (action.type) {
    case actions.PROJECT_INFO_COMPUTED:
      return true;
    default:
      return state;
  }
}

function lastLoadingError(state = null, action) {
  switch (action.type) {
    case actions.ERROR:
      debug("error: %o", action.error);
      return action.error;

    case actions.WAIT:
      return null;

    default:
      return state;
  }
}

function transaction(state = {}, action) {
  switch (action.type) {
    case actions.SAVE_TRANSACTION:
      return action.transaction;
    case actions.UNLOAD_TRANSACTION:
      return {};
    default:
      return state;
  }
}

function receipt(state = {}, action) {
  switch (action.type) {
    case actions.SAVE_RECEIPT:
      return action.receipt;
    case actions.UNLOAD_TRANSACTION:
      return {};
    default:
      return state;
  }
}

function block(state = {}, action) {
  switch (action.type) {
    case actions.SAVE_BLOCK:
      return action.block;
    case actions.UNLOAD_TRANSACTION:
      return {};
    default:
      return state;
  }
}

const session = (0, _redux.combineReducers)({
  ready,
  lastLoadingError,
  projectInfoComputed,
  transaction,
  receipt,
  block
});

const reduceState = (0, _redux.combineReducers)({
  session,
  data: _reducers2.default,
  evm: _reducers4.default,
  solidity: _reducers6.default,
  trace: _reducers8.default,
  controller: _reducers10.default
});

exports.default = reduceState;

/***/ }),
/* 62 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _set = __webpack_require__(28);

var _set2 = _interopRequireDefault(_set);

var _values = __webpack_require__(19);

var _values2 = _interopRequireDefault(_values);

var _assign = __webpack_require__(8);

var _assign2 = _interopRequireDefault(_assign);

var _extends2 = __webpack_require__(2);

var _extends3 = _interopRequireDefault(_extends2);

var _debug = __webpack_require__(0);

var _debug2 = _interopRequireDefault(_debug);

var _redux = __webpack_require__(7);

var _actions = __webpack_require__(27);

var actions = _interopRequireWildcard(_actions);

var _truffleDecoder = __webpack_require__(32);

var _helpers = __webpack_require__(1);

var _truffleDecodeUtils = __webpack_require__(4);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const debug = (0, _debug2.default)("debugger:data:reducers");

const DEFAULT_SCOPES = {
  byId: {}
};

function scopes(state = DEFAULT_SCOPES, action) {
  var scope;
  var variables;

  switch (action.type) {
    case actions.SCOPE:
      scope = state.byId[action.id] || {};

      return {
        byId: (0, _extends3.default)({}, state.byId, {

          [action.id]: (0, _extends3.default)({}, scope, {

            id: action.id,
            sourceId: action.sourceId,
            parentId: action.parentId,
            pointer: action.pointer
          })
        })
      };

    case actions.DECLARE:
      scope = state.byId[action.node.scope] || {};
      variables = scope.variables || [];

      return {
        byId: (0, _extends3.default)({}, state.byId, {

          [action.node.scope]: (0, _extends3.default)({}, scope, {

            variables: [...variables, { name: action.node.name, id: action.node.id }]
          })
        })
      };

    default:
      return state;
  }
}

//a note on the following reducer: solidity assigns a unique AST ID to every
//AST node among all the files being compiled together.  thus, it is, for now,
//safe to identify user-defined types solely by their AST ID.  In the future,
//once we eventually support having some files compiled separately from others,
//this will become a bug you'll have to fix, and you'll have to fix it in the
//decoder, too.  Sorry, future me! (or whoever's stuck doing this)

function userDefinedTypes(state = [], action) {
  switch (action.type) {
    case actions.DEFINE_TYPE:
      return [...state, action.node.id];
    default:
      return state;
  }
}

const DEFAULT_ALLOCATIONS = {
  storage: {},
  memory: {},
  calldata: {}
};

function allocations(state = DEFAULT_ALLOCATIONS, action) {
  if (action.type === actions.ALLOCATE) {
    return {
      storage: action.storage,
      memory: action.memory,
      calldata: action.calldata
    };
  } else {
    return state;
  }
}

const info = (0, _redux.combineReducers)({
  scopes,
  userDefinedTypes,
  allocations
});

const GLOBAL_ASSIGNMENTS = [[{ builtin: "msg" }, { special: "msg" }], [{ builtin: "tx" }, { special: "tx" }], [{ builtin: "block" }, { special: "block" }], [{ builtin: "this" }, { special: "this" }], [{ builtin: "now" }, { special: "timestamp" }] //we don't have an alias "now"
].map(([idObj, ref]) => (0, _helpers.makeAssignment)(idObj, ref));

const DEFAULT_ASSIGNMENTS = {
  byId: (0, _assign2.default)({}, //we start out with all globals assigned
  ...GLOBAL_ASSIGNMENTS.map(assignment => ({ [assignment.id]: assignment }))),
  byAstId: {}, //no regular variables assigned at start
  byBuiltin: (0, _assign2.default)({}, //again, all globals start assigned
  ...GLOBAL_ASSIGNMENTS.map(assignment => ({
    [assignment.builtin]: [assignment.id] //yes, that's a 1-element array
  })))
};

function assignments(state = DEFAULT_ASSIGNMENTS, action) {
  switch (action.type) {
    case actions.ASSIGN:
    case actions.MAP_PATH_AND_ASSIGN:
      debug("action.type %O", action.type);
      debug("action.assignments %O", action.assignments);
      return (0, _values2.default)(action.assignments).reduce((acc, assignment) => {
        let { id, astId } = assignment;
        //we assume for now that only ordinary variables will be assigned this
        //way, and not globals; globals are handled in DEFAULT_ASSIGNMENTS
        return (0, _extends3.default)({}, acc, {
          byId: (0, _extends3.default)({}, acc.byId, {
            [id]: assignment
          }),
          byAstId: (0, _extends3.default)({}, acc.byAstId, {
            [astId]: [...new _set2.default([...(acc.byAstId[astId] || []), id])]
            //we use a set for uniqueness
          })
        });
      }, state);

    case actions.RESET:
      return DEFAULT_ASSIGNMENTS;

    default:
      return state;
  }
}

const DEFAULT_PATHS = {
  byAddress: {}
};

//WARNING: do *not* rely on mappedPaths to keep track of paths that do not
//involve mapping keys!  Yes, many will get mapped, but there is no guarantee.
//Only when mapping keys are involved does it necessarily work reliably --
//which is fine, as that's all we need it for.
function mappedPaths(state = DEFAULT_PATHS, action) {
  switch (action.type) {
    case actions.MAP_PATH_AND_ASSIGN:
      let { address, slot, typeIdentifier, parentType } = action;
      //how this case works: first, we find the spot in our table (based on
      //address, type identifier, and slot address) where the new entry should
      //be added; if needed we set up all the objects needed along the way.  If
      //there's already something there, we do nothing.  If there's nothing
      //there, we record our given slot in that spot in that table -- however,
      //we alter it in one key way.  Before entry, we check if the slot's
      //*parent* has a spot in the table, based on address (same for both child
      //and parent), parentType, and the parent's slot address (which can be
      //found as the slotAddress of the slot's path object, if it exists -- if
      //it doesn't then we conclude that no the parent does not have a spot in
      //the table).  If the parent has a slot in the table already, then we
      //alter the child slot by replacing its path with the parent slot.  This
      //will keep the slotAddress the same, but since the versions kept in the
      //table here are supposed to preserve path information, we'll be
      //replacing a fairly bare-bones Slot object with one with a full path.

      //we do NOT want to distinguish between types with and without "_ptr" on
      //the end here!
      debug("typeIdentifier %s", typeIdentifier);
      typeIdentifier = _truffleDecodeUtils.Definition.restorePtr(typeIdentifier);
      parentType = _truffleDecodeUtils.Definition.restorePtr(parentType);

      debug("slot %o", slot);
      let hexSlotAddress = _truffleDecodeUtils.Conversion.toHexString((0, _truffleDecoder.slotAddress)(slot), _truffleDecodeUtils.EVM.WORD_SIZE);
      let parentAddress = slot.path ? _truffleDecodeUtils.Conversion.toHexString((0, _truffleDecoder.slotAddress)(slot.path), _truffleDecodeUtils.EVM.WORD_SIZE) : undefined;

      //this is going to be messy and procedural, sorry.  but let's start with
      //the easy stuff: create the new address if needed, clone if not
      let newState = (0, _extends3.default)({}, state, {
        byAddress: (0, _extends3.default)({}, state.byAddress, {
          [address]: {
            byType: (0, _extends3.default)({}, (state.byAddress[address] || { byType: {} }).byType)
          }
        })
      });

      //now, let's add in the new type, if needed
      newState.byAddress[address].byType = (0, _extends3.default)({}, newState.byAddress[address].byType, {
        [typeIdentifier]: {
          bySlotAddress: (0, _extends3.default)({}, (newState.byAddress[address].byType[typeIdentifier] || {
            bySlotAddress: {}
          }).bySlotAddress)
        }
      });

      let oldSlot = newState.byAddress[address].byType[typeIdentifier].bySlotAddress[hexSlotAddress];
      //yes, this looks strange, but we haven't changed it yet except to
      //clone or create empty (and we don't want undefined!)
      //now: is there something already there or no?  if no, we must add
      if (oldSlot === undefined) {
        let newSlot;
        debug("parentAddress %o", parentAddress);
        if (parentAddress !== undefined && newState.byAddress[address].byType[parentType] && newState.byAddress[address].byType[parentType].bySlotAddress[parentAddress]) {
          //if the parent is already present, use that instead of the given
          //parent!
          newSlot = (0, _extends3.default)({}, slot, {
            path: newState.byAddress[address].byType[parentType].bySlotAddress[parentAddress]
          });
        } else {
          newSlot = slot;
        }
        newState.byAddress[address].byType[typeIdentifier].bySlotAddress[hexSlotAddress] = newSlot;
      }
      //if there's already something there, we don't need to do anything

      return newState;

    case actions.RESET:
      return DEFAULT_PATHS;

    default:
      return state;
  }
}

const proc = (0, _redux.combineReducers)({
  assignments,
  mappedPaths
});

const reducer = (0, _redux.combineReducers)({
  info,
  proc
});

exports.default = reducer;

/***/ }),
/* 63 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends2 = __webpack_require__(2);

var _extends3 = _interopRequireDefault(_extends2);

var _debug = __webpack_require__(0);

var _debug2 = _interopRequireDefault(_debug);

var _redux = __webpack_require__(7);

var _actions = __webpack_require__(29);

var actions = _interopRequireWildcard(_actions);

var _helpers = __webpack_require__(1);

var _truffleDecodeUtils = __webpack_require__(4);

var DecodeUtils = _interopRequireWildcard(_truffleDecodeUtils);

var _bn = __webpack_require__(15);

var _bn2 = _interopRequireDefault(_bn);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const debug = (0, _debug2.default)("debugger:evm:reducers");

const DEFAULT_CONTEXTS = {
  byContext: {}
};

function contexts(state = DEFAULT_CONTEXTS, action) {
  switch (action.type) {
    /*
     * Adding a new context
     */
    case actions.ADD_CONTEXT:
      const {
        contractName,
        binary,
        sourceMap,
        compiler,
        abi,
        contractId,
        contractKind,
        isConstructor
      } = action;
      debug("action %O", action);
      //NOTE: we take hash as *string*, not as bytes, because the binary may
      //contain link references!
      const context = (0, _helpers.keccak256)({ type: "string", value: binary });
      let primarySource;
      if (sourceMap !== undefined) {
        primarySource = (0, _helpers.extractPrimarySource)(sourceMap);
      }
      //otherwise leave it undefined

      return (0, _extends3.default)({}, state, {
        byContext: (0, _extends3.default)({}, state.byContext, {
          [context]: {
            contractName,
            context,
            binary,
            sourceMap,
            primarySource,
            compiler,
            abi,
            contractId,
            contractKind,
            isConstructor
          }
        })
      });

    case actions.NORMALIZE_CONTEXTS:
      return {
        byContext: DecodeUtils.Contexts.normalizeContexts(state.byContext)
      };

    /*
     * Default case
     */
    default:
      return state;
  }
}

const info = (0, _redux.combineReducers)({
  contexts
});

const DEFAULT_TX = {
  gasprice: new _bn2.default(0),
  origin: DecodeUtils.EVM.ZERO_ADDRESS
};

function tx(state = DEFAULT_TX, action) {
  switch (action.type) {
    case actions.SAVE_GLOBALS:
      let { gasprice, origin } = action;
      return { gasprice, origin };
    case actions.UNLOAD_TRANSACTION:
      return DEFAULT_TX;
    default:
      return state;
  }
}

const DEFAULT_BLOCK = {
  coinbase: DecodeUtils.EVM.ZERO_ADDRESS,
  difficulty: new _bn2.default(0),
  gaslimit: new _bn2.default(0),
  number: new _bn2.default(0),
  timestamp: new _bn2.default(0)
};

function block(state = DEFAULT_BLOCK, action) {
  switch (action.type) {
    case actions.SAVE_GLOBALS:
      return action.block;
    case actions.UNLOAD_TRANSACTION:
      return DEFAULT_BLOCK;
    default:
      return state;
  }
}

const globals = (0, _redux.combineReducers)({
  tx,
  block
});

function status(state = null, action) {
  switch (action.type) {
    case actions.SAVE_STATUS:
      return action.status;
    case actions.UNLOAD_TRANSACTION:
      return null;
    default:
      return state;
  }
}

function initialCall(state = null, action) {
  switch (action.type) {
    case actions.CALL:
    case actions.CREATE:
      //we only want to save the initial call, so return
      //the current state if it's not null
      if (state !== null) {
        return state;
      } else {
        //we'll just store the action itself in the state
        return action;
      }
    case actions.UNLOAD_TRANSACTION:
      return null;
    default:
      return state;
  }
}

const transaction = (0, _redux.combineReducers)({
  globals,
  status,
  initialCall
});

function callstack(state = [], action) {
  switch (action.type) {
    case actions.CALL:
      {
        const { address, data, storageAddress, sender, value } = action;
        return state.concat([{ address, data, storageAddress, sender, value }]);
      }

    case actions.CREATE:
      {
        const { binary, storageAddress, sender, value } = action;
        return state.concat([{ binary, data: "0x", storageAddress, sender, value }]
        //the empty data field is to make msg.data and msg.sig come out right
        );
      }

    case actions.RETURN_CALL:
    case actions.RETURN_CREATE:
    case actions.FAIL:
      //pop the stack... unless (HACK) that would leave it empty (this will
      //only happen at the end when we want to keep the last one around)
      return state.length > 1 ? state.slice(0, -1) : state;

    case actions.RESET:
    case actions.UNLOAD_TRANSACTION:
      return [];

    default:
      return state;
  }
}

const DEFAULT_CODEX = [{
  accounts: {}
  //will be more here in the future!
}];

function codex(state = DEFAULT_CODEX, action) {
  let newState, topCodex;

  const updateFrameStorage = (frame, address, slot, value) => (0, _extends3.default)({}, frame, {
    accounts: (0, _extends3.default)({}, frame.accounts, {
      [address]: (0, _extends3.default)({}, frame.accounts[address], {
        storage: (0, _extends3.default)({}, frame.accounts[address].storage, {
          [slot]: value
        })
      })
    })
  });

  const updateFrameCode = (frame, address, code, context) => {
    let existingPage = frame.accounts[address] || { storage: {} };
    return (0, _extends3.default)({}, frame, {
      accounts: (0, _extends3.default)({}, frame.accounts, {
        [address]: (0, _extends3.default)({}, existingPage, {
          code: code,
          context: context
        })
      })
    });
  };

  //later: will add "force" parameter
  const safePop = array => array.length > 2 ? array.slice(0, -1) : array;

  //later: will add "force" parameter
  const safeSave = array => array.length > 2 ? array.slice(0, -2).concat([array[array.length - 1]]) : array;

  switch (action.type) {
    case actions.CALL:
      debug("call action");
      debug("codex: %O", state);
      //on a call, we can just make a new stackframe by cloning the top
      //stackframe; there should already be an account for the address we're
      //calling into, so we don't need to make one
      return [...state, state[state.length - 1]];

    case actions.CREATE:
      //on a create, make a new stackframe, then add a new pages to the
      //codex if necessary; don't add a zero page though (or pages that already
      //exist)

      //first, add a new stackframe by cloning the top one
      newState = [...state, state[state.length - 1]];
      topCodex = newState[newState.length - 1];
      //now, do we need to add a new address to this stackframe?
      if (topCodex.accounts[action.storageAddress] !== undefined || action.storageAddress === DecodeUtils.EVM.ZERO_ADDRESS) {
        //if we don't
        return newState;
      }
      //if we do
      newState[newState.length - 1] = (0, _extends3.default)({}, topCodex, {
        accounts: (0, _extends3.default)({}, topCodex.accounts, {
          [action.storageAddress]: {
            storage: {},
            code: "0x",
            context: null
            //there will be more here in the future!
          }
        })
      });
      return newState;

    case actions.STORE:
      {
        //on a store, the relevant page should already exist, so we can just
        //add or update the needed slot
        const { address, slot, value } = action;
        if (address === DecodeUtils.EVM.ZERO_ADDRESS) {
          //as always, we do not maintain a zero page
          return state;
        }
        newState = state.slice(); //clone the state
        topCodex = newState[newState.length - 1];
        newState[newState.length - 1] = updateFrameStorage(topCodex, address, slot, value);
        return newState;
      }

    case actions.LOAD:
      {
        //loads are a little more complicated -- usually we do nothing, but if
        //it's an external load (there was nothing already there), then we want
        //to update *every* stackframe
        const { address, slot, value } = action;
        if (address === DecodeUtils.EVM.ZERO_ADDRESS) {
          //as always, we do not maintain a zero page
          return state;
        }
        topCodex = state[state.length - 1];
        if (topCodex.accounts[address].storage[slot] !== undefined) {
          //if we already have a value in the *top* stackframe, update *no*
          //stackframes; don't update the top (no need, it's just a load, not a
          //store), don't update the rest (that would be wrong, you might be
          //loading a value that will get reverted later)
          return state;
        } else {
          //if we *don't* already have a value in the top stackframe, that means
          //we're loading a value from a previous transaction!  That's not a
          //value that will get reverted if this call fails, so update *every*
          //stackframe
          return state.map(frame => updateFrameStorage(frame, address, slot, value));
        }
      }

    case actions.RETURN_CALL:
      //we want to pop the top while making the new top a copy of the old top;
      //that is to say, we want to drop just the element *second* from the top
      //NOTE: we don't ever go down to 1 element!
      return safeSave(state);

    case actions.RETURN_CREATE:
      {
        //we're going to do the same things in this case as in the usual return
        //case, but first we need to record the code that was returned
        const { address, code, context } = action;
        newState = state.slice(); //clone the state
        //NOTE: since this is only for RETURN_CREATE, and not FAIL, we shouldn't
        //have to worry about accidentally getting a zero address here
        newState[newState.length - 1] = updateFrameCode(newState[newState.length - 1], address, code, context);
        debug("newState: %O", newState);
        return safeSave(newState);
      }

    case actions.FAIL:
      //pop the stack
      //NOTE: we don't ever go down to 1 element!
      return safePop(state);

    case actions.RESET:
      return [state[0]]; //leave the -1 frame on the stack

    case actions.UNLOAD_TRANSACTION:
      return DEFAULT_CODEX;

    case actions.ADD_INSTANCE:
      {
        //add the instance to every frame
        //(this is a little HACKy, but it *should* be fine)
        debug("adding instance");
        const { address, binary, context } = action;
        return state.map(frame => updateFrameCode(frame, address, binary, context));
      }

    default:
      return state;
  }
}

const proc = (0, _redux.combineReducers)({
  callstack,
  codex
});

const reducer = (0, _redux.combineReducers)({
  info,
  transaction,
  proc
});

exports.default = reducer;

/***/ }),
/* 64 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends2 = __webpack_require__(2);

var _extends3 = _interopRequireDefault(_extends2);

var _keys = __webpack_require__(16);

var _keys2 = _interopRequireDefault(_keys);

var _redux = __webpack_require__(7);

var _actions = __webpack_require__(35);

var actions = _interopRequireWildcard(_actions);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const DEFAULT_SOURCES = {
  byId: {}
};

function sources(state = DEFAULT_SOURCES, action) {
  switch (action.type) {
    /*
     * Adding a new source
     */
    case actions.ADD_SOURCE:
      let { ast, source, sourcePath, compiler } = action;

      let id = (0, _keys2.default)(state.byId).length;

      return {
        byId: (0, _extends3.default)({}, state.byId, {

          [id]: {
            id,
            ast,
            source,
            sourcePath,
            compiler
          }
        })
      };

    /*
     * Default case
     */
    default:
      return state;
  }
}

const info = (0, _redux.combineReducers)({
  sources
});

function functionDepthStack(state = [0], action) {
  switch (action.type) {
    case actions.JUMP:
      let newState = state.slice(); //clone the state
      const delta = spelunk(action.jumpDirection);
      let top = newState[newState.length - 1];
      newState[newState.length - 1] = top + delta;
      return newState;

    case actions.RESET:
      return [0];

    case actions.EXTERNAL_CALL:
      return [...state, state[state.length - 1] + 1];

    case actions.EXTERNAL_RETURN:
      //just pop the stack! unless, HACK, that would leave it empty
      return state.length > 1 ? state.slice(0, -1) : state;

    default:
      return state;
  }
}

function spelunk(jump) {
  if (jump === "i") {
    return 1;
  } else if (jump === "o") {
    return -1;
  } else {
    return 0;
  }
}

const proc = (0, _redux.combineReducers)({
  functionDepthStack
});

const reducer = (0, _redux.combineReducers)({
  info,
  proc
});

exports.default = reducer;

/***/ }),
/* 65 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _debug = __webpack_require__(0);

var _debug2 = _interopRequireDefault(_debug);

var _redux = __webpack_require__(7);

var _actions = __webpack_require__(12);

var actions = _interopRequireWildcard(_actions);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const debug = (0, _debug2.default)("debugger:trace:reducers");

function index(state = 0, action) {
  switch (action.type) {
    case actions.TOCK:
      return state + 1;

    case actions.RESET:
    case actions.UNLOAD_TRANSACTION:
      return 0;

    default:
      return state;
  }
}

function finished(state = false, action) {
  switch (action.type) {
    case actions.END_OF_TRACE:
      return true;

    case actions.RESET:
    case actions.UNLOAD_TRANSACTION:
      return false;

    default:
      return state;
  }
}

function steps(state = null, action) {
  switch (action.type) {
    case actions.SAVE_STEPS:
      return action.steps;
    case actions.UNLOAD_TRANSACTION:
      debug("unloading");
      return null;
    default:
      return state;
  }
}

const transaction = (0, _redux.combineReducers)({
  steps
});

const proc = (0, _redux.combineReducers)({
  index,
  finished
});

const reducer = (0, _redux.combineReducers)({
  transaction,
  proc
});

exports.default = reducer;

/***/ }),
/* 66 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _debug = __webpack_require__(0);

var _debug2 = _interopRequireDefault(_debug);

var _redux = __webpack_require__(7);

var _actions = __webpack_require__(20);

var actions = _interopRequireWildcard(_actions);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const debug = (0, _debug2.default)("debugger:controller:reducers");

function breakpoints(state = [], action) {
  switch (action.type) {
    case actions.ADD_BREAKPOINT:
      //check for any existing identical breakpoints to avoid redundancy
      if (state.filter(breakpoint => breakpoint.sourceId === action.breakpoint.sourceId && breakpoint.line === action.breakpoint.line && breakpoint.node === action.breakpoint.node //may be undefined
      ).length > 0) {
        //if it's already there, do nothing
        return state;
      } else {
        //otherwise add it
        return state.concat([action.breakpoint]);
      }
      break;

    case actions.REMOVE_BREAKPOINT:
      return state.filter(breakpoint => breakpoint.sourceId !== action.breakpoint.sourceId || breakpoint.line !== action.breakpoint.line || breakpoint.node !== action.breakpoint.node //may be undefined
      );
      break;

    case actions.REMOVE_ALL_BREAKPOINTS:
      return [];

    default:
      return state;
  }
}

function isStepping(state = false, action) {
  switch (action.type) {
    case actions.START_STEPPING:
      debug("got step start action");
      return true;
    case actions.DONE_STEPPING:
      debug("got step stop action");
      return false;
    default:
      return state;
  }
}

const reducer = (0, _redux.combineReducers)({
  breakpoints,
  isStepping
});

exports.default = reducer;

/***/ })
/******/ ]);
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGVidWdnZXIuanMiLCJzb3VyY2VzIjpbIndlYnBhY2svdW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbiIsIndlYnBhY2svYm9vdHN0cmFwIGI3MDYyYTgxNzNhZTExMjAwNDFmIiwiZXh0ZXJuYWwgXCJkZWJ1Z1wiIiwibGliL2hlbHBlcnMvaW5kZXguanMiLCJleHRlcm5hbCBcImJhYmVsLXJ1bnRpbWUvaGVscGVycy9leHRlbmRzXCIiLCJleHRlcm5hbCBcInJlc2VsZWN0LXRyZWVcIiIsImV4dGVybmFsIFwidHJ1ZmZsZS1kZWNvZGUtdXRpbHNcIiIsImV4dGVybmFsIFwicmVkdXgtc2FnYS9lZmZlY3RzXCIiLCJleHRlcm5hbCBcImJhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3QvZW50cmllc1wiIiwiZXh0ZXJuYWwgXCJyZWR1eFwiIiwiZXh0ZXJuYWwgXCJiYWJlbC1ydW50aW1lL2NvcmUtanMvb2JqZWN0L2Fzc2lnblwiIiwibGliL2V2bS9zZWxlY3RvcnMvaW5kZXguanMiLCJsaWIvdHJhY2Uvc2VsZWN0b3JzL2luZGV4LmpzIiwibGliL3NvbGlkaXR5L3NlbGVjdG9ycy9pbmRleC5qcyIsImxpYi90cmFjZS9hY3Rpb25zL2luZGV4LmpzIiwibGliL3RyYWNlL3NhZ2FzL2luZGV4LmpzIiwibGliL3Nlc3Npb24vYWN0aW9ucy9pbmRleC5qcyIsImV4dGVybmFsIFwiYm4uanNcIiIsImV4dGVybmFsIFwiYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC9rZXlzXCIiLCJsaWIvZGF0YS9zYWdhcy9pbmRleC5qcyIsImV4dGVybmFsIFwiYmFiZWwtcnVudGltZS9oZWxwZXJzL2FzeW5jVG9HZW5lcmF0b3JcIiIsImV4dGVybmFsIFwiYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC92YWx1ZXNcIiIsImxpYi9jb250cm9sbGVyL2FjdGlvbnMvaW5kZXguanMiLCJsaWIvZGF0YS9zZWxlY3RvcnMvaW5kZXguanMiLCJleHRlcm5hbCBcImpzb24tcG9pbnRlclwiIiwibGliL2V2bS9zYWdhcy9pbmRleC5qcyIsImxpYi9jb250cm9sbGVyL3NlbGVjdG9ycy9pbmRleC5qcyIsImxpYi9hc3QvbWFwLmpzIiwibGliL3Nlc3Npb24vc2VsZWN0b3JzL2luZGV4LmpzIiwibGliL2RhdGEvYWN0aW9ucy9pbmRleC5qcyIsImV4dGVybmFsIFwiYmFiZWwtcnVudGltZS9jb3JlLWpzL3NldFwiIiwibGliL2V2bS9hY3Rpb25zL2luZGV4LmpzIiwibGliL3dlYjMvc2FnYXMvaW5kZXguanMiLCJleHRlcm5hbCBcIndlYjNcIiIsImV4dGVybmFsIFwidHJ1ZmZsZS1kZWNvZGVyXCIiLCJsaWIvY29udHJvbGxlci9zYWdhcy9pbmRleC5qcyIsImxpYi9zb2xpZGl0eS9zYWdhcy9pbmRleC5qcyIsImxpYi9zb2xpZGl0eS9hY3Rpb25zL2luZGV4LmpzIiwibGliL2FzdC9zZWxlY3RvcnMvaW5kZXguanMiLCIvVXNlcnMvZ25pZGFuL3NyYy93b3JrL3RydWZmbGUvcGFja2FnZXMvdHJ1ZmZsZS1kZWJ1Z2dlci9kZWJ1Z2dlci5qcyIsImxpYi9kZWJ1Z2dlci5qcyIsImV4dGVybmFsIFwidHJ1ZmZsZS1leHBlY3RcIiIsImxpYi9zZXNzaW9uL2luZGV4LmpzIiwiZXh0ZXJuYWwgXCJiYWJlbC1ydW50aW1lL2NvcmUtanMvcHJvbWlzZVwiIiwibGliL3N0b3JlL2luZGV4LmpzIiwibGliL3N0b3JlL3Byb2R1Y3Rpb24uanMiLCJsaWIvc3RvcmUvY29tbW9uLmpzIiwiZXh0ZXJuYWwgXCJyZWR1eC1zYWdhXCIiLCJleHRlcm5hbCBcInJlZHV4LWNsaS1sb2dnZXJcIiIsIi9Vc2Vycy9nbmlkYW4vc3JjL3dvcmsvdHJ1ZmZsZS9ub2RlX21vZHVsZXMvanNvbi1zdGFibGUtc3RyaW5naWZ5L2luZGV4LmpzIiwiL1VzZXJzL2duaWRhbi9zcmMvd29yay90cnVmZmxlL25vZGVfbW9kdWxlcy9qc29uaWZ5L2luZGV4LmpzIiwiL1VzZXJzL2duaWRhbi9zcmMvd29yay90cnVmZmxlL25vZGVfbW9kdWxlcy9qc29uaWZ5L2xpYi9wYXJzZS5qcyIsIi9Vc2Vycy9nbmlkYW4vc3JjL3dvcmsvdHJ1ZmZsZS9ub2RlX21vZHVsZXMvanNvbmlmeS9saWIvc3RyaW5naWZ5LmpzIiwiZXh0ZXJuYWwgXCJ0cnVmZmxlLXNvbGlkaXR5LXV0aWxzXCIiLCJleHRlcm5hbCBcInRydWZmbGUtY29kZS11dGlsc1wiIiwiL1VzZXJzL2duaWRhbi9zcmMvd29yay90cnVmZmxlL25vZGVfbW9kdWxlcy9ub2RlLWludGVydmFsLXRyZWUvbGliL2luZGV4LmpzIiwiL1VzZXJzL2duaWRhbi9zcmMvd29yay90cnVmZmxlL25vZGVfbW9kdWxlcy9zaGFsbG93ZXF1YWwvaW5kZXguanMiLCJsaWIvd2ViMy9hY3Rpb25zL2luZGV4LmpzIiwibGliL3dlYjMvYWRhcHRlci5qcyIsImV4dGVybmFsIFwidXRpbFwiIiwiZXh0ZXJuYWwgXCJsb2Rhc2guc3VtXCIiLCJsaWIvc2Vzc2lvbi9zYWdhcy9pbmRleC5qcyIsImxpYi9hc3Qvc2FnYXMvaW5kZXguanMiLCJsaWIvc2Vzc2lvbi9yZWR1Y2Vycy5qcyIsImxpYi9kYXRhL3JlZHVjZXJzLmpzIiwibGliL2V2bS9yZWR1Y2Vycy5qcyIsImxpYi9zb2xpZGl0eS9yZWR1Y2Vycy5qcyIsImxpYi90cmFjZS9yZWR1Y2Vycy5qcyIsImxpYi9jb250cm9sbGVyL3JlZHVjZXJzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiB3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbihyb290LCBmYWN0b3J5KSB7XG5cdGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0Jylcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcblx0ZWxzZSBpZih0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpXG5cdFx0ZGVmaW5lKFwiRGVidWdnZXJcIiwgW10sIGZhY3RvcnkpO1xuXHRlbHNlIGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jylcblx0XHRleHBvcnRzW1wiRGVidWdnZXJcIl0gPSBmYWN0b3J5KCk7XG5cdGVsc2Vcblx0XHRyb290W1wiRGVidWdnZXJcIl0gPSBmYWN0b3J5KCk7XG59KSh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgPyBzZWxmIDogdGhpcywgZnVuY3Rpb24oKSB7XG5yZXR1cm4gXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHdlYnBhY2svdW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbiIsIiBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbiBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbiBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbiBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKSB7XG4gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG4gXHRcdH1cbiBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbiBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuIFx0XHRcdGk6IG1vZHVsZUlkLFxuIFx0XHRcdGw6IGZhbHNlLFxuIFx0XHRcdGV4cG9ydHM6IHt9XG4gXHRcdH07XG5cbiBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG4gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbiBcdFx0bW9kdWxlLmwgPSB0cnVlO1xuXG4gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbiBcdH1cblxuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbiBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbiBcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb24gZm9yIGhhcm1vbnkgZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XG4gXHRcdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywgbmFtZSkpIHtcbiBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwge1xuIFx0XHRcdFx0Y29uZmlndXJhYmxlOiBmYWxzZSxcbiBcdFx0XHRcdGVudW1lcmFibGU6IHRydWUsXG4gXHRcdFx0XHRnZXQ6IGdldHRlclxuIFx0XHRcdH0pO1xuIFx0XHR9XG4gXHR9O1xuXG4gXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG4gXHRcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuIFx0XHRcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHsgcmV0dXJuIG1vZHVsZTsgfTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xuIFx0XHRyZXR1cm4gZ2V0dGVyO1xuIFx0fTtcblxuIFx0Ly8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7IH07XG5cbiBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuXG4gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbiBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IDM3KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyB3ZWJwYWNrL2Jvb3RzdHJhcCBiNzA2MmE4MTczYWUxMTIwMDQxZiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcImRlYnVnXCIpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGV4dGVybmFsIFwiZGVidWdcIlxuLy8gbW9kdWxlIGlkID0gMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgKiBhcyB1dGlscyBmcm9tIFwidHJ1ZmZsZS1kZWNvZGUtdXRpbHNcIjtcblxuY29uc3Qgc3RyaW5naWZ5ID0gcmVxdWlyZShcImpzb24tc3RhYmxlLXN0cmluZ2lmeVwiKTtcblxuLyoqIEFTVCBub2RlIHR5cGVzIHRoYXQgYXJlIHNraXBwZWQgYnkgc3RlcE5leHQoKSB0byBmaWx0ZXIgb3V0IHNvbWUgbm9pc2UgKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0RlbGliZXJhdGVseVNraXBwZWROb2RlVHlwZShub2RlKSB7XG4gIGNvbnN0IHNraXBwZWRUeXBlcyA9IFtcIkNvbnRyYWN0RGVmaW5pdGlvblwiLCBcIlZhcmlhYmxlRGVjbGFyYXRpb25cIl07XG4gIHJldHVybiBza2lwcGVkVHlwZXMuaW5jbHVkZXMobm9kZS5ub2RlVHlwZSk7XG59XG5cbi8vSEFDS1xuLy90aGVzZSBhcmVuJ3QgdGhlIG9ubHkgdHlwZXMgb2Ygc2tpcHBlZCBub2RlcywgYnV0IGRldGVybWluaW5nIGFsbCBza2lwcGVkXG4vL25vZGVzIHdvdWxkIGJlIHRvbyBkaWZmaWN1bHRcbmV4cG9ydCBmdW5jdGlvbiBpc1NraXBwZWROb2RlVHlwZShub2RlKSB7XG4gIGNvbnN0IG90aGVyU2tpcHBlZFR5cGVzID0gW1wiVmFyaWFibGVEZWNsYXJhdGlvblN0YXRlbWVudFwiLCBcIk1hcHBpbmdcIl07XG4gIHJldHVybiAoXG4gICAgaXNEZWxpYmVyYXRlbHlTa2lwcGVkTm9kZVR5cGUobm9kZSkgfHxcbiAgICBvdGhlclNraXBwZWRUeXBlcy5pbmNsdWRlcyhub2RlLm5vZGVUeXBlKSB8fFxuICAgIG5vZGUubm9kZVR5cGUuaW5jbHVkZXMoXCJUeXBlTmFtZVwiKSB8fCAvL0hBQ0tcbiAgICAvL3NraXAgc3RyaW5nIGxpdGVyYWxzIHRvbyAtLSB3ZSdsbCBoYW5kbGUgdGhhdCBtYW51YWxseVxuICAgIChub2RlLnR5cGVEZXNjcmlwdGlvbnMgIT09IHVuZGVmaW5lZCAmJiAvL3NlZW1zIHRoaXMgc29tZXRpbWVzIGhhcHBlbnM/XG4gICAgICB1dGlscy5EZWZpbml0aW9uLnR5cGVDbGFzcyhub2RlKSA9PT0gXCJzdHJpbmdsaXRlcmFsXCIpXG4gICk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwcmVmaXhOYW1lKHByZWZpeCwgZm4pIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGZuLCBcIm5hbWVcIiwge1xuICAgIHZhbHVlOiBgJHtwcmVmaXh9LiR7Zm4ubmFtZX1gLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcblxuICByZXR1cm4gZm47XG59XG5cbi8qXG4gKiBleHRyYWN0IHRoZSBwcmltYXJ5IHNvdXJjZSBmcm9tIGEgc291cmNlIG1hcFxuICogKGkuZS4sIHRoZSBzb3VyY2UgZm9yIHRoZSBmaXJzdCBpbnN0cnVjdGlvbiwgZm91bmRcbiAqIGJldHdlZW4gdGhlIHNlY29uZCBhbmQgdGhpcmQgY29sb25zKVxuICogKHRoaXMgaXMgc29tZXRoaW5nIG9mIGEgSEFDSylcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGV4dHJhY3RQcmltYXJ5U291cmNlKHNvdXJjZU1hcCkge1xuICByZXR1cm4gcGFyc2VJbnQoc291cmNlTWFwLm1hdGNoKC9eW146XSs6W146XSs6KFteOl0rKTovKVsxXSk7XG59XG5cbi8qKlxuICogQHJldHVybiAweC1wcmVmaXggc3RyaW5nIG9mIGtlY2NhazI1NiBoYXNoXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBrZWNjYWsyNTYoLi4uYXJncykge1xuICByZXR1cm4gdXRpbHMuQ29udmVyc2lvbi50b0hleFN0cmluZyh1dGlscy5FVk0ua2VjY2FrMjU2KC4uLmFyZ3MpKTtcbn1cblxuLyoqXG4gKiBHaXZlbiBhbiBvYmplY3QsIHJldHVybiBhIHN0YWJsZSBoYXNoIGJ5IGZpcnN0IHJ1bm5pbmcgaXQgdGhyb3VnaCBhIHN0YWJsZVxuICogc3RyaW5naWZ5IG9wZXJhdGlvbiBiZWZvcmUgaGFzaGluZ1xuICovXG5leHBvcnQgZnVuY3Rpb24gc3RhYmxlS2VjY2FrMjU2KG9iaikge1xuICByZXR1cm4ga2VjY2FrMjU2KHsgdHlwZTogXCJzdHJpbmdcIiwgdmFsdWU6IHN0cmluZ2lmeShvYmopIH0pO1xufVxuXG4vKlxuICogdXNlZCBieSBkYXRhOyB0YWtlcyBhbiBpZCBvYmplY3QgYW5kIGEgcmVmIChwb2ludGVyKSBhbmQgcmV0dXJucyBhIGZ1bGxcbiAqIGNvcnJlc3BvbmRpbmcgYXNzaWdubWVudCBvYmplY3RcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1ha2VBc3NpZ25tZW50KGlkT2JqLCByZWYpIHtcbiAgbGV0IGlkID0gc3RhYmxlS2VjY2FrMjU2KGlkT2JqKTtcbiAgcmV0dXJuIHsgLi4uaWRPYmosIGlkLCByZWYgfTtcbn1cblxuLypcbiAqIEdpdmVuIGEgbW1lbW9uaWMsIGRldGVybWluZSB3aGV0aGVyIGl0J3MgdGhlIG1uZW1vbmljIG9mIGEgY2FsbGluZ1xuICogaW5zdHJ1Y3Rpb24gKGRvZXMgTk9UIGluY2x1ZGUgY3JlYXRpb24gaW5zdHJ1Y3Rpb25zKVxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNDYWxsTW5lbW9uaWMob3ApIHtcbiAgY29uc3QgY2FsbHMgPSBbXCJDQUxMXCIsIFwiREVMRUdBVEVDQUxMXCIsIFwiU1RBVElDQ0FMTFwiLCBcIkNBTExDT0RFXCJdO1xuICByZXR1cm4gY2FsbHMuaW5jbHVkZXMob3ApO1xufVxuXG4vKlxuICogcmV0dXJucyB0cnVlIGZvciBtbmVtb25pY3MgZm9yIGNhbGxzIHRoYXQgdGFrZSBvbmx5IDYgYXJncyBpbnN0ZWFkIG9mIDdcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzU2hvcnRDYWxsTW5lbW9uaWMob3ApIHtcbiAgY29uc3Qgc2hvcnRDYWxscyA9IFtcIkRFTEVHQVRFQ0FMTFwiLCBcIlNUQVRJQ0NBTExcIl07XG4gIHJldHVybiBzaG9ydENhbGxzLmluY2x1ZGVzKG9wKTtcbn1cblxuLypcbiAqIHJldHVybnMgdHJ1ZSBmb3IgbW5lbW9uaWNzIGZvciBjYWxscyB0aGF0IGRlbGVnYXRlIHN0b3JhZ2VcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzRGVsZWdhdGVDYWxsTW5lbW9uaWNCcm9hZChvcCkge1xuICBjb25zdCBkZWxlZ2F0ZUNhbGxzID0gW1wiREVMRUdBVEVDQUxMXCIsIFwiQ0FMTENPREVcIl07XG4gIHJldHVybiBkZWxlZ2F0ZUNhbGxzLmluY2x1ZGVzKG9wKTtcbn1cblxuLypcbiAqIHJldHVybnMgdHJ1ZSBmb3IgbW5lbW9uaWNzIGZvciBjYWxscyB0aGF0IGRlbGVnYXRlIGV2ZXJ5dGhpbmdcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzRGVsZWdhdGVDYWxsTW5lbW9uaWNTdHJpY3Qob3ApIHtcbiAgY29uc3QgZGVsZWdhdGVDYWxscyA9IFtcIkRFTEVHQVRFQ0FMTFwiXTtcbiAgcmV0dXJuIGRlbGVnYXRlQ2FsbHMuaW5jbHVkZXMob3ApO1xufVxuXG4vKlxuICogcmV0dXJucyB0cnVlIGZvciBtbmVtb25pY3MgZm9yIHN0YXRpYyBjYWxsc1xuICovXG5leHBvcnQgZnVuY3Rpb24gaXNTdGF0aWNDYWxsTW5lbW9uaWMob3ApIHtcbiAgY29uc3QgZGVsZWdhdGVDYWxscyA9IFtcIlNUQVRJQ0NBTExcIl07XG4gIHJldHVybiBkZWxlZ2F0ZUNhbGxzLmluY2x1ZGVzKG9wKTtcbn1cblxuLypcbiAqIEdpdmVuIGEgbW1lbW9uaWMsIGRldGVybWluZSB3aGV0aGVyIGl0J3MgdGhlIG1uZW1vbmljIG9mIGEgY3JlYXRpb25cbiAqIGluc3RydWN0aW9uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0NyZWF0ZU1uZW1vbmljKG9wKSB7XG4gIGNvbnN0IGNyZWF0ZXMgPSBbXCJDUkVBVEVcIiwgXCJDUkVBVEUyXCJdO1xuICByZXR1cm4gY3JlYXRlcy5pbmNsdWRlcyhvcCk7XG59XG5cbi8qXG4gKiBHaXZlbiBhIG1tZW1vbmljLCBkZXRlcm1pbmUgd2hldGhlciBpdCdzIHRoZSBtbmVtb25pYyBvZiBhIG5vcm1hbFxuICogaGFsdGluZyBpbnN0cnVjdGlvblxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNOb3JtYWxIYWx0aW5nTW5lbW9uaWMob3ApIHtcbiAgY29uc3QgaGFsdHMgPSBbXCJTVE9QXCIsIFwiUkVUVVJOXCIsIFwiU0VMRkRFU1RSVUNUXCIsIFwiU1VJQ0lERVwiXTtcbiAgLy90aGUgbW5lbW9uaWMgU1VJQ0lERSBpcyBubyBsb25nZXIgdXNlZCwgYnV0IGp1c3QgaW4gY2FzZSwgSSdtIGluY2x1ZGluZyBpdFxuICByZXR1cm4gaGFsdHMuaW5jbHVkZXMob3ApO1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIGxpYi9oZWxwZXJzL2luZGV4LmpzIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiYmFiZWwtcnVudGltZS9oZWxwZXJzL2V4dGVuZHNcIik7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZXh0ZXJuYWwgXCJiYWJlbC1ydW50aW1lL2hlbHBlcnMvZXh0ZW5kc1wiXG4vLyBtb2R1bGUgaWQgPSAyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcInJlc2VsZWN0LXRyZWVcIik7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZXh0ZXJuYWwgXCJyZXNlbGVjdC10cmVlXCJcbi8vIG1vZHVsZSBpZCA9IDNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwidHJ1ZmZsZS1kZWNvZGUtdXRpbHNcIik7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZXh0ZXJuYWwgXCJ0cnVmZmxlLWRlY29kZS11dGlsc1wiXG4vLyBtb2R1bGUgaWQgPSA0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcInJlZHV4LXNhZ2EvZWZmZWN0c1wiKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBleHRlcm5hbCBcInJlZHV4LXNhZ2EvZWZmZWN0c1wiXG4vLyBtb2R1bGUgaWQgPSA1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcImJhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3QvZW50cmllc1wiKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBleHRlcm5hbCBcImJhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3QvZW50cmllc1wiXG4vLyBtb2R1bGUgaWQgPSA2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcInJlZHV4XCIpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGV4dGVybmFsIFwicmVkdXhcIlxuLy8gbW9kdWxlIGlkID0gN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJiYWJlbC1ydW50aW1lL2NvcmUtanMvb2JqZWN0L2Fzc2lnblwiKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBleHRlcm5hbCBcImJhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3QvYXNzaWduXCJcbi8vIG1vZHVsZSBpZCA9IDhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IGRlYnVnTW9kdWxlIGZyb20gXCJkZWJ1Z1wiO1xuY29uc3QgZGVidWcgPSBkZWJ1Z01vZHVsZShcImRlYnVnZ2VyOmV2bTpzZWxlY3RvcnNcIik7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcblxuaW1wb3J0IHsgY3JlYXRlU2VsZWN0b3JUcmVlLCBjcmVhdGVMZWFmIH0gZnJvbSBcInJlc2VsZWN0LXRyZWVcIjtcbmltcG9ydCBCTiBmcm9tIFwiYm4uanNcIjtcblxuaW1wb3J0IHRyYWNlIGZyb20gXCJsaWIvdHJhY2Uvc2VsZWN0b3JzXCI7XG5cbmltcG9ydCAqIGFzIERlY29kZVV0aWxzIGZyb20gXCJ0cnVmZmxlLWRlY29kZS11dGlsc1wiO1xuaW1wb3J0IHtcbiAgaXNDYWxsTW5lbW9uaWMsXG4gIGlzQ3JlYXRlTW5lbW9uaWMsXG4gIGlzU2hvcnRDYWxsTW5lbW9uaWMsXG4gIGlzRGVsZWdhdGVDYWxsTW5lbW9uaWNCcm9hZCxcbiAgaXNEZWxlZ2F0ZUNhbGxNbmVtb25pY1N0cmljdCxcbiAgaXNTdGF0aWNDYWxsTW5lbW9uaWMsXG4gIGlzTm9ybWFsSGFsdGluZ01uZW1vbmljXG59IGZyb20gXCJsaWIvaGVscGVyc1wiO1xuXG4vKipcbiAqIGNyZWF0ZSBFVk0tbGV2ZWwgc2VsZWN0b3JzIGZvciBhIGdpdmVuIHRyYWNlIHN0ZXAgc2VsZWN0b3JcbiAqIG1heSBzcGVjaWZ5IGFkZGl0aW9uYWwgc2VsZWN0b3JzIHRvIGluY2x1ZGVcbiAqL1xuZnVuY3Rpb24gY3JlYXRlU3RlcFNlbGVjdG9ycyhzdGVwLCBzdGF0ZSA9IG51bGwpIHtcbiAgbGV0IGJhc2UgPSB7XG4gICAgLyoqXG4gICAgICogLnRyYWNlXG4gICAgICpcbiAgICAgKiB0cmFjZSBzdGVwIGluZm8gcmVsYXRlZCB0byBvcGVyYXRpb25cbiAgICAgKi9cbiAgICB0cmFjZTogY3JlYXRlTGVhZihbc3RlcF0sIHN0ZXAgPT4ge1xuICAgICAgaWYgKCFzdGVwKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgbGV0IHsgZ2FzQ29zdCwgb3AsIHBjIH0gPSBzdGVwO1xuICAgICAgcmV0dXJuIHsgZ2FzQ29zdCwgb3AsIHBjIH07XG4gICAgfSksXG5cbiAgICAvKipcbiAgICAgKiAucHJvZ3JhbUNvdW50ZXJcbiAgICAgKi9cbiAgICBwcm9ncmFtQ291bnRlcjogY3JlYXRlTGVhZihbXCIuL3RyYWNlXCJdLCBzdGVwID0+IChzdGVwID8gc3RlcC5wYyA6IG51bGwpKSxcblxuICAgIC8qKlxuICAgICAqIC5pc0p1bXBcbiAgICAgKi9cbiAgICBpc0p1bXA6IGNyZWF0ZUxlYWYoXG4gICAgICBbXCIuL3RyYWNlXCJdLFxuICAgICAgc3RlcCA9PiBzdGVwLm9wICE9IFwiSlVNUERFU1RcIiAmJiBzdGVwLm9wLmluZGV4T2YoXCJKVU1QXCIpID09IDBcbiAgICApLFxuXG4gICAgLyoqXG4gICAgICogLmlzQ2FsbFxuICAgICAqXG4gICAgICogd2hldGhlciB0aGUgb3Bjb2RlIHdpbGwgc3dpdGNoIHRvIGFub3RoZXIgY2FsbGluZyBjb250ZXh0XG4gICAgICovXG4gICAgaXNDYWxsOiBjcmVhdGVMZWFmKFtcIi4vdHJhY2VcIl0sIHN0ZXAgPT4gaXNDYWxsTW5lbW9uaWMoc3RlcC5vcCkpLFxuXG4gICAgLyoqXG4gICAgICogLmlzU2hvcnRDYWxsXG4gICAgICpcbiAgICAgKiBmb3IgY2FsbHMgdGhhdCBvbmx5IHRha2UgNiBhcmd1bWVudHMgaW5zdGVhZCBvZiA3XG4gICAgICovXG4gICAgaXNTaG9ydENhbGw6IGNyZWF0ZUxlYWYoW1wiLi90cmFjZVwiXSwgc3RlcCA9PiBpc1Nob3J0Q2FsbE1uZW1vbmljKHN0ZXAub3ApKSxcblxuICAgIC8qKlxuICAgICAqIC5pc0RlbGVnYXRlQ2FsbEJyb2FkXG4gICAgICpcbiAgICAgKiBmb3IgY2FsbHMgdGhhdCBkZWxlZ2F0ZSBzdG9yYWdlXG4gICAgICovXG4gICAgaXNEZWxlZ2F0ZUNhbGxCcm9hZDogY3JlYXRlTGVhZihbXCIuL3RyYWNlXCJdLCBzdGVwID0+XG4gICAgICBpc0RlbGVnYXRlQ2FsbE1uZW1vbmljQnJvYWQoc3RlcC5vcClcbiAgICApLFxuXG4gICAgLyoqXG4gICAgICogLmlzRGVsZWdhdGVDYWxsU3RyaWN0XG4gICAgICpcbiAgICAgKiBmb3IgY2FsbHMgdGhhdCBhZGRpdGlvbmFsbHkgZGVsZWdhdGUgc2VuZGVyIGFuZCB2YWx1ZVxuICAgICAqL1xuICAgIGlzRGVsZWdhdGVDYWxsU3RyaWN0OiBjcmVhdGVMZWFmKFtcIi4vdHJhY2VcIl0sIHN0ZXAgPT5cbiAgICAgIGlzRGVsZWdhdGVDYWxsTW5lbW9uaWNTdHJpY3Qoc3RlcC5vcClcbiAgICApLFxuXG4gICAgLyoqXG4gICAgICogLmlzU3RhdGljQ2FsbFxuICAgICAqL1xuICAgIGlzU3RhdGljQ2FsbDogY3JlYXRlTGVhZihbXCIuL3RyYWNlXCJdLCBzdGVwID0+XG4gICAgICBpc1N0YXRpY0NhbGxNbmVtb25pYyhzdGVwLm9wKVxuICAgICksXG5cbiAgICAvKipcbiAgICAgKiAuaXNDcmVhdGVcbiAgICAgKi9cbiAgICBpc0NyZWF0ZTogY3JlYXRlTGVhZihbXCIuL3RyYWNlXCJdLCBzdGVwID0+IGlzQ3JlYXRlTW5lbW9uaWMoc3RlcC5vcCkpLFxuXG4gICAgLyoqXG4gICAgICogLmlzSGFsdGluZ1xuICAgICAqXG4gICAgICogd2hldGhlciB0aGUgaW5zdHJ1Y3Rpb24gaGFsdHMgb3IgcmV0dXJucyBmcm9tIGEgY2FsbGluZyBjb250ZXh0XG4gICAgICogTk9URTogdGhpcyBjb3ZlcnMgb25seSBvcmRpbmFyeSBoYWx0cywgbm90IGV4Y2VwdGlvbmFsIGhhbHRzO1xuICAgICAqIGJ1dCBpdCBkb2Vzbid0IGNoZWNrIHRoZSByZXR1cm4gc3RhdHVzLCBzbyBhbnkgbm9ybWFsIGhhbHRpbmdcbiAgICAgKiBpbnN0cnVjdGlvbiB3aWxsIHF1YWxpZnkgaGVyZVxuICAgICAqL1xuICAgIGlzSGFsdGluZzogY3JlYXRlTGVhZihbXCIuL3RyYWNlXCJdLCBzdGVwID0+XG4gICAgICBpc05vcm1hbEhhbHRpbmdNbmVtb25pYyhzdGVwLm9wKVxuICAgICksXG5cbiAgICAvKlxuICAgICAqIC5pc1N0b3JlXG4gICAgICovXG4gICAgaXNTdG9yZTogY3JlYXRlTGVhZihbXCIuL3RyYWNlXCJdLCBzdGVwID0+IHN0ZXAub3AgPT0gXCJTU1RPUkVcIiksXG5cbiAgICAvKlxuICAgICAqIC5pc0xvYWRcbiAgICAgKi9cbiAgICBpc0xvYWQ6IGNyZWF0ZUxlYWYoW1wiLi90cmFjZVwiXSwgc3RlcCA9PiBzdGVwLm9wID09IFwiU0xPQURcIiksXG5cbiAgICAvKlxuICAgICAqIC50b3VjaGVzU3RvcmFnZVxuICAgICAqXG4gICAgICogd2hldGhlciB0aGUgaW5zdHJ1Y3Rpb24gaW52b2x2ZXMgc3RvcmFnZVxuICAgICAqL1xuICAgIHRvdWNoZXNTdG9yYWdlOiBjcmVhdGVMZWFmKFxuICAgICAgW1wiLi9pc1N0b3JlXCIsIFwiaXNMb2FkXCJdLFxuICAgICAgKHN0b3JlcywgbG9hZHMpID0+IHN0b3JlcyB8fCBsb2Fkc1xuICAgIClcbiAgfTtcblxuICBpZiAoc3RhdGUpIHtcbiAgICBjb25zdCBpc1JlbGF0aXZlID0gcGF0aCA9PlxuICAgICAgdHlwZW9mIHBhdGggPT0gXCJzdHJpbmdcIiAmJlxuICAgICAgKHBhdGguc3RhcnRzV2l0aChcIi4vXCIpIHx8IHBhdGguc3RhcnRzV2l0aChcIi4uL1wiKSk7XG5cbiAgICBpZiAoaXNSZWxhdGl2ZShzdGF0ZSkpIHtcbiAgICAgIHN0YXRlID0gYC4uLyR7c3RhdGV9YDtcbiAgICB9XG5cbiAgICBPYmplY3QuYXNzaWduKGJhc2UsIHtcbiAgICAgIC8qKlxuICAgICAgICogLmNhbGxBZGRyZXNzXG4gICAgICAgKlxuICAgICAgICogYWRkcmVzcyB0cmFuc2ZlcnJlZCB0byBieSBjYWxsIG9wZXJhdGlvblxuICAgICAgICovXG4gICAgICBjYWxsQWRkcmVzczogY3JlYXRlTGVhZihcbiAgICAgICAgW1wiLi9pc0NhbGxcIiwgc3RhdGVdLFxuXG4gICAgICAgIChpc0NhbGwsIHsgc3RhY2sgfSkgPT4ge1xuICAgICAgICAgIGlmICghaXNDYWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBsZXQgYWRkcmVzcyA9IHN0YWNrW3N0YWNrLmxlbmd0aCAtIDJdO1xuICAgICAgICAgIHJldHVybiBEZWNvZGVVdGlscy5Db252ZXJzaW9uLnRvQWRkcmVzcyhhZGRyZXNzKTtcbiAgICAgICAgfVxuICAgICAgKSxcblxuICAgICAgLyoqXG4gICAgICAgKiAuY3JlYXRlQmluYXJ5XG4gICAgICAgKlxuICAgICAgICogYmluYXJ5IGNvZGUgdG8gZXhlY3V0ZSB2aWEgY3JlYXRlIG9wZXJhdGlvblxuICAgICAgICovXG4gICAgICBjcmVhdGVCaW5hcnk6IGNyZWF0ZUxlYWYoXG4gICAgICAgIFtcIi4vaXNDcmVhdGVcIiwgc3RhdGVdLFxuXG4gICAgICAgIChpc0NyZWF0ZSwgeyBzdGFjaywgbWVtb3J5IH0pID0+IHtcbiAgICAgICAgICBpZiAoIWlzQ3JlYXRlKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBHZXQgdGhlIGNvZGUgdGhhdCdzIGdvaW5nIHRvIGJlIGNyZWF0ZWQgZnJvbSBtZW1vcnkuXG4gICAgICAgICAgLy8gTm90ZSB3ZSBtdWx0aXBseSBieSAyIGJlY2F1c2UgdGhlc2Ugb2Zmc2V0cyBhcmUgaW4gYnl0ZXMuXG4gICAgICAgICAgY29uc3Qgb2Zmc2V0ID0gcGFyc2VJbnQoc3RhY2tbc3RhY2subGVuZ3RoIC0gMl0sIDE2KSAqIDI7XG4gICAgICAgICAgY29uc3QgbGVuZ3RoID0gcGFyc2VJbnQoc3RhY2tbc3RhY2subGVuZ3RoIC0gM10sIDE2KSAqIDI7XG5cbiAgICAgICAgICByZXR1cm4gXCIweFwiICsgbWVtb3J5LmpvaW4oXCJcIikuc3Vic3RyaW5nKG9mZnNldCwgb2Zmc2V0ICsgbGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgKSxcblxuICAgICAgLyoqXG4gICAgICAgKiAuY2FsbERhdGFcbiAgICAgICAqXG4gICAgICAgKiBkYXRhIHBhc3NlZCB0byBFVk0gY2FsbFxuICAgICAgICovXG4gICAgICBjYWxsRGF0YTogY3JlYXRlTGVhZihcbiAgICAgICAgW1wiLi9pc0NhbGxcIiwgXCIuL2lzU2hvcnRDYWxsXCIsIHN0YXRlXSxcbiAgICAgICAgKGlzQ2FsbCwgc2hvcnQsIHsgc3RhY2ssIG1lbW9yeSB9KSA9PiB7XG4gICAgICAgICAgaWYgKCFpc0NhbGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vaWYgaXQncyA2LWFyZ3VtZW50IGNhbGwsIHRoZSBkYXRhIHN0YXJ0IGFuZCBvZmZzZXQgd2lsbCBiZSBvbmUgc3BvdFxuICAgICAgICAgIC8vaGlnaGVyIGluIHRoZSBzdGFjayB0aGFuIHRoZXkgd291bGQgYmUgZm9yIGEgNy1hcmd1bWVudCBjYWxsLCBzb1xuICAgICAgICAgIC8vbGV0J3MgaW50cm9kdWNlIGFuIG9mZnNldCB0byBoYW5kbGUgdGhpc1xuICAgICAgICAgIGxldCBhcmdPZmZzZXQgPSBzaG9ydCA/IDEgOiAwO1xuXG4gICAgICAgICAgLy8gR2V0IHRoZSBkYXRhIGZyb20gbWVtb3J5LlxuICAgICAgICAgIC8vIE5vdGUgd2UgbXVsdGlwbHkgYnkgMiBiZWNhdXNlIHRoZXNlIG9mZnNldHMgYXJlIGluIGJ5dGVzLlxuICAgICAgICAgIGNvbnN0IG9mZnNldCA9IHBhcnNlSW50KHN0YWNrW3N0YWNrLmxlbmd0aCAtIDQgKyBhcmdPZmZzZXRdLCAxNikgKiAyO1xuICAgICAgICAgIGNvbnN0IGxlbmd0aCA9IHBhcnNlSW50KHN0YWNrW3N0YWNrLmxlbmd0aCAtIDUgKyBhcmdPZmZzZXRdLCAxNikgKiAyO1xuXG4gICAgICAgICAgcmV0dXJuIFwiMHhcIiArIG1lbW9yeS5qb2luKFwiXCIpLnN1YnN0cmluZyhvZmZzZXQsIG9mZnNldCArIGxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgICksXG5cbiAgICAgIC8qKlxuICAgICAgICogLmNhbGxWYWx1ZVxuICAgICAgICpcbiAgICAgICAqIHZhbHVlIGZvciB0aGUgY2FsbCAobm90IGNyZWF0ZSk7IHJldHVybnMgbnVsbCBmb3IgREVMRUdBVEVDQUxMXG4gICAgICAgKi9cbiAgICAgIGNhbGxWYWx1ZTogY3JlYXRlTGVhZihcbiAgICAgICAgW1wiLi9pc0NhbGxcIiwgXCIuL2lzRGVsZWdhdGVDYWxsU3RyaWN0XCIsIFwiLi9pc1N0YXRpY0NhbGxcIiwgc3RhdGVdLFxuICAgICAgICAoY2FsbHMsIGRlbGVnYXRlcywgaXNTdGF0aWMsIHsgc3RhY2sgfSkgPT4ge1xuICAgICAgICAgIGlmICghY2FsbHMgfHwgZGVsZWdhdGVzKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoaXNTdGF0aWMpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQk4oMCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy9vdGhlcndpc2UsIGZvciBDQUxMIGFuZCBDQUxMQ09ERSwgaXQncyB0aGUgM3JkIGFyZ3VtZW50XG4gICAgICAgICAgbGV0IHZhbHVlID0gc3RhY2tbc3RhY2subGVuZ3RoIC0gM107XG4gICAgICAgICAgcmV0dXJuIERlY29kZVV0aWxzLkNvbnZlcnNpb24udG9CTih2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICksXG5cbiAgICAgIC8qKlxuICAgICAgICogLmNyZWF0ZVZhbHVlXG4gICAgICAgKlxuICAgICAgICogdmFsdWUgZm9yIHRoZSBjcmVhdGVcbiAgICAgICAqL1xuICAgICAgY3JlYXRlVmFsdWU6IGNyZWF0ZUxlYWYoW1wiLi9pc0NyZWF0ZVwiLCBzdGF0ZV0sIChpc0NyZWF0ZSwgeyBzdGFjayB9KSA9PiB7XG4gICAgICAgIGlmICghaXNDcmVhdGUpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vY3JlYXRlcyBoYXZlIHRoZSB2YWx1ZSBhcyB0aGUgZmlyc3QgYXJndW1lbnRcbiAgICAgICAgbGV0IHZhbHVlID0gc3RhY2tbc3RhY2subGVuZ3RoIC0gMV07XG4gICAgICAgIHJldHVybiBEZWNvZGVVdGlscy5Db252ZXJzaW9uLnRvQk4odmFsdWUpO1xuICAgICAgfSksXG5cbiAgICAgIC8qKlxuICAgICAgICogLnN0b3JhZ2VBZmZlY3RlZFxuICAgICAgICpcbiAgICAgICAqIHN0b3JhZ2Ugc2xvdCBiZWluZyBzdG9yZWQgdG8gb3IgbG9hZGVkIGZyb21cbiAgICAgICAqIHdlIGRvIE5PVCBwcmVwZW5kIFwiMHhcIlxuICAgICAgICovXG4gICAgICBzdG9yYWdlQWZmZWN0ZWQ6IGNyZWF0ZUxlYWYoXG4gICAgICAgIFtcIi4vdG91Y2hlc1N0b3JhZ2VcIiwgc3RhdGVdLFxuXG4gICAgICAgICh0b3VjaGVzU3RvcmFnZSwgeyBzdGFjayB9KSA9PiB7XG4gICAgICAgICAgaWYgKCF0b3VjaGVzU3RvcmFnZSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdO1xuICAgICAgICB9XG4gICAgICApLFxuXG4gICAgICAvKlxuICAgICAgICogLnJldHVyblZhbHVlXG4gICAgICAgKlxuICAgICAgICogZm9yIGEgUkVUVVJOIGluc3RydWN0aW9uLCB0aGUgdmFsdWUgcmV0dXJuZWRcbiAgICAgICAqIHdlIERPIHByZXBlbmQgXCIweFwiXG4gICAgICAgKiAod2lsbCBhbHNvIHJldHVybiBcIjB4XCIgZm9yIFNUT1Agb3IgU0VMRkRFU1RSVUNUIGJ1dFxuICAgICAgICogbnVsbCBvdGhlcndpc2UpXG4gICAgICAgKi9cbiAgICAgIHJldHVyblZhbHVlOiBjcmVhdGVMZWFmKFxuICAgICAgICBbXCIuL3RyYWNlXCIsIFwiLi9pc0hhbHRpbmdcIiwgc3RhdGVdLFxuXG4gICAgICAgIChzdGVwLCBpc0hhbHRpbmcsIHsgc3RhY2ssIG1lbW9yeSB9KSA9PiB7XG4gICAgICAgICAgaWYgKCFpc0hhbHRpbmcpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc3RlcC5vcCAhPT0gXCJSRVRVUk5cIikge1xuICAgICAgICAgICAgLy9TVE9QIGFuZCBTRUxGREVTVFJVQ1QgcmV0dXJuIGVtcHR5IHZhbHVlXG4gICAgICAgICAgICByZXR1cm4gXCIweFwiO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBHZXQgdGhlIGRhdGEgZnJvbSBtZW1vcnkuXG4gICAgICAgICAgLy8gTm90ZSB3ZSBtdWx0aXBseSBieSAyIGJlY2F1c2UgdGhlc2Ugb2Zmc2V0cyBhcmUgaW4gYnl0ZXMuXG4gICAgICAgICAgY29uc3Qgb2Zmc2V0ID0gcGFyc2VJbnQoc3RhY2tbc3RhY2subGVuZ3RoIC0gMV0sIDE2KSAqIDI7XG4gICAgICAgICAgY29uc3QgbGVuZ3RoID0gcGFyc2VJbnQoc3RhY2tbc3RhY2subGVuZ3RoIC0gMl0sIDE2KSAqIDI7XG5cbiAgICAgICAgICByZXR1cm4gXCIweFwiICsgbWVtb3J5LmpvaW4oXCJcIikuc3Vic3RyaW5nKG9mZnNldCwgb2Zmc2V0ICsgbGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgKVxuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIGJhc2U7XG59XG5cbmNvbnN0IGV2bSA9IGNyZWF0ZVNlbGVjdG9yVHJlZSh7XG4gIC8qKlxuICAgKiBldm0uc3RhdGVcbiAgICovXG4gIHN0YXRlOiBzdGF0ZSA9PiBzdGF0ZS5ldm0sXG5cbiAgLyoqXG4gICAqIGV2bS5pbmZvXG4gICAqL1xuICBpbmZvOiB7XG4gICAgLyoqXG4gICAgICogZXZtLmluZm8uY29udGV4dHNcbiAgICAgKi9cbiAgICBjb250ZXh0czogY3JlYXRlTGVhZihbXCIvc3RhdGVcIl0sIHN0YXRlID0+IHN0YXRlLmluZm8uY29udGV4dHMuYnlDb250ZXh0KSxcblxuICAgIC8qKlxuICAgICAqIGV2bS5pbmZvLmJpbmFyaWVzXG4gICAgICovXG4gICAgYmluYXJpZXM6IHtcbiAgICAgIC8qKlxuICAgICAgICogZXZtLmluZm8uYmluYXJpZXMuc2VhcmNoXG4gICAgICAgKlxuICAgICAgICogcmV0dXJucyBmdW5jdGlvbiAoYmluYXJ5KSA9PiBjb250ZXh0IChyZXR1cm5zIHRoZSAqSUQqIG9mIHRoZSBjb250ZXh0KVxuICAgICAgICogKHJldHVybnMgbnVsbCBvbiBubyBtYXRjaClcbiAgICAgICAqL1xuICAgICAgc2VhcmNoOiBjcmVhdGVMZWFmKFtcIi9pbmZvL2NvbnRleHRzXCJdLCBjb250ZXh0cyA9PiBiaW5hcnkgPT5cbiAgICAgICAgRGVjb2RlVXRpbHMuQ29udGV4dHMuZmluZERlYnVnZ2VyQ29udGV4dChjb250ZXh0cywgYmluYXJ5KVxuICAgICAgKVxuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogZXZtLnRyYW5zYWN0aW9uXG4gICAqL1xuICB0cmFuc2FjdGlvbjoge1xuICAgIC8qXG4gICAgICogZXZtLnRyYW5zYWN0aW9uLmdsb2JhbHNcbiAgICAgKi9cbiAgICBnbG9iYWxzOiB7XG4gICAgICAvKlxuICAgICAgICogZXZtLnRyYW5zYWN0aW9uLmdsb2JhbHMudHhcbiAgICAgICAqL1xuICAgICAgdHg6IGNyZWF0ZUxlYWYoW1wiL3N0YXRlXCJdLCBzdGF0ZSA9PiBzdGF0ZS50cmFuc2FjdGlvbi5nbG9iYWxzLnR4KSxcbiAgICAgIC8qXG4gICAgICAgKiBldm0udHJhbnNhY3Rpb24uZ2xvYmFscy5ibG9ja1xuICAgICAgICovXG4gICAgICBibG9jazogY3JlYXRlTGVhZihbXCIvc3RhdGVcIl0sIHN0YXRlID0+IHN0YXRlLnRyYW5zYWN0aW9uLmdsb2JhbHMuYmxvY2spXG4gICAgfSxcblxuICAgIC8qXG4gICAgICogZXZtLnRyYW5zYWN0aW9uLnN0YXR1c1xuICAgICAqL1xuICAgIHN0YXR1czogY3JlYXRlTGVhZihbXCIvc3RhdGVcIl0sIHN0YXRlID0+IHN0YXRlLnRyYW5zYWN0aW9uLnN0YXR1cyksXG5cbiAgICAvKlxuICAgICAqIGV2bS50cmFuc2FjdGlvbi5pbml0aWFsQ2FsbFxuICAgICAqL1xuICAgIGluaXRpYWxDYWxsOiBjcmVhdGVMZWFmKFtcIi9zdGF0ZVwiXSwgc3RhdGUgPT4gc3RhdGUudHJhbnNhY3Rpb24uaW5pdGlhbENhbGwpXG4gIH0sXG5cbiAgLyoqXG4gICAqIGV2bS5jdXJyZW50XG4gICAqL1xuICBjdXJyZW50OiB7XG4gICAgLyoqXG4gICAgICogZXZtLmN1cnJlbnQuY2FsbHN0YWNrXG4gICAgICovXG4gICAgY2FsbHN0YWNrOiBzdGF0ZSA9PiBzdGF0ZS5ldm0ucHJvYy5jYWxsc3RhY2ssXG5cbiAgICAvKipcbiAgICAgKiBldm0uY3VycmVudC5jYWxsXG4gICAgICovXG4gICAgY2FsbDogY3JlYXRlTGVhZihcbiAgICAgIFtcIi4vY2FsbHN0YWNrXCJdLFxuXG4gICAgICBzdGFjayA9PiAoc3RhY2subGVuZ3RoID8gc3RhY2tbc3RhY2subGVuZ3RoIC0gMV0gOiB7fSlcbiAgICApLFxuXG4gICAgLyoqXG4gICAgICogZXZtLmN1cnJlbnQuY29udGV4dFxuICAgICAqL1xuICAgIGNvbnRleHQ6IGNyZWF0ZUxlYWYoXG4gICAgICBbXG4gICAgICAgIFwiLi9jYWxsXCIsXG4gICAgICAgIFwiLi9jb2RleC9pbnN0YW5jZXNcIixcbiAgICAgICAgXCIvaW5mby9iaW5hcmllcy9zZWFyY2hcIixcbiAgICAgICAgXCIvaW5mby9jb250ZXh0c1wiXG4gICAgICBdLFxuICAgICAgKHsgYWRkcmVzcywgYmluYXJ5IH0sIGluc3RhbmNlcywgc2VhcmNoLCBjb250ZXh0cykgPT4ge1xuICAgICAgICBsZXQgY29udGV4dElkO1xuICAgICAgICBpZiAoYWRkcmVzcykge1xuICAgICAgICAgIC8vaWYgd2UncmUgaW4gYSBjYWxsIHRvIGEgZGVwbG95ZWQgY29udHJhY3QsIHdlIG11c3QgaGF2ZSByZWNvcmRlZFxuICAgICAgICAgIC8vdGhlIGNvbnRleHQgaW4gdGhlIGNvZGV4LCBzbyB3ZSBkb24ndCBuZWVkIHRvIGRvIGFueSBmdXJ0aGVyXG4gICAgICAgICAgLy9zZWFyY2hpbmdcbiAgICAgICAgICAoeyBjb250ZXh0OiBjb250ZXh0SWQsIGJpbmFyeSB9ID0gaW5zdGFuY2VzW2FkZHJlc3NdKTtcbiAgICAgICAgfSBlbHNlIGlmIChiaW5hcnkpIHtcbiAgICAgICAgICAvL290aGVyd2lzZSwgaWYgd2UncmUgaW4gYSBjb25zdHJ1Y3Rvciwgd2UnbGwgbmVlZCB0byBhY3R1YWxseSBkbyBhXG4gICAgICAgICAgLy9zZWFyY2hcbiAgICAgICAgICBjb250ZXh0SWQgPSBzZWFyY2goYmluYXJ5KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvL2V4Y2VwdGlvbmFsIGNhc2U6IG5vIHRyYW5zYWN0aW9uIGlzIGxvYWRlZFxuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNvbnRleHRJZCAhPSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAvL2lmIHdlIGZvdW5kIHRoZSBjb250ZXh0LCB1c2UgaXRcbiAgICAgICAgICBsZXQgY29udGV4dCA9IGNvbnRleHRzW2NvbnRleHRJZF07XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLmNvbnRleHQsXG4gICAgICAgICAgICBiaW5hcnlcbiAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vb3RoZXJ3aXNlIHdlJ2xsIGNvbnN0cnVjdCBzb21ldGhpbmcgZGVmYXVsdFxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBiaW5hcnksXG4gICAgICAgICAgICBpc0NvbnN0cnVjdG9yOiBhZGRyZXNzID09PSB1bmRlZmluZWRcbiAgICAgICAgICAgIC8vV0FSTklORzogd2UndmUgbXV0YXRlZCBiaW5hcnkgaGVyZSwgc29cbiAgICAgICAgICAgIC8vaW5zdGVhZCB3ZSBnbyBieSB3aGV0aGVyIGFkZHJlc3MgaXMgdW5kZWZpbmVkXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICksXG5cbiAgICAvKipcbiAgICAgKiBldm0uY3VycmVudC5zdGF0ZVxuICAgICAqXG4gICAgICogZXZtIHN0YXRlIGluZm86IGFzIG9mIGxhc3Qgb3BlcmF0aW9uLCBiZWZvcmUgb3AgZGVmaW5lZCBpbiBzdGVwXG4gICAgICovXG4gICAgc3RhdGU6IE9iamVjdC5hc3NpZ24oXG4gICAgICB7fSxcbiAgICAgIC4uLltcImRlcHRoXCIsIFwiZXJyb3JcIiwgXCJnYXNcIiwgXCJtZW1vcnlcIiwgXCJzdGFja1wiLCBcInN0b3JhZ2VcIl0ubWFwKHBhcmFtID0+ICh7XG4gICAgICAgIFtwYXJhbV06IGNyZWF0ZUxlYWYoW3RyYWNlLnN0ZXBdLCBzdGVwID0+IHN0ZXBbcGFyYW1dKVxuICAgICAgfSkpXG4gICAgKSxcblxuICAgIC8qKlxuICAgICAqIGV2bS5jdXJyZW50LnN0ZXBcbiAgICAgKi9cbiAgICBzdGVwOiB7XG4gICAgICAuLi5jcmVhdGVTdGVwU2VsZWN0b3JzKHRyYWNlLnN0ZXAsIFwiLi9zdGF0ZVwiKSxcblxuICAgICAgLy90aGUgZm9sbG93aW5nIHN0ZXAgc2VsZWN0b3JzIG9ubHkgZXhpc3QgZm9yIGN1cnJlbnQsIG5vdCBuZXh0IG9yIGFueVxuICAgICAgLy9vdGhlciBzdGVwXG5cbiAgICAgIC8qXG4gICAgICAgKiBldm0uY3VycmVudC5zdGVwLmNyZWF0ZWRBZGRyZXNzXG4gICAgICAgKlxuICAgICAgICogYWRkcmVzcyBjcmVhdGVkIGJ5IHRoZSBjdXJyZW50IGNyZWF0ZSBzdGVwXG4gICAgICAgKi9cbiAgICAgIGNyZWF0ZWRBZGRyZXNzOiBjcmVhdGVMZWFmKFxuICAgICAgICBbXCIuL2lzQ3JlYXRlXCIsIFwiL25leHRPZlNhbWVEZXB0aC9zdGF0ZS9zdGFja1wiXSxcbiAgICAgICAgKGlzQ3JlYXRlLCBzdGFjaykgPT4ge1xuICAgICAgICAgIGlmICghaXNDcmVhdGUpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgICBsZXQgYWRkcmVzcyA9IHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdO1xuICAgICAgICAgIHJldHVybiBEZWNvZGVVdGlscy5Db252ZXJzaW9uLnRvQWRkcmVzcyhhZGRyZXNzKTtcbiAgICAgICAgfVxuICAgICAgKSxcblxuICAgICAgLyoqXG4gICAgICAgKiBldm0uY3VycmVudC5zdGVwLmNhbGxzUHJlY29tcGlsZU9yRXh0ZXJuYWxcbiAgICAgICAqXG4gICAgICAgKiBhcmUgd2UgY2FsbGluZyBhIHByZWNvbXBpbGVkIGNvbnRyYWN0IG9yIGFuIGV4dGVybmFsbHktb3duZWQgYWNjb3VudCxcbiAgICAgICAqIHJhdGhlciB0aGFuIGEgY29udHJhY3QgYWNjb3VudCB0aGF0IGlzbid0IHByZWNvbXBpbGVkP1xuICAgICAgICovXG4gICAgICBjYWxsc1ByZWNvbXBpbGVPckV4dGVybmFsOiBjcmVhdGVMZWFmKFxuICAgICAgICBbXCIuL2lzQ2FsbFwiLCBcIi9jdXJyZW50L3N0YXRlL2RlcHRoXCIsIFwiL25leHQvc3RhdGUvZGVwdGhcIl0sXG4gICAgICAgIChjYWxscywgY3VycmVudERlcHRoLCBuZXh0RGVwdGgpID0+IGNhbGxzICYmIGN1cnJlbnREZXB0aCA9PT0gbmV4dERlcHRoXG4gICAgICApLFxuXG4gICAgICAvKipcbiAgICAgICAqIGV2bS5jdXJyZW50LnN0ZXAuaXNDb250ZXh0Q2hhbmdlXG4gICAgICAgKiBncm91cHMgdG9nZXRoZXIgY2FsbHMsIGNyZWF0ZXMsIGhhbHRzLCBhbmQgZXhjZXB0aW9uYWwgaGFsdHNcbiAgICAgICAqL1xuICAgICAgaXNDb250ZXh0Q2hhbmdlOiBjcmVhdGVMZWFmKFxuICAgICAgICBbXCIvY3VycmVudC9zdGF0ZS9kZXB0aFwiLCBcIi9uZXh0L3N0YXRlL2RlcHRoXCJdLFxuICAgICAgICAoY3VycmVudERlcHRoLCBuZXh0RGVwdGgpID0+IGN1cnJlbnREZXB0aCAhPT0gbmV4dERlcHRoXG4gICAgICApLFxuXG4gICAgICAvKipcbiAgICAgICAqIGV2bS5jdXJyZW50LnN0ZXAuaXNFeGNlcHRpb25hbEhhbHRpbmdcbiAgICAgICAqL1xuICAgICAgaXNFeGNlcHRpb25hbEhhbHRpbmc6IGNyZWF0ZUxlYWYoXG4gICAgICAgIFtcbiAgICAgICAgICBcIi4vaXNIYWx0aW5nXCIsXG4gICAgICAgICAgXCIvY3VycmVudC9zdGF0ZS9kZXB0aFwiLFxuICAgICAgICAgIFwiL25leHQvc3RhdGUvZGVwdGhcIixcbiAgICAgICAgICBcIi4vcmV0dXJuU3RhdHVzXCJcbiAgICAgICAgXSxcbiAgICAgICAgKGhhbHRpbmcsIGN1cnJlbnREZXB0aCwgbmV4dERlcHRoLCBzdGF0dXMpID0+XG4gICAgICAgICAgaGFsdGluZ1xuICAgICAgICAgICAgPyAhc3RhdHVzIC8vaWYgZGVsaWJlcmF0ZWx5IGhhbHRpbmcsIGNoZWNrIHRoZSByZXR1cm4gc3RhdHVzXG4gICAgICAgICAgICA6IG5leHREZXB0aCA8IGN1cnJlbnREZXB0aCAvL2lmIG5vdCBvbiBhIGRlbGliZXJhdGUgaGFsdCwgYW55IGhhbHRcbiAgICAgICAgLy9pcyBhbiBleGNlcHRpb25hbCBoYWx0XG4gICAgICApLFxuXG4gICAgICAvKipcbiAgICAgICAqIGV2bS5jdXJyZW50LnN0ZXAucmV0dXJuU3RhdHVzXG4gICAgICAgKiBjaGVja3MgdGhlIHJldHVybiBzdGF0dXMgb2YgdGhlICpjdXJyZW50KiBoYWx0aW5nIGluc3RydWN0aW9uIChmb3JcbiAgICAgICAqIG5vcm1hbCBoYWx0cyBvbmx5KVxuICAgICAgICogKHJldHVybnMgYSBib29sZWFuIC0tIHRydWUgZm9yIHN1Y2Nlc3MsIGZhbHNlIGZvciBmYWlsdXJlKVxuICAgICAgICovXG4gICAgICByZXR1cm5TdGF0dXM6IGNyZWF0ZUxlYWYoXG4gICAgICAgIFtcbiAgICAgICAgICBcIi4vaXNIYWx0aW5nXCIsXG4gICAgICAgICAgXCIvbmV4dC9zdGF0ZVwiLFxuICAgICAgICAgIHRyYWNlLnN0ZXBzUmVtYWluaW5nLFxuICAgICAgICAgIFwiL3RyYW5zYWN0aW9uL3N0YXR1c1wiXG4gICAgICAgIF0sXG4gICAgICAgIChpc0hhbHRpbmcsIHsgc3RhY2sgfSwgcmVtYWluaW5nLCBmaW5hbFN0YXR1cykgPT4ge1xuICAgICAgICAgIGlmICghaXNIYWx0aW5nKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDsgLy9ub3QgY2xlYXIgdGhpcydsbCBkbyBtdWNoIGdvb2Qgc2luY2UgdGhpcyBtYXkgZ2V0XG4gICAgICAgICAgICAvL3JlYWQgYXMgZmFsc2UsIGJ1dCwgb2ggd2VsbCwgbWF5IGFzIHdlbGxcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHJlbWFpbmluZyA8PSAxKSB7XG4gICAgICAgICAgICByZXR1cm4gZmluYWxTdGF0dXM7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IFpFUk9fV09SRCA9IFwiMDBcIi5yZXBlYXQoRGVjb2RlVXRpbHMuRVZNLldPUkRfU0laRSk7XG4gICAgICAgICAgICByZXR1cm4gc3RhY2tbc3RhY2subGVuZ3RoIC0gMV0gIT09IFpFUk9fV09SRDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIClcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogZXZtLmN1cnJlbnQuY29kZXggKG5hbWVzcGFjZSlcbiAgICAgKi9cbiAgICBjb2RleDoge1xuICAgICAgLyoqXG4gICAgICAgKiBldm0uY3VycmVudC5jb2RleCAoc2VsZWN0b3IpXG4gICAgICAgKiB0aGUgd2hvbGUgY29kZXghIG5vdCB0aGF0IHRoYXQncyB2ZXJ5IG11Y2ggYXQgdGhlIG1vbWVudFxuICAgICAgICovXG4gICAgICBfOiBjcmVhdGVMZWFmKFtcIi9zdGF0ZVwiXSwgc3RhdGUgPT4gc3RhdGUucHJvYy5jb2RleCksXG5cbiAgICAgIC8qKlxuICAgICAgICogZXZtLmN1cnJlbnQuY29kZXguc3RvcmFnZVxuICAgICAgICogdGhlIGN1cnJlbnQgc3RvcmFnZSwgYXMgZmV0Y2hlZCBmcm9tIHRoZSBjb2RleC4uLiB1bmxlc3Mgd2UncmUgaW4gYVxuICAgICAgICogZmFpbGVkIGNyZWF0aW9uIGNhbGwsIHRoZW4gd2UganVzdCBmYWxsIGJhY2sgb24gdGhlIHN0YXRlICh3aGljaCB3aWxsXG4gICAgICAgKiB3b3JrLCBzaW5jZSBub3RoaW5nIGVsc2UgY2FuIGludGVyZmVyZSB3aXRoIHRoZSBzdG9yYWdlIG9mIGEgZmFpbGVkXG4gICAgICAgKiBjcmVhdGlvbiBjYWxsISlcbiAgICAgICAqL1xuICAgICAgc3RvcmFnZTogY3JlYXRlTGVhZihcbiAgICAgICAgW1wiLi9fXCIsIFwiLi4vc3RhdGUvc3RvcmFnZVwiLCBcIi4uL2NhbGxcIl0sXG4gICAgICAgIChjb2RleCwgcmF3U3RvcmFnZSwgeyBzdG9yYWdlQWRkcmVzcyB9KSA9PlxuICAgICAgICAgIHN0b3JhZ2VBZGRyZXNzID09PSBEZWNvZGVVdGlscy5FVk0uWkVST19BRERSRVNTXG4gICAgICAgICAgICA/IHJhd1N0b3JhZ2UgLy9IQUNLIC0tIGlmIHplcm8gYWRkcmVzcyBpZ25vcmUgdGhlIGNvZGV4XG4gICAgICAgICAgICA6IGNvZGV4W2NvZGV4Lmxlbmd0aCAtIDFdLmFjY291bnRzW3N0b3JhZ2VBZGRyZXNzXS5zdG9yYWdlXG4gICAgICApLFxuXG4gICAgICAvKlxuICAgICAgICogZXZtLmN1cnJlbnQuY29kZXguaW5zdGFuY2VzXG4gICAgICAgKi9cbiAgICAgIGluc3RhbmNlczogY3JlYXRlTGVhZihbXCIuL19cIl0sIGNvZGV4ID0+XG4gICAgICAgIE9iamVjdC5hc3NpZ24oXG4gICAgICAgICAge30sXG4gICAgICAgICAgLi4uT2JqZWN0LmVudHJpZXMoY29kZXhbY29kZXgubGVuZ3RoIC0gMV0uYWNjb3VudHMpLm1hcChcbiAgICAgICAgICAgIChbYWRkcmVzcywgeyBjb2RlLCBjb250ZXh0IH1dKSA9PiAoe1xuICAgICAgICAgICAgICBbYWRkcmVzc106IHsgYWRkcmVzcywgYmluYXJ5OiBjb2RlLCBjb250ZXh0IH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgKVxuICAgICAgICApXG4gICAgICApXG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBldm0ubmV4dFxuICAgKi9cbiAgbmV4dDoge1xuICAgIC8qKlxuICAgICAqIGV2bS5uZXh0LnN0YXRlXG4gICAgICpcbiAgICAgKiBldm0gc3RhdGUgYXMgYSByZXN1bHQgb2YgbmV4dCBzdGVwIG9wZXJhdGlvblxuICAgICAqL1xuICAgIHN0YXRlOiBPYmplY3QuYXNzaWduKFxuICAgICAge30sXG4gICAgICAuLi5bXCJkZXB0aFwiLCBcImVycm9yXCIsIFwiZ2FzXCIsIFwibWVtb3J5XCIsIFwic3RhY2tcIiwgXCJzdG9yYWdlXCJdLm1hcChwYXJhbSA9PiAoe1xuICAgICAgICBbcGFyYW1dOiBjcmVhdGVMZWFmKFt0cmFjZS5uZXh0XSwgc3RlcCA9PiBzdGVwW3BhcmFtXSlcbiAgICAgIH0pKVxuICAgICksXG5cbiAgICAvKlxuICAgICAqIGV2bS5uZXh0LnN0ZXBcbiAgICAgKi9cbiAgICBzdGVwOiBjcmVhdGVTdGVwU2VsZWN0b3JzKHRyYWNlLm5leHQsIFwiLi9zdGF0ZVwiKVxuICB9LFxuXG4gIC8qKlxuICAgKiBldm0ubmV4dE9mU2FtZURlcHRoXG4gICAqL1xuICBuZXh0T2ZTYW1lRGVwdGg6IHtcbiAgICAvKipcbiAgICAgKiBldm0ubmV4dE9mU2FtZURlcHRoLnN0YXRlXG4gICAgICpcbiAgICAgKiBldm0gc3RhdGUgYXQgdGhlIG5leHQgc3RlcCBvZiBzYW1lIGRlcHRoXG4gICAgICovXG4gICAgc3RhdGU6IE9iamVjdC5hc3NpZ24oXG4gICAgICB7fSxcbiAgICAgIC4uLltcImRlcHRoXCIsIFwiZXJyb3JcIiwgXCJnYXNcIiwgXCJtZW1vcnlcIiwgXCJzdGFja1wiLCBcInN0b3JhZ2VcIl0ubWFwKHBhcmFtID0+ICh7XG4gICAgICAgIFtwYXJhbV06IGNyZWF0ZUxlYWYoW3RyYWNlLm5leHRPZlNhbWVEZXB0aF0sIHN0ZXAgPT4gc3RlcFtwYXJhbV0pXG4gICAgICB9KSlcbiAgICApXG4gIH1cbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBldm07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gbGliL2V2bS9zZWxlY3RvcnMvaW5kZXguanMiLCJpbXBvcnQgeyBjcmVhdGVTZWxlY3RvclRyZWUsIGNyZWF0ZUxlYWYgfSBmcm9tIFwicmVzZWxlY3QtdHJlZVwiO1xuXG5jb25zdCBQQVNUX0VORF9PRl9UUkFDRSA9IHtcbiAgZGVwdGg6IC0xLCAvL3RoaXMgaXMgdGhlIHBhcnQgdGhhdCBtYXR0ZXJzIVxuICAvL3RoZSByZXN0IG9mIHRoaXMgaXMganVzdCB0byBsb29rIGxpa2UgYSB0cmFjZSBzdGVwXG4gIGVycm9yOiBcIlwiLFxuICBnYXM6IDAsXG4gIG1lbW9yeTogW10sXG4gIHN0YWNrOiBbXSxcbiAgc3RvcmFnZToge30sXG4gIGdhc0Nvc3Q6IDAsXG4gIG9wOiBcIlNUT1BcIixcbiAgcGM6IC0xIC8vdGhpcyBpcyBub3QgYXQgYWxsIHZhbGlkIGJ1dCB0aGF0J3MgZmluZVxufTtcblxubGV0IHRyYWNlID0gY3JlYXRlU2VsZWN0b3JUcmVlKHtcbiAgLyoqXG4gICAqIHRyYWNlLmluZGV4XG4gICAqXG4gICAqIGN1cnJlbnQgc3RlcCBpbmRleFxuICAgKi9cbiAgaW5kZXg6IHN0YXRlID0+IHN0YXRlLnRyYWNlLnByb2MuaW5kZXgsXG5cbiAgLypcbiAgICogdHJhY2UubG9hZGVkXG4gICAqIGlzIGEgdHJhY2UgbG9hZGVkP1xuICAgKi9cbiAgbG9hZGVkOiBjcmVhdGVMZWFmKFtcIi9zdGVwc1wiXSwgc3RlcHMgPT4gc3RlcHMgIT09IG51bGwpLFxuXG4gIC8qKlxuICAgKiB0cmFjZS5maW5pc2hlZFxuICAgKiBpcyB0aGUgdHJhY2UgZmluaXNoZWQ/XG4gICAqL1xuICBmaW5pc2hlZDogc3RhdGUgPT4gc3RhdGUudHJhY2UucHJvYy5maW5pc2hlZCxcblxuICAvKipcbiAgICogdHJhY2UuZmluaXNoZWRPclVubG9hZGVkXG4gICAqXG4gICAqIGlzIHRoZSB0cmFjZSBmaW5pc2hlZCwgaW5jbHVkaW5nIGlmIGl0J3MgdW5sb2FkZWQ/XG4gICAqL1xuICBmaW5pc2hlZE9yVW5sb2FkZWQ6IGNyZWF0ZUxlYWYoXG4gICAgW1wiL2ZpbmlzaGVkXCIsIFwiL2xvYWRlZFwiXSxcbiAgICAoZmluaXNoZWQsIGxvYWRlZCkgPT4gZmluaXNoZWQgfHwgIWxvYWRlZFxuICApLFxuXG4gIC8qKlxuICAgKiB0cmFjZS5zdGVwc1xuICAgKlxuICAgKiBhbGwgdHJhY2Ugc3RlcHNcbiAgICovXG4gIHN0ZXBzOiBzdGF0ZSA9PiBzdGF0ZS50cmFjZS50cmFuc2FjdGlvbi5zdGVwcyxcblxuICAvKipcbiAgICogdHJhY2Uuc3RlcHNSZW1haW5pbmdcbiAgICpcbiAgICogbnVtYmVyIG9mIHN0ZXBzIHJlbWFpbmluZyBpbiB0cmFjZVxuICAgKi9cbiAgc3RlcHNSZW1haW5pbmc6IGNyZWF0ZUxlYWYoXG4gICAgW1wiLi9zdGVwc1wiLCBcIi4vaW5kZXhcIl0sXG4gICAgKHN0ZXBzLCBpbmRleCkgPT4gc3RlcHMubGVuZ3RoIC0gaW5kZXhcbiAgKSxcblxuICAvKipcbiAgICogdHJhY2Uuc3RlcFxuICAgKlxuICAgKiBjdXJyZW50IHRyYWNlIHN0ZXBcbiAgICovXG4gIHN0ZXA6IGNyZWF0ZUxlYWYoXG4gICAgW1wiLi9zdGVwc1wiLCBcIi4vaW5kZXhcIl0sXG4gICAgKHN0ZXBzLCBpbmRleCkgPT4gKHN0ZXBzID8gc3RlcHNbaW5kZXhdIDogbnVsbCkgLy9udWxsIGlmIG5vIHR4IGxvYWRlZFxuICApLFxuXG4gIC8qKlxuICAgKiB0cmFjZS5uZXh0XG4gICAqXG4gICAqIG5leHQgdHJhY2Ugc3RlcFxuICAgKiBIQUNLOiBpZiBhdCB0aGUgZW5kLFxuICAgKiB3ZSB3aWxsIHJldHVybiBhIHNwb29mZWQgXCJwYXN0IGVuZFwiIHN0ZXBcbiAgICovXG4gIG5leHQ6IGNyZWF0ZUxlYWYoXG4gICAgW1wiLi9zdGVwc1wiLCBcIi4vaW5kZXhcIl0sXG4gICAgKHN0ZXBzLCBpbmRleCkgPT5cbiAgICAgIGluZGV4IDwgc3RlcHMubGVuZ3RoIC0gMSA/IHN0ZXBzW2luZGV4ICsgMV0gOiBQQVNUX0VORF9PRl9UUkFDRVxuICApLFxuXG4gIC8qXG4gICAqIHRyYWNlLm5leHRPZlNhbWVEZXB0aFxuICAgKiBuZXh0IHRyYWNlIHN0ZXAgdGhhdCdzIGF0IHRoZSBzYW1lIGRlcHRoIGFzIHRoaXMgb25lXG4gICAqIE5PVEU6IGlmIHRoZXJlIGlzIG5vbmUsIHdpbGwgcmV0dXJuIHVuZGVmaW5lZFxuICAgKiAoc2hvdWxkIG5vdCBiZSB1c2VkIGluIHN1Y2ggY2FzZXMpXG4gICAqL1xuICBuZXh0T2ZTYW1lRGVwdGg6IGNyZWF0ZUxlYWYoW1wiLi9zdGVwc1wiLCBcIi4vaW5kZXhcIl0sIChzdGVwcywgaW5kZXgpID0+IHtcbiAgICBsZXQgZGVwdGggPSBzdGVwc1tpbmRleF0uZGVwdGg7XG4gICAgcmV0dXJuIHN0ZXBzLnNsaWNlKGluZGV4ICsgMSkuZmluZChzdGVwID0+IHN0ZXAuZGVwdGggPT09IGRlcHRoKTtcbiAgfSlcbn0pO1xuXG5leHBvcnQgZGVmYXVsdCB0cmFjZTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBsaWIvdHJhY2Uvc2VsZWN0b3JzL2luZGV4LmpzIiwiaW1wb3J0IGRlYnVnTW9kdWxlIGZyb20gXCJkZWJ1Z1wiO1xuY29uc3QgZGVidWcgPSBkZWJ1Z01vZHVsZShcImRlYnVnZ2VyOnNvbGlkaXR5OnNlbGVjdG9yc1wiKTtcblxuaW1wb3J0IHsgY3JlYXRlU2VsZWN0b3JUcmVlLCBjcmVhdGVMZWFmIH0gZnJvbSBcInJlc2VsZWN0LXRyZWVcIjtcbmltcG9ydCBTb2xpZGl0eVV0aWxzIGZyb20gXCJ0cnVmZmxlLXNvbGlkaXR5LXV0aWxzXCI7XG5pbXBvcnQgQ29kZVV0aWxzIGZyb20gXCJ0cnVmZmxlLWNvZGUtdXRpbHNcIjtcblxuaW1wb3J0IHsgZmluZFJhbmdlIH0gZnJvbSBcImxpYi9hc3QvbWFwXCI7XG5pbXBvcnQganNvbnBvaW50ZXIgZnJvbSBcImpzb24tcG9pbnRlclwiO1xuXG5pbXBvcnQgZXZtIGZyb20gXCJsaWIvZXZtL3NlbGVjdG9yc1wiO1xuaW1wb3J0IHRyYWNlIGZyb20gXCJsaWIvdHJhY2Uvc2VsZWN0b3JzXCI7XG5cbmZ1bmN0aW9uIGdldFNvdXJjZVJhbmdlKGluc3RydWN0aW9uID0ge30pIHtcbiAgcmV0dXJuIHtcbiAgICBzdGFydDogaW5zdHJ1Y3Rpb24uc3RhcnQgfHwgMCxcbiAgICBsZW5ndGg6IGluc3RydWN0aW9uLmxlbmd0aCB8fCAwLFxuICAgIGxpbmVzOiBpbnN0cnVjdGlvbi5yYW5nZSB8fCB7XG4gICAgICBzdGFydDoge1xuICAgICAgICBsaW5lOiAwLFxuICAgICAgICBjb2x1bW46IDBcbiAgICAgIH0sXG4gICAgICBlbmQ6IHtcbiAgICAgICAgbGluZTogMCxcbiAgICAgICAgY29sdW1uOiAwXG4gICAgICB9XG4gICAgfVxuICB9O1xufVxuXG4vL2Z1bmN0aW9uIHRvIGNyZWF0ZSBzZWxlY3RvcnMgdGhhdCBuZWVkIGJvdGggYSBjdXJyZW50IGFuZCBuZXh0IHZlcnNpb25cbmZ1bmN0aW9uIGNyZWF0ZU11bHRpc3RlcFNlbGVjdG9ycyhzdGVwU2VsZWN0b3IpIHtcbiAgcmV0dXJuIHtcbiAgICAvKipcbiAgICAgKiAuaW5zdHJ1Y3Rpb25cbiAgICAgKi9cbiAgICBpbnN0cnVjdGlvbjogY3JlYXRlTGVhZihcbiAgICAgIFtcIi9jdXJyZW50L2luc3RydWN0aW9uQXRQcm9ncmFtQ291bnRlclwiLCBzdGVwU2VsZWN0b3IucHJvZ3JhbUNvdW50ZXJdLFxuICAgICAgLy9IQUNLOiB3ZSB1c2Ugc29saWRpdHkuY3VycmVudC5pbnN0cnVjdGlvbkF0UHJvZ3JhbUNvdW50ZXJcbiAgICAgIC8vZXZlbiBpZiB3ZSdyZSBsb29raW5nIGF0IHNvbGlkaXR5Lm5leHQuXG4gICAgICAvL1RoaXMgaXMgaGFybWxlc3MuLi4gc28gbG9uZyBhcyB0aGUgY3VycmVudCBpbnN0cnVjdGlvbiBpc24ndCBhIGNvbnRleHRcbiAgICAgIC8vY2hhbmdlLiAgU28sIGRvbid0IHVzZSBzb2xpZGl0eS5uZXh0IHdoZW4gaXQgaXMuXG5cbiAgICAgIChtYXAsIHBjKSA9PiBtYXBbcGNdIHx8IHt9XG4gICAgKSxcblxuICAgIC8qKlxuICAgICAqIC5zb3VyY2VcbiAgICAgKi9cbiAgICBzb3VyY2U6IGNyZWF0ZUxlYWYoXG4gICAgICBbXCIvaW5mby9zb3VyY2VzXCIsIFwiLi9pbnN0cnVjdGlvblwiXSxcblxuICAgICAgKHNvdXJjZXMsIHsgZmlsZTogaWQgfSkgPT4gc291cmNlc1tpZF0gfHwge31cbiAgICApLFxuXG4gICAgLyoqXG4gICAgICogLnNvdXJjZVJhbmdlXG4gICAgICovXG4gICAgc291cmNlUmFuZ2U6IGNyZWF0ZUxlYWYoW1wiLi9pbnN0cnVjdGlvblwiXSwgZ2V0U291cmNlUmFuZ2UpLFxuXG4gICAgLyoqXG4gICAgICogLnBvaW50ZXJcbiAgICAgKi9cbiAgICBwb2ludGVyOiBjcmVhdGVMZWFmKFxuICAgICAgW1wiLi9zb3VyY2VcIiwgXCIuL3NvdXJjZVJhbmdlXCJdLFxuXG4gICAgICAoeyBhc3QgfSwgcmFuZ2UpID0+IGZpbmRSYW5nZShhc3QsIHJhbmdlLnN0YXJ0LCByYW5nZS5sZW5ndGgpXG4gICAgKSxcblxuICAgIC8qKlxuICAgICAqIC5ub2RlXG4gICAgICovXG4gICAgbm9kZTogY3JlYXRlTGVhZihcbiAgICAgIFtcIi4vc291cmNlXCIsIFwiLi9wb2ludGVyXCJdLFxuICAgICAgKHsgYXN0IH0sIHBvaW50ZXIpID0+XG4gICAgICAgIHBvaW50ZXIgPyBqc29ucG9pbnRlci5nZXQoYXN0LCBwb2ludGVyKSA6IGpzb25wb2ludGVyLmdldChhc3QsIFwiXCIpXG4gICAgKVxuICB9O1xufVxuXG5sZXQgc29saWRpdHkgPSBjcmVhdGVTZWxlY3RvclRyZWUoe1xuICAvKipcbiAgICogc29saWRpdHkuc3RhdGVcbiAgICovXG4gIHN0YXRlOiBzdGF0ZSA9PiBzdGF0ZS5zb2xpZGl0eSxcblxuICAvKipcbiAgICogc29saWRpdHkuaW5mb1xuICAgKi9cbiAgaW5mbzoge1xuICAgIC8qKlxuICAgICAqIHNvbGlkaXR5LmluZm8uc291cmNlc1xuICAgICAqL1xuICAgIHNvdXJjZXM6IGNyZWF0ZUxlYWYoW1wiL3N0YXRlXCJdLCBzdGF0ZSA9PiBzdGF0ZS5pbmZvLnNvdXJjZXMuYnlJZClcbiAgfSxcblxuICAvKipcbiAgICogc29saWRpdHkuY3VycmVudFxuICAgKi9cbiAgY3VycmVudDoge1xuICAgIC8qKlxuICAgICAqIHNvbGlkaXR5LmN1cnJlbnQuc291cmNlTWFwXG4gICAgICovXG4gICAgc291cmNlTWFwOiBjcmVhdGVMZWFmKFxuICAgICAgW2V2bS5jdXJyZW50LmNvbnRleHRdLFxuXG4gICAgICBjb250ZXh0ID0+IChjb250ZXh0ID8gY29udGV4dC5zb3VyY2VNYXAgOiBudWxsKSAvL251bGwgd2hlbiBubyB0eCBsb2FkZWRcbiAgICApLFxuXG4gICAgLyoqXG4gICAgICogc29saWRpdHkuY3VycmVudC5mdW5jdGlvbkRlcHRoU3RhY2tcbiAgICAgKi9cbiAgICBmdW5jdGlvbkRlcHRoU3RhY2s6IHN0YXRlID0+IHN0YXRlLnNvbGlkaXR5LnByb2MuZnVuY3Rpb25EZXB0aFN0YWNrLFxuXG4gICAgLyoqXG4gICAgICogc29saWRpdHkuY3VycmVudC5mdW5jdGlvbkRlcHRoXG4gICAgICovXG4gICAgZnVuY3Rpb25EZXB0aDogY3JlYXRlTGVhZihcbiAgICAgIFtcIi4vZnVuY3Rpb25EZXB0aFN0YWNrXCJdLFxuICAgICAgc3RhY2sgPT4gc3RhY2tbc3RhY2subGVuZ3RoIC0gMV1cbiAgICApLFxuXG4gICAgLyoqXG4gICAgICogc29saWRpdHkuY3VycmVudC5pbnN0cnVjdGlvbnNcbiAgICAgKi9cbiAgICBpbnN0cnVjdGlvbnM6IGNyZWF0ZUxlYWYoXG4gICAgICBbXCIvaW5mby9zb3VyY2VzXCIsIGV2bS5jdXJyZW50LmNvbnRleHQsIFwiLi9zb3VyY2VNYXBcIl0sXG5cbiAgICAgIChzb3VyY2VzLCBjb250ZXh0LCBzb3VyY2VNYXApID0+IHtcbiAgICAgICAgaWYgKCFjb250ZXh0KSB7XG4gICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICAgIGxldCBiaW5hcnkgPSBjb250ZXh0LmJpbmFyeTtcbiAgICAgICAgaWYgKCFiaW5hcnkpIHtcbiAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgbnVtSW5zdHJ1Y3Rpb25zO1xuICAgICAgICBpZiAoc291cmNlTWFwKSB7XG4gICAgICAgICAgbnVtSW5zdHJ1Y3Rpb25zID0gc291cmNlTWFwLnNwbGl0KFwiO1wiKS5sZW5ndGg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy9IQUNLXG4gICAgICAgICAgbnVtSW5zdHJ1Y3Rpb25zID0gKGJpbmFyeS5sZW5ndGggLSAyKSAvIDI7XG4gICAgICAgICAgLy90aGlzIGlzIGFjdHVhbGx5IGFuIG92ZXJlc3RpbWF0ZSwgYnV0IHRoYXQncyBPS1xuICAgICAgICB9XG5cbiAgICAgICAgLy9iZWNhdXNlIHdlIG1pZ2h0IGJlIGRlYWxpbmcgd2l0aCBhIGNvbnN0cnVjdG9yIHdpdGggYXJndW1lbnRzLCB3ZSBkb1xuICAgICAgICAvLypub3QqIHJlbW92ZSBtZXRhZGF0YSBtYW51YWxseVxuICAgICAgICBsZXQgaW5zdHJ1Y3Rpb25zID0gQ29kZVV0aWxzLnBhcnNlQ29kZShiaW5hcnksIG51bUluc3RydWN0aW9ucyk7XG5cbiAgICAgICAgaWYgKCFzb3VyY2VNYXApIHtcbiAgICAgICAgICAvLyBIQUNLXG4gICAgICAgICAgLy8gTGV0J3MgY3JlYXRlIGEgc291cmNlIG1hcCB0byB1c2Ugc2luY2Ugbm9uZSBleGlzdHMuIFRoaXMgc291cmNlXG4gICAgICAgICAgLy8gbWFwIG1hcHMganVzdCBhcyBtYW55IHJhbmdlcyBhcyB0aGVyZSBhcmUgaW5zdHJ1Y3Rpb25zIChvclxuICAgICAgICAgIC8vIHBvc3NpYmx5IG1vcmUpLCBhbmQgbWFya3MgdGhlbSBhbGwgYXMgYmVpbmcgU29saWRpdHktaW50ZXJuYWwgYW5kXG4gICAgICAgICAgLy8gbm90IGp1bXBzLlxuICAgICAgICAgIHNvdXJjZU1hcCA9XG4gICAgICAgICAgICBiaW5hcnkgIT09IFwiMHhcIlxuICAgICAgICAgICAgICA/IFwiMDowOi0xOi1cIi5jb25jYXQoXCI7XCIucmVwZWF0KGluc3RydWN0aW9ucy5sZW5ndGggLSAxKSlcbiAgICAgICAgICAgICAgOiBcIlwiO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGxpbmVBbmRDb2x1bW5NYXBwaW5ncyA9IE9iamVjdC5hc3NpZ24oXG4gICAgICAgICAge30sXG4gICAgICAgICAgLi4uT2JqZWN0LmVudHJpZXMoc291cmNlcykubWFwKChbaWQsIHsgc291cmNlIH1dKSA9PiAoe1xuICAgICAgICAgICAgW2lkXTogU29saWRpdHlVdGlscy5nZXRDaGFyYWN0ZXJPZmZzZXRUb0xpbmVBbmRDb2x1bW5NYXBwaW5nKFxuICAgICAgICAgICAgICBzb3VyY2UgfHwgXCJcIlxuICAgICAgICAgICAgKVxuICAgICAgICAgIH0pKVxuICAgICAgICApO1xuICAgICAgICB2YXIgaHVtYW5SZWFkYWJsZVNvdXJjZU1hcCA9IFNvbGlkaXR5VXRpbHMuZ2V0SHVtYW5SZWFkYWJsZVNvdXJjZU1hcChcbiAgICAgICAgICBzb3VyY2VNYXBcbiAgICAgICAgKTtcblxuICAgICAgICBsZXQgcHJpbWFyeUZpbGUgPSBodW1hblJlYWRhYmxlU291cmNlTWFwWzBdLmZpbGU7XG4gICAgICAgIGRlYnVnKFwicHJpbWFyeUZpbGUgJW9cIiwgcHJpbWFyeUZpbGUpO1xuXG4gICAgICAgIHJldHVybiBpbnN0cnVjdGlvbnNcbiAgICAgICAgICAubWFwKChpbnN0cnVjdGlvbiwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIC8vIGxvb2t1cCBzb3VyY2UgbWFwIGJ5IGluZGV4IGFuZCBhZGQgYGluZGV4YCBwcm9wZXJ0eSB0b1xuICAgICAgICAgICAgLy8gaW5zdHJ1Y3Rpb25cbiAgICAgICAgICAgIC8vXG5cbiAgICAgICAgICAgIGNvbnN0IHNvdXJjZU1hcCA9IGh1bWFuUmVhZGFibGVTb3VyY2VNYXBbaW5kZXhdIHx8IHt9O1xuXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICBpbnN0cnVjdGlvbjogeyAuLi5pbnN0cnVjdGlvbiwgaW5kZXggfSxcbiAgICAgICAgICAgICAgc291cmNlTWFwXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH0pXG4gICAgICAgICAgLm1hcCgoeyBpbnN0cnVjdGlvbiwgc291cmNlTWFwIH0pID0+IHtcbiAgICAgICAgICAgIC8vIGFkZCBzb3VyY2UgbWFwIGluZm9ybWF0aW9uIHRvIGluc3RydWN0aW9uLCBvciBkZWZhdWx0c1xuICAgICAgICAgICAgLy9cblxuICAgICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgICBqdW1wLFxuICAgICAgICAgICAgICBzdGFydCA9IDAsXG4gICAgICAgICAgICAgIGxlbmd0aCA9IDAsXG4gICAgICAgICAgICAgIGZpbGUgPSBwcmltYXJ5RmlsZVxuICAgICAgICAgICAgfSA9IHNvdXJjZU1hcDtcbiAgICAgICAgICAgIGNvbnN0IGxpbmVBbmRDb2x1bW5NYXBwaW5nID0gbGluZUFuZENvbHVtbk1hcHBpbmdzW2ZpbGVdIHx8IHt9O1xuICAgICAgICAgICAgY29uc3QgcmFuZ2UgPSB7XG4gICAgICAgICAgICAgIHN0YXJ0OiBsaW5lQW5kQ29sdW1uTWFwcGluZ1tzdGFydF0gfHwge1xuICAgICAgICAgICAgICAgIGxpbmU6IG51bGwsXG4gICAgICAgICAgICAgICAgY29sdW1uOiBudWxsXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIGVuZDogbGluZUFuZENvbHVtbk1hcHBpbmdbc3RhcnQgKyBsZW5ndGhdIHx8IHtcbiAgICAgICAgICAgICAgICBsaW5lOiBudWxsLFxuICAgICAgICAgICAgICAgIGNvbHVtbjogbnVsbFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBpZiAocmFuZ2Uuc3RhcnQubGluZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICBkZWJ1ZyhcInNvdXJjZU1hcCAlb1wiLCBzb3VyY2VNYXApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAuLi5pbnN0cnVjdGlvbixcblxuICAgICAgICAgICAgICBqdW1wLFxuICAgICAgICAgICAgICBzdGFydCxcbiAgICAgICAgICAgICAgbGVuZ3RoLFxuICAgICAgICAgICAgICBmaWxlLFxuICAgICAgICAgICAgICByYW5nZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9KTtcbiAgICAgIH1cbiAgICApLFxuXG4gICAgLyoqXG4gICAgICogc29saWRpdHkuY3VycmVudC5pbnN0cnVjdGlvbkF0UHJvZ3JhbUNvdW50ZXJcbiAgICAgKi9cbiAgICBpbnN0cnVjdGlvbkF0UHJvZ3JhbUNvdW50ZXI6IGNyZWF0ZUxlYWYoXG4gICAgICBbXCIuL2luc3RydWN0aW9uc1wiXSxcblxuICAgICAgaW5zdHJ1Y3Rpb25zID0+XG4gICAgICAgIE9iamVjdC5hc3NpZ24oXG4gICAgICAgICAge30sXG4gICAgICAgICAgLi4uaW5zdHJ1Y3Rpb25zLm1hcChpbnN0cnVjdGlvbiA9PiAoe1xuICAgICAgICAgICAgW2luc3RydWN0aW9uLnBjXTogaW5zdHJ1Y3Rpb25cbiAgICAgICAgICB9KSlcbiAgICAgICAgKVxuICAgICksXG5cbiAgICAuLi5jcmVhdGVNdWx0aXN0ZXBTZWxlY3RvcnMoZXZtLmN1cnJlbnQuc3RlcCksXG5cbiAgICAvKipcbiAgICAgKiBzb2xpZGl0eS5jdXJyZW50LmlzU291cmNlUmFuZ2VGaW5hbFxuICAgICAqL1xuICAgIGlzU291cmNlUmFuZ2VGaW5hbDogY3JlYXRlTGVhZihcbiAgICAgIFtcbiAgICAgICAgXCIuL2luc3RydWN0aW9uQXRQcm9ncmFtQ291bnRlclwiLFxuICAgICAgICBldm0uY3VycmVudC5zdGVwLnByb2dyYW1Db3VudGVyLFxuICAgICAgICBldm0ubmV4dC5zdGVwLnByb2dyYW1Db3VudGVyXG4gICAgICBdLFxuXG4gICAgICAobWFwLCBjdXJyZW50LCBuZXh0KSA9PiB7XG4gICAgICAgIGlmICghbWFwW25leHRdKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBjdXJyZW50ID0gbWFwW2N1cnJlbnRdO1xuICAgICAgICBuZXh0ID0gbWFwW25leHRdO1xuXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgY3VycmVudC5zdGFydCAhPSBuZXh0LnN0YXJ0IHx8XG4gICAgICAgICAgY3VycmVudC5sZW5ndGggIT0gbmV4dC5sZW5ndGggfHxcbiAgICAgICAgICBjdXJyZW50LmZpbGUgIT0gbmV4dC5maWxlXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgKSxcblxuICAgIC8qXG4gICAgICogc29saWRpdHkuY3VycmVudC5mdW5jdGlvbnNCeVByb2dyYW1Db3VudGVyXG4gICAgICovXG4gICAgZnVuY3Rpb25zQnlQcm9ncmFtQ291bnRlcjogY3JlYXRlTGVhZihcbiAgICAgIFtcIi4vaW5zdHJ1Y3Rpb25zXCIsIFwiL2luZm8vc291cmNlc1wiXSxcbiAgICAgIChpbnN0cnVjdGlvbnMsIHNvdXJjZXMpID0+XG4gICAgICAgIE9iamVjdC5hc3NpZ24oXG4gICAgICAgICAge30sXG4gICAgICAgICAgLi4uaW5zdHJ1Y3Rpb25zXG4gICAgICAgICAgICAuZmlsdGVyKGluc3RydWN0aW9uID0+IGluc3RydWN0aW9uLm5hbWUgPT09IFwiSlVNUERFU1RcIilcbiAgICAgICAgICAgIC5maWx0ZXIoaW5zdHJ1Y3Rpb24gPT4gaW5zdHJ1Y3Rpb24uZmlsZSAhPT0gLTEpXG4gICAgICAgICAgICAvL25vdGUgdGhhdCB0aGUgZGVzaWduYXRlZCBpbnZhbGlkIGZ1bmN0aW9uICpkb2VzKiBoYXZlIGFuIGFzc29jaWF0ZWRcbiAgICAgICAgICAgIC8vZmlsZSwgc28gaXQgKmlzKiBzYWZlIHRvIGp1c3QgZmlsdGVyIG91dCB0aGUgb25lcyB0aGF0IGRvbid0XG4gICAgICAgICAgICAubWFwKGluc3RydWN0aW9uID0+IHtcbiAgICAgICAgICAgICAgZGVidWcoXCJpbnN0cnVjdGlvbiAlT1wiLCBpbnN0cnVjdGlvbik7XG4gICAgICAgICAgICAgIGxldCBzb3VyY2UgPSBpbnN0cnVjdGlvbi5maWxlO1xuICAgICAgICAgICAgICBkZWJ1ZyhcInNvdXJjZSAlT1wiLCBzb3VyY2VzW3NvdXJjZV0pO1xuICAgICAgICAgICAgICBsZXQgYXN0ID0gc291cmNlc1tzb3VyY2VdLmFzdDtcbiAgICAgICAgICAgICAgbGV0IHJhbmdlID0gZ2V0U291cmNlUmFuZ2UoaW5zdHJ1Y3Rpb24pO1xuICAgICAgICAgICAgICBsZXQgcG9pbnRlciA9IGZpbmRSYW5nZShhc3QsIHJhbmdlLnN0YXJ0LCByYW5nZS5sZW5ndGgpO1xuICAgICAgICAgICAgICBsZXQgbm9kZSA9IHBvaW50ZXJcbiAgICAgICAgICAgICAgICA/IGpzb25wb2ludGVyLmdldChhc3QsIHBvaW50ZXIpXG4gICAgICAgICAgICAgICAgOiBqc29ucG9pbnRlci5nZXQoYXN0LCBcIlwiKTtcbiAgICAgICAgICAgICAgaWYgKCFub2RlIHx8IG5vZGUubm9kZVR5cGUgIT09IFwiRnVuY3Rpb25EZWZpbml0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICAvL2ZpbHRlciBvdXQgSlVNUERFU1RzIHRoYXQgYXJlbid0IGZ1bmN0aW9uIGRlZmluaXRpb25zLi4uXG4gICAgICAgICAgICAgICAgLy9leGNlcHQgZm9yIHRoZSBkZXNpZ25hdGVkIGludmFsaWQgZnVuY3Rpb25cbiAgICAgICAgICAgICAgICBsZXQgbmV4dEluc3RydWN0aW9uID0gaW5zdHJ1Y3Rpb25zW2luc3RydWN0aW9uLmluZGV4ICsgMV0gfHwge307XG4gICAgICAgICAgICAgICAgaWYgKG5leHRJbnN0cnVjdGlvbi5uYW1lID09PSBcIklOVkFMSURcIikge1xuICAgICAgICAgICAgICAgICAgLy9kZXNpZ25hdGVkIGludmFsaWQsIGluY2x1ZGUgaXRcbiAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIFtpbnN0cnVjdGlvbi5wY106IHtcbiAgICAgICAgICAgICAgICAgICAgICBpc0Rlc2lnbmF0ZWRJbnZhbGlkOiB0cnVlXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIC8vbm90IGRlc2lnbmF0ZWQgaW52YWxpZCwgZmlsdGVyIGl0IG91dFxuICAgICAgICAgICAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvL290aGVyd2lzZSwgd2UncmUgZ29vZCB0byBnbywgc28gbGV0J3MgZmluZCB0aGUgY29udHJhY3Qgbm9kZSBhbmRcbiAgICAgICAgICAgICAgLy9wdXQgaXQgYWxsIHRvZ2V0aGVyXG4gICAgICAgICAgICAgIC8vdG8gZ2V0IHRoZSBjb250cmFjdCBub2RlLCB3ZSBnbyB1cCB0d2ljZSBmcm9tIHRoZSBmdW5jdGlvbiBub2RlO1xuICAgICAgICAgICAgICAvL3RoZSBwYXRoIGZyb20gb25lIHRvIHRoZSBvdGhlciBzaG91bGQgaGF2ZSBhIHZlcnkgc3BlY2lmaWMgZm9ybSxcbiAgICAgICAgICAgICAgLy9zbyB0aGlzIGlzIGVhc3lcbiAgICAgICAgICAgICAgbGV0IGNvbnRyYWN0UG9pbnRlciA9IHBvaW50ZXIucmVwbGFjZSgvXFwvbm9kZXNcXC9cXGQrJC8sIFwiXCIpO1xuICAgICAgICAgICAgICBsZXQgY29udHJhY3ROb2RlID0ganNvbnBvaW50ZXIuZ2V0KGFzdCwgY29udHJhY3RQb2ludGVyKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBbaW5zdHJ1Y3Rpb24ucGNdOiB7XG4gICAgICAgICAgICAgICAgICBzb3VyY2UsXG4gICAgICAgICAgICAgICAgICBwb2ludGVyLFxuICAgICAgICAgICAgICAgICAgbm9kZSxcbiAgICAgICAgICAgICAgICAgIG5hbWU6IG5vZGUubmFtZSxcbiAgICAgICAgICAgICAgICAgIGlkOiBub2RlLmlkLFxuICAgICAgICAgICAgICAgICAgY29udHJhY3RQb2ludGVyLFxuICAgICAgICAgICAgICAgICAgY29udHJhY3ROb2RlLFxuICAgICAgICAgICAgICAgICAgY29udHJhY3ROYW1lOiBjb250cmFjdE5vZGUubmFtZSxcbiAgICAgICAgICAgICAgICAgIGNvbnRyYWN0SWQ6IGNvbnRyYWN0Tm9kZS5pZCxcbiAgICAgICAgICAgICAgICAgIGNvbnRyYWN0S2luZDogY29udHJhY3ROb2RlLmNvbnRyYWN0S2luZCxcbiAgICAgICAgICAgICAgICAgIGlzRGVzaWduYXRlZEludmFsaWQ6IGZhbHNlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSlcbiAgICAgICAgKVxuICAgICksXG5cbiAgICAvKipcbiAgICAgKiBzb2xpZGl0eS5jdXJyZW50LmlzTXVsdGlsaW5lXG4gICAgICovXG4gICAgaXNNdWx0aWxpbmU6IGNyZWF0ZUxlYWYoXG4gICAgICBbXCIuL3NvdXJjZVJhbmdlXCJdLFxuXG4gICAgICAoeyBsaW5lcyB9KSA9PiBsaW5lcy5zdGFydC5saW5lICE9IGxpbmVzLmVuZC5saW5lXG4gICAgKSxcblxuICAgIC8qKlxuICAgICAqIHNvbGlkaXR5LmN1cnJlbnQud2lsbEp1bXBcbiAgICAgKi9cbiAgICB3aWxsSnVtcDogY3JlYXRlTGVhZihbZXZtLmN1cnJlbnQuc3RlcC5pc0p1bXBdLCBpc0p1bXAgPT4gaXNKdW1wKSxcblxuICAgIC8qKlxuICAgICAqIHNvbGlkaXR5LmN1cnJlbnQuanVtcERpcmVjdGlvblxuICAgICAqL1xuICAgIGp1bXBEaXJlY3Rpb246IGNyZWF0ZUxlYWYoW1wiLi9pbnN0cnVjdGlvblwiXSwgKGkgPSB7fSkgPT4gaS5qdW1wIHx8IFwiLVwiKSxcblxuICAgIC8qKlxuICAgICAqIHNvbGlkaXR5LmN1cnJlbnQud2lsbENhbGxcbiAgICAgKi9cbiAgICB3aWxsQ2FsbDogY3JlYXRlTGVhZihbZXZtLmN1cnJlbnQuc3RlcC5pc0NhbGxdLCB4ID0+IHgpLFxuXG4gICAgLyoqXG4gICAgICogc29saWRpdHkuY3VycmVudC53aWxsQ3JlYXRlXG4gICAgICovXG4gICAgd2lsbENyZWF0ZTogY3JlYXRlTGVhZihbZXZtLmN1cnJlbnQuc3RlcC5pc0NyZWF0ZV0sIHggPT4geCksXG5cbiAgICAvKipcbiAgICAgKiBzb2xpZGl0eS5jdXJyZW50LmNhbGxzUHJlY29tcGlsZU9yRXh0ZXJuYWxcbiAgICAgKi9cbiAgICBjYWxsc1ByZWNvbXBpbGVPckV4dGVybmFsOiBjcmVhdGVMZWFmKFxuICAgICAgW2V2bS5jdXJyZW50LnN0ZXAuY2FsbHNQcmVjb21waWxlT3JFeHRlcm5hbF0sXG4gICAgICB4ID0+IHhcbiAgICApLFxuXG4gICAgLyoqXG4gICAgICogc29saWRpdHkuY3VycmVudC53aWxsUmV0dXJuXG4gICAgICovXG4gICAgd2lsbFJldHVybjogY3JlYXRlTGVhZihcbiAgICAgIFtldm0uY3VycmVudC5zdGVwLmlzSGFsdGluZ10sXG4gICAgICBpc0hhbHRpbmcgPT4gaXNIYWx0aW5nXG4gICAgKSxcblxuICAgIC8qKlxuICAgICAqIHNvbGlkaXR5LmN1cnJlbnQud2lsbEZhaWxcbiAgICAgKi9cbiAgICB3aWxsRmFpbDogY3JlYXRlTGVhZihbZXZtLmN1cnJlbnQuc3RlcC5pc0V4Y2VwdGlvbmFsSGFsdGluZ10sIHggPT4geCksXG5cbiAgICAvKlxuICAgICAqIHNvbGlkaXR5LmN1cnJlbnQubmV4dE1hcHBlZFxuICAgICAqIHJldHVybnMgdGhlIG5leHQgdHJhY2Ugc3RlcCBhZnRlciB0aGlzIG9uZSB3aGljaCBpcyBzb3VyY2VtYXBwZWRcbiAgICAgKiBIQUNLOiB0aGlzIGFzc3VtZXMgd2UncmUgbm90IGFib3V0IHRvIGNoYW5nZSBjb250ZXh0ISBkb24ndCB1c2UgdGhpcyBpZlxuICAgICAqIHdlIGFyZSFcbiAgICAgKiBBTFNPLCB0aGlzIG1heSByZXR1cm4gdW5kZWZpbmVkLCBzbyBiZSBwcmVwYXJlZCBmb3IgdGhhdFxuICAgICAqL1xuICAgIG5leHRNYXBwZWQ6IGNyZWF0ZUxlYWYoXG4gICAgICBbXCIuL2luc3RydWN0aW9uQXRQcm9ncmFtQ291bnRlclwiLCB0cmFjZS5zdGVwcywgdHJhY2UuaW5kZXhdLFxuICAgICAgKG1hcCwgc3RlcHMsIGluZGV4KSA9PlxuICAgICAgICBzdGVwcy5zbGljZShpbmRleCArIDEpLmZpbmQoKHsgcGMgfSkgPT4gbWFwW3BjXSAmJiBtYXBbcGNdLmZpbGUgIT09IC0xKVxuICAgIClcbiAgfSxcblxuICAvKipcbiAgICogc29saWRpdHkubmV4dFxuICAgKiBIQUNLIFdBUk5JTkc6IGRvIG5vdCB1c2UgdGhlc2Ugc2VsZWN0b3JzIHdoZW4gdGhlIGN1cnJlbnQgaW5zdHJ1Y3Rpb24gaXMgYVxuICAgKiBjb250ZXh0IGNoYW5nZSEgKGV2bSBjYWxsIG9yIGV2bSByZXR1cm4pXG4gICAqL1xuICBuZXh0OiBjcmVhdGVNdWx0aXN0ZXBTZWxlY3RvcnMoZXZtLm5leHQuc3RlcClcbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBzb2xpZGl0eTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBsaWIvc29saWRpdHkvc2VsZWN0b3JzL2luZGV4LmpzIiwiZXhwb3J0IGNvbnN0IFNBVkVfU1RFUFMgPSBcIlNBVkVfU1RFUFNcIjtcbmV4cG9ydCBmdW5jdGlvbiBzYXZlU3RlcHMoc3RlcHMpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBTQVZFX1NURVBTLFxuICAgIHN0ZXBzXG4gIH07XG59XG5cbmV4cG9ydCBjb25zdCBORVhUID0gXCJORVhUXCI7XG5leHBvcnQgZnVuY3Rpb24gbmV4dCgpIHtcbiAgcmV0dXJuIHsgdHlwZTogTkVYVCB9O1xufVxuXG5leHBvcnQgY29uc3QgVElDSyA9IFwiVElDS1wiO1xuZXhwb3J0IGZ1bmN0aW9uIHRpY2soKSB7XG4gIHJldHVybiB7IHR5cGU6IFRJQ0sgfTtcbn1cblxuZXhwb3J0IGNvbnN0IFRPQ0sgPSBcIlRPQ0tcIjtcbmV4cG9ydCBmdW5jdGlvbiB0b2NrKCkge1xuICByZXR1cm4geyB0eXBlOiBUT0NLIH07XG59XG5cbmV4cG9ydCBjb25zdCBFTkRfT0ZfVFJBQ0UgPSBcIkVPVFwiO1xuZXhwb3J0IGZ1bmN0aW9uIGVuZFRyYWNlKCkge1xuICByZXR1cm4geyB0eXBlOiBFTkRfT0ZfVFJBQ0UgfTtcbn1cblxuZXhwb3J0IGNvbnN0IFJFU0VUID0gXCJUUkFDRV9SRVNFVFwiO1xuZXhwb3J0IGZ1bmN0aW9uIHJlc2V0KCkge1xuICByZXR1cm4geyB0eXBlOiBSRVNFVCB9O1xufVxuXG5leHBvcnQgY29uc3QgVU5MT0FEX1RSQU5TQUNUSU9OID0gXCJUUkFDRV9VTkxPQURfVFJBTlNBQ1RJT05cIjtcbmV4cG9ydCBmdW5jdGlvbiB1bmxvYWRUcmFuc2FjdGlvbigpIHtcbiAgcmV0dXJuIHsgdHlwZTogVU5MT0FEX1RSQU5TQUNUSU9OIH07XG59XG5cbmV4cG9ydCBjb25zdCBCQUNLVElDSyA9IFwiQkFDS1RJQ0tcIjtcbmV4cG9ydCBmdW5jdGlvbiBiYWNrdGljaygpIHtcbiAgcmV0dXJuIHsgdHlwZTogQkFDS1RJQ0sgfTtcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBsaWIvdHJhY2UvYWN0aW9ucy9pbmRleC5qcyIsImltcG9ydCBkZWJ1Z01vZHVsZSBmcm9tIFwiZGVidWdcIjtcbmNvbnN0IGRlYnVnID0gZGVidWdNb2R1bGUoXCJkZWJ1Z2dlcjp0cmFjZTpzYWdhc1wiKTtcblxuaW1wb3J0IHsgdGFrZSwgdGFrZUV2ZXJ5LCBwdXQsIHNlbGVjdCB9IGZyb20gXCJyZWR1eC1zYWdhL2VmZmVjdHNcIjtcbmltcG9ydCB7IHByZWZpeE5hbWUsIGlzQ2FsbE1uZW1vbmljIH0gZnJvbSBcImxpYi9oZWxwZXJzXCI7XG5cbmltcG9ydCAqIGFzIERlY29kZVV0aWxzIGZyb20gXCJ0cnVmZmxlLWRlY29kZS11dGlsc1wiO1xuXG5pbXBvcnQgKiBhcyBhY3Rpb25zIGZyb20gXCIuLi9hY3Rpb25zXCI7XG5cbmltcG9ydCB0cmFjZSBmcm9tIFwiLi4vc2VsZWN0b3JzXCI7XG5cbmV4cG9ydCBmdW5jdGlvbiogYWR2YW5jZSgpIHtcbiAgeWllbGQgcHV0KGFjdGlvbnMubmV4dCgpKTtcblxuICBkZWJ1ZyhcIlRPQ0sgdG8gdGFrZVwiKTtcbiAgeWllbGQgdGFrZShbYWN0aW9ucy5UT0NLLCBhY3Rpb25zLkVORF9PRl9UUkFDRV0pO1xuICBkZWJ1ZyhcIlRPQ0sgdGFrZW5cIik7XG59XG5cbmNvbnN0IFNVQk1PRFVMRV9DT1VOVCA9IDM7IC8vZGF0YSwgZXZtLCBzb2xpZGl0eVxuXG5mdW5jdGlvbiogbmV4dCgpIHtcbiAgbGV0IHJlbWFpbmluZyA9IHlpZWxkIHNlbGVjdCh0cmFjZS5zdGVwc1JlbWFpbmluZyk7XG4gIGRlYnVnKFwicmVtYWluaW5nOiAlb1wiLCByZW1haW5pbmcpO1xuICBsZXQgc3RlcHMgPSB5aWVsZCBzZWxlY3QodHJhY2Uuc3RlcHMpO1xuICBkZWJ1ZyhcInRvdGFsIHN0ZXBzOiAlb1wiLCBzdGVwcy5sZW5ndGgpO1xuICBsZXQgd2FpdGluZ0ZvclN1Ym1vZHVsZXMgPSAwO1xuXG4gIGlmIChyZW1haW5pbmcgPiAwKSB7XG4gICAgZGVidWcoXCJwdXR0aW5nIFRJQ0tcIik7XG4gICAgLy8gdXBkYXRlcyBzdGF0ZSBmb3IgY3VycmVudCBzdGVwXG4gICAgd2FpdGluZ0ZvclN1Ym1vZHVsZXMgPSBTVUJNT0RVTEVfQ09VTlQ7XG4gICAgeWllbGQgcHV0KGFjdGlvbnMudGljaygpKTtcbiAgICBkZWJ1ZyhcInB1dCBUSUNLXCIpO1xuXG4gICAgLy93YWl0IGZvciBhbGwgYmFja3RpY2tzIGJlZm9yZSBjb250aW51aW5nXG4gICAgd2hpbGUgKHdhaXRpbmdGb3JTdWJtb2R1bGVzID4gMCkge1xuICAgICAgeWllbGQgdGFrZShhY3Rpb25zLkJBQ0tUSUNLKTtcbiAgICAgIGRlYnVnKFwiZ290IEJBQ0tUSUNLXCIpO1xuICAgICAgd2FpdGluZ0ZvclN1Ym1vZHVsZXMtLTtcbiAgICB9XG5cbiAgICByZW1haW5pbmctLTsgLy8gbG9jYWwgdXBkYXRlLCBqdXN0IGZvciBjb252ZW5pZW5jZVxuICB9XG5cbiAgaWYgKHJlbWFpbmluZykge1xuICAgIGRlYnVnKFwicHV0dGluZyBUT0NLXCIpO1xuICAgIC8vIHVwZGF0ZXMgc3RlcCB0byBuZXh0IHN0ZXAgaW4gdHJhY2VcbiAgICB5aWVsZCBwdXQoYWN0aW9ucy50b2NrKCkpO1xuICAgIGRlYnVnKFwicHV0IFRPQ0tcIik7XG4gIH0gZWxzZSB7XG4gICAgZGVidWcoXCJwdXR0aW5nIEVORF9PRl9UUkFDRVwiKTtcbiAgICB5aWVsZCBwdXQoYWN0aW9ucy5lbmRUcmFjZSgpKTtcbiAgICBkZWJ1ZyhcInB1dCBFTkRfT0ZfVFJBQ0VcIik7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uKiBzaWduYWxUaWNrU2FnYUNvbXBsZXRpb24oKSB7XG4gIHlpZWxkIHB1dChhY3Rpb25zLmJhY2t0aWNrKCkpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24qIHByb2Nlc3NUcmFjZShzdGVwcykge1xuICB5aWVsZCBwdXQoYWN0aW9ucy5zYXZlU3RlcHMoc3RlcHMpKTtcblxuICBsZXQgYWRkcmVzc2VzID0gW1xuICAgIC4uLm5ldyBTZXQoXG4gICAgICBzdGVwc1xuICAgICAgICAubWFwKFxuICAgICAgICAgICh7IG9wLCBzdGFjayB9KSA9PlxuICAgICAgICAgICAgaXNDYWxsTW5lbW9uaWMob3ApXG4gICAgICAgICAgICAgID8gLy9pZiBpdCdzIGEgY2FsbCwganVzdCBmZXRjaCB0aGUgYWRkcmVzcyBvZmYgdGhlIHN0YWNrXG4gICAgICAgICAgICAgICAgRGVjb2RlVXRpbHMuQ29udmVyc2lvbi50b0FkZHJlc3Moc3RhY2tbc3RhY2subGVuZ3RoIC0gMl0pXG4gICAgICAgICAgICAgIDogLy9pZiBpdCdzIG5vdCBhIGNhbGwsIGp1c3QgcmV0dXJuIHVuZGVmaW5lZCAod2UndmUgZ29uZSBiYWNrIHRvXG4gICAgICAgICAgICAgICAgLy9za2lwcGluZyBjcmVhdGVzKVxuICAgICAgICAgICAgICAgIHVuZGVmaW5lZFxuICAgICAgICApXG4gICAgICAgIC8vZmlsdGVyIG91dCB6ZXJvIGFkZHJlc3NlcyBmcm9tIGZhaWxlZCBjcmVhdGVzIChhcyB3ZWxsIGFzIHVuZGVmaW5lZHMpXG4gICAgICAgIC5maWx0ZXIoXG4gICAgICAgICAgYWRkcmVzcyA9PlxuICAgICAgICAgICAgYWRkcmVzcyAhPT0gdW5kZWZpbmVkICYmIGFkZHJlc3MgIT09IERlY29kZVV0aWxzLkVWTS5aRVJPX0FERFJFU1NcbiAgICAgICAgKVxuICAgIClcbiAgXTtcblxuICByZXR1cm4gYWRkcmVzc2VzO1xufVxuXG5leHBvcnQgZnVuY3Rpb24qIHJlc2V0KCkge1xuICB5aWVsZCBwdXQoYWN0aW9ucy5yZXNldCgpKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uKiB1bmxvYWQoKSB7XG4gIHlpZWxkIHB1dChhY3Rpb25zLnVubG9hZFRyYW5zYWN0aW9uKCkpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24qIHNhZ2EoKSB7XG4gIHlpZWxkIHRha2VFdmVyeShhY3Rpb25zLk5FWFQsIG5leHQpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBwcmVmaXhOYW1lKFwidHJhY2VcIiwgc2FnYSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gbGliL3RyYWNlL3NhZ2FzL2luZGV4LmpzIiwiZXhwb3J0IGNvbnN0IFNUQVJUID0gXCJTRVNTSU9OX1NUQVJUXCI7XG5leHBvcnQgZnVuY3Rpb24gc3RhcnQocHJvdmlkZXIsIHR4SGFzaCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFNUQVJULFxuICAgIHByb3ZpZGVyLFxuICAgIHR4SGFzaCAvL09QVElPTkFMXG4gIH07XG59XG5cbmV4cG9ydCBjb25zdCBMT0FEX1RSQU5TQUNUSU9OID0gXCJMT0FEX1RSQU5TQUNUSU9OXCI7XG5leHBvcnQgZnVuY3Rpb24gbG9hZFRyYW5zYWN0aW9uKHR4SGFzaCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IExPQURfVFJBTlNBQ1RJT04sXG4gICAgdHhIYXNoXG4gIH07XG59XG5cbmV4cG9ydCBjb25zdCBJTlRFUlJVUFQgPSBcIlNFU1NJT05fSU5URVJSVVBUXCI7XG5leHBvcnQgZnVuY3Rpb24gaW50ZXJydXB0KCkge1xuICByZXR1cm4geyB0eXBlOiBJTlRFUlJVUFQgfTtcbn1cblxuZXhwb3J0IGNvbnN0IFVOTE9BRF9UUkFOU0FDVElPTiA9IFwiVU5MT0FEX1RSQU5TQUNUSU9OXCI7XG5leHBvcnQgZnVuY3Rpb24gdW5sb2FkVHJhbnNhY3Rpb24oKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogVU5MT0FEX1RSQU5TQUNUSU9OXG4gIH07XG59XG5cbmV4cG9ydCBjb25zdCBSRUFEWSA9IFwiU0VTU0lPTl9SRUFEWVwiO1xuZXhwb3J0IGZ1bmN0aW9uIHJlYWR5KCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFJFQURZXG4gIH07XG59XG5cbmV4cG9ydCBjb25zdCBXQUlUID0gXCJTRVNTSU9OX1dBSVRcIjtcbmV4cG9ydCBmdW5jdGlvbiB3YWl0KCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFdBSVRcbiAgfTtcbn1cblxuZXhwb3J0IGNvbnN0IEVSUk9SID0gXCJTRVNTSU9OX0VSUk9SXCI7XG5leHBvcnQgZnVuY3Rpb24gZXJyb3IoZXJyb3IpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBFUlJPUixcbiAgICBlcnJvclxuICB9O1xufVxuXG5leHBvcnQgY29uc3QgQ0xFQVJfRVJST1IgPSBcIkNMRUFSX0VSUk9SXCI7XG5leHBvcnQgZnVuY3Rpb24gY2xlYXJFcnJvcigpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBDTEVBUl9FUlJPUlxuICB9O1xufVxuXG5leHBvcnQgY29uc3QgUkVDT1JEX0NPTlRSQUNUUyA9IFwiUkVDT1JEX0NPTlRSQUNUU1wiO1xuZXhwb3J0IGZ1bmN0aW9uIHJlY29yZENvbnRyYWN0cyhjb250ZXh0cywgc291cmNlcykge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFJFQ09SRF9DT05UUkFDVFMsXG4gICAgY29udGV4dHMsXG4gICAgc291cmNlc1xuICB9O1xufVxuXG5leHBvcnQgY29uc3QgU0FWRV9UUkFOU0FDVElPTiA9IFwiU0FWRV9UUkFOU0FDVElPTlwiO1xuZXhwb3J0IGZ1bmN0aW9uIHNhdmVUcmFuc2FjdGlvbih0cmFuc2FjdGlvbikge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFNBVkVfVFJBTlNBQ1RJT04sXG4gICAgdHJhbnNhY3Rpb25cbiAgfTtcbn1cblxuZXhwb3J0IGNvbnN0IFNBVkVfUkVDRUlQVCA9IFwiU0FWRV9SRUNFSVBUXCI7XG5leHBvcnQgZnVuY3Rpb24gc2F2ZVJlY2VpcHQocmVjZWlwdCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFNBVkVfUkVDRUlQVCxcbiAgICByZWNlaXB0XG4gIH07XG59XG5cbmV4cG9ydCBjb25zdCBTQVZFX0JMT0NLID0gXCJTQVZFX0JMT0NLXCI7XG5leHBvcnQgZnVuY3Rpb24gc2F2ZUJsb2NrKGJsb2NrKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogU0FWRV9CTE9DSyxcbiAgICBibG9ja1xuICB9O1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIGxpYi9zZXNzaW9uL2FjdGlvbnMvaW5kZXguanMiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJibi5qc1wiKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBleHRlcm5hbCBcImJuLmpzXCJcbi8vIG1vZHVsZSBpZCA9IDE1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcImJhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3Qva2V5c1wiKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBleHRlcm5hbCBcImJhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3Qva2V5c1wiXG4vLyBtb2R1bGUgaWQgPSAxNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgZGVidWdNb2R1bGUgZnJvbSBcImRlYnVnXCI7XG5jb25zdCBkZWJ1ZyA9IGRlYnVnTW9kdWxlKFwiZGVidWdnZXI6ZGF0YTpzYWdhc1wiKTtcblxuaW1wb3J0IHsgcHV0LCB0YWtlRXZlcnksIHNlbGVjdCB9IGZyb20gXCJyZWR1eC1zYWdhL2VmZmVjdHNcIjtcblxuaW1wb3J0IHsgcHJlZml4TmFtZSwgc3RhYmxlS2VjY2FrMjU2LCBtYWtlQXNzaWdubWVudCB9IGZyb20gXCJsaWIvaGVscGVyc1wiO1xuXG5pbXBvcnQgeyBUSUNLIH0gZnJvbSBcImxpYi90cmFjZS9hY3Rpb25zXCI7XG5pbXBvcnQgKiBhcyBhY3Rpb25zIGZyb20gXCIuLi9hY3Rpb25zXCI7XG5pbXBvcnQgKiBhcyB0cmFjZSBmcm9tIFwibGliL3RyYWNlL3NhZ2FzXCI7XG5pbXBvcnQgKiBhcyBldm0gZnJvbSBcImxpYi9ldm0vc2FnYXNcIjtcbmltcG9ydCAqIGFzIHdlYjMgZnJvbSBcImxpYi93ZWIzL3NhZ2FzXCI7XG5cbmltcG9ydCBkYXRhIGZyb20gXCIuLi9zZWxlY3RvcnNcIjtcblxuaW1wb3J0IHN1bSBmcm9tIFwibG9kYXNoLnN1bVwiO1xuXG5pbXBvcnQgKiBhcyBEZWNvZGVVdGlscyBmcm9tIFwidHJ1ZmZsZS1kZWNvZGUtdXRpbHNcIjtcbmltcG9ydCB7XG4gIGdldFN0b3JhZ2VBbGxvY2F0aW9ucyxcbiAgZ2V0TWVtb3J5QWxsb2NhdGlvbnMsXG4gIGdldENhbGxkYXRhQWxsb2NhdGlvbnMsXG4gIHJlYWRTdGFjayxcbiAgc3RvcmFnZVNpemUsXG4gIGZvckV2bVN0YXRlXG59IGZyb20gXCJ0cnVmZmxlLWRlY29kZXJcIjtcbmltcG9ydCBCTiBmcm9tIFwiYm4uanNcIjtcblxuZXhwb3J0IGZ1bmN0aW9uKiBzY29wZShub2RlSWQsIHBvaW50ZXIsIHBhcmVudElkLCBzb3VyY2VJZCkge1xuICB5aWVsZCBwdXQoYWN0aW9ucy5zY29wZShub2RlSWQsIHBvaW50ZXIsIHBhcmVudElkLCBzb3VyY2VJZCkpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24qIGRlY2xhcmUobm9kZSkge1xuICB5aWVsZCBwdXQoYWN0aW9ucy5kZWNsYXJlKG5vZGUpKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uKiBkZWZpbmVUeXBlKG5vZGUpIHtcbiAgeWllbGQgcHV0KGFjdGlvbnMuZGVmaW5lVHlwZShub2RlKSk7XG59XG5cbmZ1bmN0aW9uKiB0aWNrU2FnYSgpIHtcbiAgZGVidWcoXCJnb3QgVElDS1wiKTtcblxuICB5aWVsZCogdmFyaWFibGVzQW5kTWFwcGluZ3NTYWdhKCk7XG4gIGRlYnVnKFwiYWJvdXQgdG8gU1VCVE9DS1wiKTtcbiAgeWllbGQqIHRyYWNlLnNpZ25hbFRpY2tTYWdhQ29tcGxldGlvbigpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24qIGRlY29kZShkZWZpbml0aW9uLCByZWYpIHtcbiAgbGV0IHJlZmVyZW5jZURlY2xhcmF0aW9ucyA9IHlpZWxkIHNlbGVjdChkYXRhLnZpZXdzLnJlZmVyZW5jZURlY2xhcmF0aW9ucyk7XG4gIGxldCBzdGF0ZSA9IHlpZWxkIHNlbGVjdChkYXRhLmN1cnJlbnQuc3RhdGUpO1xuICBsZXQgbWFwcGluZ0tleXMgPSB5aWVsZCBzZWxlY3QoZGF0YS52aWV3cy5tYXBwaW5nS2V5cyk7XG4gIGxldCBhbGxvY2F0aW9ucyA9IHlpZWxkIHNlbGVjdChkYXRhLmluZm8uYWxsb2NhdGlvbnMpO1xuICBsZXQgaW5zdGFuY2VzID0geWllbGQgc2VsZWN0KGRhdGEudmlld3MuaW5zdGFuY2VzKTtcbiAgbGV0IGNvbnRleHRzID0geWllbGQgc2VsZWN0KGRhdGEudmlld3MuY29udGV4dHMpO1xuICBsZXQgY3VycmVudENvbnRleHQgPSB5aWVsZCBzZWxlY3QoZGF0YS5jdXJyZW50LmNvbnRleHQpO1xuICBsZXQgaW50ZXJuYWxGdW5jdGlvbnNUYWJsZSA9IHlpZWxkIHNlbGVjdChcbiAgICBkYXRhLmN1cnJlbnQuZnVuY3Rpb25zQnlQcm9ncmFtQ291bnRlclxuICApO1xuICBsZXQgYmxvY2tOdW1iZXIgPSB5aWVsZCBzZWxlY3QoZGF0YS52aWV3cy5ibG9ja051bWJlcik7XG5cbiAgbGV0IFpFUk9fV09SRCA9IG5ldyBVaW50OEFycmF5KERlY29kZVV0aWxzLkVWTS5XT1JEX1NJWkUpO1xuICBaRVJPX1dPUkQuZmlsbCgwKTtcbiAgbGV0IE5PX0NPREUgPSBuZXcgVWludDhBcnJheSgpOyAvL2VtcHR5IGFycmF5XG5cbiAgbGV0IGRlY29kZXIgPSBmb3JFdm1TdGF0ZShkZWZpbml0aW9uLCByZWYsIHtcbiAgICByZWZlcmVuY2VEZWNsYXJhdGlvbnMsXG4gICAgc3RhdGUsXG4gICAgbWFwcGluZ0tleXMsXG4gICAgc3RvcmFnZUFsbG9jYXRpb25zOiBhbGxvY2F0aW9ucy5zdG9yYWdlLFxuICAgIG1lbW9yeUFsbG9jYXRpb25zOiBhbGxvY2F0aW9ucy5tZW1vcnksXG4gICAgY2FsbGRhdGFBbGxvY2F0aW9uczogYWxsb2NhdGlvbnMuY2FsbGRhdGEsXG4gICAgY29udGV4dHMsXG4gICAgY3VycmVudENvbnRleHQsXG4gICAgaW50ZXJuYWxGdW5jdGlvbnNUYWJsZVxuICB9KTtcblxuICBsZXQgcmVzdWx0ID0gZGVjb2Rlci5uZXh0KCk7XG4gIHdoaWxlICghcmVzdWx0LmRvbmUpIHtcbiAgICBsZXQgcmVxdWVzdCA9IHJlc3VsdC52YWx1ZTtcbiAgICBsZXQgcmVzcG9uc2U7XG4gICAgc3dpdGNoIChyZXF1ZXN0LnR5cGUpIHtcbiAgICAgIGNhc2UgXCJzdG9yYWdlXCI6XG4gICAgICAgIC8vdGhlIGRlYnVnZ2VyIHN1cHBsaWVzIGFsbCBzdG9yYWdlIGl0IGtub3dzIGF0IHRoZSBiZWdpbm5pbmcuXG4gICAgICAgIC8vYW55IHN0b3JhZ2UgaXQgZG9lcyBub3Qga25vdyBpcyBwcmVzdW1lZCB0byBiZSB6ZXJvLlxuICAgICAgICByZXNwb25zZSA9IFpFUk9fV09SRDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiY29kZVwiOlxuICAgICAgICBsZXQgYWRkcmVzcyA9IHJlcXVlc3QuYWRkcmVzcztcbiAgICAgICAgaWYgKGFkZHJlc3MgaW4gaW5zdGFuY2VzKSB7XG4gICAgICAgICAgcmVzcG9uc2UgPSBpbnN0YW5jZXNbYWRkcmVzc107XG4gICAgICAgIH0gZWxzZSBpZiAoYWRkcmVzcyA9PT0gRGVjb2RlVXRpbHMuRVZNLlpFUk9fQUREUkVTUykge1xuICAgICAgICAgIC8vSEFDSzogdG8gYXZvaWQgZGlzcGxheWluZyB0aGUgemVybyBhZGRyZXNzIHRvIHRoZSB1c2VyIGFzIGFuXG4gICAgICAgICAgLy9hZmZlY3RlZCBhZGRyZXNzIGp1c3QgYmVjYXVzZSB0aGV5IGRlY29kZWQgYSBjb250cmFjdCBvciBleHRlcm5hbFxuICAgICAgICAgIC8vZnVuY3Rpb24gdmFyaWFibGUgdGhhdCBoYWRuJ3QgYmVlbiBpbml0aWFsaXplZCB5ZXQsIHdlIGdpdmUgdGhlXG4gICAgICAgICAgLy96ZXJvIGFkZHJlc3MncyBjb2RlbGVzc25lc3MgaXRzIG93biBwcml2YXRlIGNhY2hlIDpQXG4gICAgICAgICAgcmVzcG9uc2UgPSBOT19DT0RFO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vSSBkb24ndCB3YW50IHRvIHdyaXRlIGEgbmV3IHdlYjMgc2FnYSwgc28gbGV0J3MganVzdCB1c2VcbiAgICAgICAgICAvL29idGFpbkJpbmFyaWVzIHdpdGggYSBvbmUtZWxlbWVudCBhcnJheVxuICAgICAgICAgIGRlYnVnKFwiZmV0Y2hpbmcgYmluYXJ5XCIpO1xuICAgICAgICAgIGxldCBiaW5hcnkgPSAoeWllbGQqIHdlYjMub2J0YWluQmluYXJpZXMoW2FkZHJlc3NdLCBibG9ja051bWJlcikpWzBdO1xuICAgICAgICAgIGRlYnVnKFwiYWRkaW5nIGluc3RhbmNlXCIpO1xuICAgICAgICAgIHlpZWxkKiBldm0uYWRkSW5zdGFuY2UoYWRkcmVzcywgYmluYXJ5KTtcbiAgICAgICAgICByZXNwb25zZSA9IERlY29kZVV0aWxzLkNvbnZlcnNpb24udG9CeXRlcyhiaW5hcnkpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgZGVidWcoXCJ1bnJlY29nbml6ZWQgcmVxdWVzdCB0eXBlIVwiKTtcbiAgICB9XG4gICAgcmVzdWx0ID0gZGVjb2Rlci5uZXh0KHJlc3BvbnNlKTtcbiAgfVxuICAvL2F0IHRoaXMgcG9pbnQsIHJlc3VsdC52YWx1ZSBob2xkcyB0aGUgZmluYWwgdmFsdWVcbiAgLy9ub3RlOiB3ZSdyZSBzdGlsbCB1c2luZyB0aGUgb2xkIGRlY29kZXIgb3V0cHV0IGZvcm1hdCwgc28gd2UgbmVlZCB0byBjbGVhblxuICAvL2NvbnRhaW5lcnMgYmVmb3JlIHJldHVybmluZyBzb21ldGhpbmcgdGhlIGRlYnVnZ2VyIGNhbiB1c2VcbiAgcmV0dXJuIERlY29kZVV0aWxzLkNvbnZlcnNpb24uY2xlYW5Db250YWluZXJzKHJlc3VsdC52YWx1ZSk7XG59XG5cbmZ1bmN0aW9uKiB2YXJpYWJsZXNBbmRNYXBwaW5nc1NhZ2EoKSB7XG4gIGxldCBub2RlID0geWllbGQgc2VsZWN0KGRhdGEuY3VycmVudC5ub2RlKTtcbiAgbGV0IHNjb3BlcyA9IHlpZWxkIHNlbGVjdChkYXRhLnZpZXdzLnNjb3Blcy5pbmxpbmVkKTtcbiAgbGV0IHJlZmVyZW5jZURlY2xhcmF0aW9ucyA9IHlpZWxkIHNlbGVjdChkYXRhLnZpZXdzLnJlZmVyZW5jZURlY2xhcmF0aW9ucyk7XG4gIGxldCBhbGxvY2F0aW9ucyA9IHlpZWxkIHNlbGVjdChkYXRhLmluZm8uYWxsb2NhdGlvbnMuc3RvcmFnZSk7XG4gIGxldCBjdXJyZW50QXNzaWdubWVudHMgPSB5aWVsZCBzZWxlY3QoZGF0YS5wcm9jLmFzc2lnbm1lbnRzKTtcbiAgbGV0IG1hcHBlZFBhdGhzID0geWllbGQgc2VsZWN0KGRhdGEucHJvYy5tYXBwZWRQYXRocyk7XG4gIGxldCBjdXJyZW50RGVwdGggPSB5aWVsZCBzZWxlY3QoZGF0YS5jdXJyZW50LmZ1bmN0aW9uRGVwdGgpO1xuICBsZXQgYWRkcmVzcyA9IHlpZWxkIHNlbGVjdChkYXRhLmN1cnJlbnQuYWRkcmVzcyk7XG4gIC8vc3RvcmFnZSBhZGRyZXNzLCBub3QgY29kZSBhZGRyZXNzXG5cbiAgbGV0IHN0YWNrID0geWllbGQgc2VsZWN0KGRhdGEubmV4dC5zdGF0ZS5zdGFjayk7IC8vbm90ZSB0aGUgdXNlIG9mIG5leHQhXG4gIC8vaW4gdGhpcyBzYWdhIHdlIGFyZSBpbnRlcmVzdGVkIGluIHRoZSAqcmVzdWx0cyogb2YgdGhlIGN1cnJlbnQgaW5zdHJ1Y3Rpb25cbiAgLy9ub3RlIHRoYXQgdGhlIGRlY29kZXIgaXMgc3RpbGwgYmFzZWQgb24gZGF0YS5jdXJyZW50LnN0YXRlOyB0aGF0J3MgZmluZVxuICAvL3Rob3VnaC4gIFRoZXJlJ3MgYWxyZWFkeSBhIGRlbGF5IGJldHdlZW4gd2hlbiB3ZSByZWNvcmQgdGhpbmdzIG9mZiB0aGVcbiAgLy9zdGFjayBhbmQgd2hlbiB3ZSBkZWNvZGUgdGhlbSwgYWZ0ZXIgYWxsLiAgQmFzaWNhbGx5LCBub3RoaW5nIHNlcmlvdXNcbiAgLy9zaG91bGQgaGFwcGVuIGFmdGVyIGFuIGluZGV4IG5vZGUgYnV0IGJlZm9yZSB0aGUgaW5kZXggYWNjZXNzIG5vZGUgdGhhdFxuICAvL3dvdWxkIGNhdXNlIHN0b3JhZ2UsIG1lbW9yeSwgb3IgY2FsbGRhdGEgdG8gY2hhbmdlLCBtZWFuaW5nIHRoYXQgZXZlbiBpZlxuICAvL3RoZSBsaXRlcmFsIHdlIHJlY29yZGVkIHdhcyBhIHBvaW50ZXIsIGl0IHdpbGwgc3RpbGwgYmUgdmFsaWQgYXQgdGhlIHRpbWVcbiAgLy93ZSB1c2UgaXQuICAoVGhlIG90aGVyIGxpdGVyYWxzIHdlIG1ha2UgdXNlIG9mLCBmb3IgdGhlIGJhc2UgZXhwcmVzc2lvbnMsXG4gIC8vYXJlIG5vdCBkZWNvZGVkLCBzbyBubyBwb3RlbnRpYWwgbWlzbWF0Y2ggdGhlcmUgd291bGQgYmUgcmVsZXZhbnQgYW55d2F5LilcblxuICBsZXQgYWx0ZXJuYXRlU3RhY2sgPSB5aWVsZCBzZWxlY3QoZGF0YS5uZXh0TWFwcGVkLnN0YXRlLnN0YWNrKTtcbiAgLy9IQUNLOiB1bmZvcnR1bmF0ZWx5LCBpbiBzb21lIGNhc2VzLCBkYXRhLm5leHQuc3RhdGUuc3RhY2sgZ2V0cyB0aGUgd3JvbmdcbiAgLy9yZXN1bHRzIGR1ZSB0byB1bm1hcHBlZCBpbnN0cnVjdGlvbnMgaW50ZXJ2ZW5pbmcuICBTbywgd2UgZ2V0IHRoZSBzdGFjayBhdFxuICAvL3RoZSBuZXh0ICptYXBwZWQqIHN0YWNrIGluc3RlYWQuICBUaGlzIGlzIHNvbWV0aGluZyBvZiBhIGhhY2sgYW5kIHdvbid0XG4gIC8vd29yayBpZiB3ZSdyZSBhYm91dCB0byBjaGFuZ2UgY29udGV4dCwgYnV0IGl0IHNob3VsZCB3b3JrIGluIHRoZSBjYXNlcyB0aGF0XG4gIC8vbmVlZCBpdC5cblxuICBpZiAoIXN0YWNrKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgbGV0IHRvcCA9IHN0YWNrLmxlbmd0aCAtIDE7XG4gIHZhciBhc3NpZ25tZW50LCBhc3NpZ25tZW50cywgcHJlYW1ibGVBc3NpZ25tZW50cywgYmFzZUV4cHJlc3Npb24sIHNsb3QsIHBhdGg7XG5cbiAgaWYgKCFub2RlKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gc3RhY2sgaXMgb25seSByZWFkeSBmb3IgaW50ZXJwcmV0YXRpb24gYWZ0ZXIgdGhlIGxhc3Qgc3RlcCBvZiBlYWNoXG4gIC8vIHNvdXJjZSByYW5nZVxuICAvL1xuICAvLyB0aGUgZGF0YSBtb2R1bGUgYWx3YXlzIGxvb2tzIGF0IHRoZSByZXN1bHQgb2YgYSBwYXJ0aWN1bGFyIG9wY29kZVxuICAvLyAoaS5lLiwgdGhlIGZvbGxvd2luZyB0cmFjZSBzdGVwJ3Mgc3RhY2svbWVtb3J5L3N0b3JhZ2UpLCBzbyB0aGlzXG4gIC8vIGFzc2VydHMgdGhhdCB0aGUgX2N1cnJlbnRfIG9wZXJhdGlvbiBpcyB0aGUgZmluYWwgb25lIGJlZm9yZVxuICAvLyBwcm9jZWVkaW5nXG4gIGlmICghKHlpZWxkIHNlbGVjdChkYXRhLnZpZXdzLmF0TGFzdEluc3RydWN0aW9uRm9yU291cmNlUmFuZ2UpKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vSEFDSzogbW9kaWZpZXIgcHJlYW1ibGVcbiAgLy9tb2RpZmllciBkZWZpbml0aW9ucyBhcmUgdHlwaWNhbGx5IHNraXBwZWQgKHRoaXMgaW5jbHVkZXMgY29uc3RydWN0b3JcbiAgLy9kZWZpbml0aW9ucyB3aGVuIGNhbGxlZCBhcyBhIGJhc2UgY29uc3RydWN0b3IpOyBhcyBzdWNoIEkndmUgYWRkZWQgdGhpc1xuICAvL1wibW9kaWZpZXIgcHJlYW1ibGVcIiB0byBjYXRjaCB0aGVtXG4gIGlmICh5aWVsZCBzZWxlY3QoZGF0YS5jdXJyZW50LmFib3V0VG9Nb2RpZnkpKSB7XG4gICAgbGV0IG1vZGlmaWVyID0geWllbGQgc2VsZWN0KGRhdGEuY3VycmVudC5tb2RpZmllckJlaW5nSW52b2tlZCk7XG4gICAgLy9tYXkgYmUgZWl0aGVyIGEgbW9kaWZpZXIgb3IgYmFzZSBjb25zdHJ1Y3RvclxuICAgIGxldCBjdXJyZW50SW5kZXggPSB5aWVsZCBzZWxlY3QoZGF0YS5jdXJyZW50Lm1vZGlmaWVyQXJndW1lbnRJbmRleCk7XG4gICAgZGVidWcoXCJjdXJyZW50SW5kZXggJWRcIiwgY3VycmVudEluZGV4KTtcbiAgICBsZXQgcGFyYW1ldGVycyA9IG1vZGlmaWVyLnBhcmFtZXRlcnMucGFyYW1ldGVycztcbiAgICAvL25vdzogbG9vayBhdCB0aGUgcGFyYW1ldGVycyAqYWZ0ZXIqIHRoZSBjdXJyZW50IGluZGV4LiAgd2UnbGwgbmVlZCB0b1xuICAgIC8vYWRqdXN0IGZvciB0aG9zZS5cbiAgICBsZXQgcGFyYW1ldGVyc0xlZnQgPSBwYXJhbWV0ZXJzLnNsaWNlKGN1cnJlbnRJbmRleCArIDEpO1xuICAgIGxldCBhZGp1c3RtZW50ID0gc3VtKHBhcmFtZXRlcnNMZWZ0Lm1hcChEZWNvZGVVdGlscy5EZWZpbml0aW9uLnN0YWNrU2l6ZSkpO1xuICAgIGRlYnVnKFwiYWRqdXN0bWVudCAlZFwiLCBhZGp1c3RtZW50KTtcbiAgICBwcmVhbWJsZUFzc2lnbm1lbnRzID0gYXNzaWduUGFyYW1ldGVycyhcbiAgICAgIHBhcmFtZXRlcnMsXG4gICAgICB0b3AgKyBhZGp1c3RtZW50LFxuICAgICAgY3VycmVudERlcHRoXG4gICAgKTtcbiAgfSBlbHNlIHtcbiAgICBwcmVhbWJsZUFzc2lnbm1lbnRzID0ge307XG4gIH1cblxuICBzd2l0Y2ggKG5vZGUubm9kZVR5cGUpIHtcbiAgICBjYXNlIFwiRnVuY3Rpb25EZWZpbml0aW9uXCI6XG4gICAgY2FzZSBcIk1vZGlmaWVyRGVmaW5pdGlvblwiOlxuICAgICAgLy9OT1RFOiB0aGlzIHdpbGwgKm5vdCogY2F0Y2ggbW9zdCBtb2RpZmllciBkZWZpbml0aW9ucyFcbiAgICAgIC8vdGhlIHJlc3QgaG9wZWZ1bGx5IHdpbGwgYmUgY2F1Z2h0IGJ5IHRoZSBtb2RpZmllciBwcmVhbWJsZVxuICAgICAgLy8oaW4gZmFjdCB0aGV5IHdvbid0IGFsbCBiZSwgYnV0Li4uKVxuXG4gICAgICAvL0hBQ0s6IGZpbHRlciBvdXQgc29tZSBnYXJiYWdlXG4gICAgICAvL3RoaXMgZmlsdGVycyBvdXQgdGhlIGNhc2Ugd2hlcmUgd2UncmUgcmVhbGx5IGluIGFuIGludm9jYXRpb24gb2YgYVxuICAgICAgLy9tb2RpZmllciBvciBiYXNlIGNvbnN0cnVjdG9yLCBidXQgaGF2ZSB0ZW1wb3JhcmlseSBoaXQgdGhlIGRlZmluaXRpb25cbiAgICAgIC8vbm9kZSBmb3Igc29tZSByZWFzb24uICBIb3dldmVyIHRoaXMgb2J2aW91c2x5IGNhbiBoYXZlIGEgZmFsc2UgcG9zaXRpdmVcbiAgICAgIC8vaW4gdGhlIGNhc2Ugd2hlcmUgYSBmdW5jdGlvbiBoYXMgdGhlIHNhbWUgbW9kaWZpZXIgdHdpY2UuXG4gICAgICBsZXQgbmV4dE1vZGlmaWVyID0geWllbGQgc2VsZWN0KGRhdGEubmV4dC5tb2RpZmllckJlaW5nSW52b2tlZCk7XG4gICAgICBpZiAobmV4dE1vZGlmaWVyICYmIG5leHRNb2RpZmllci5pZCA9PT0gbm9kZS5pZCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgbGV0IHBhcmFtZXRlcnMgPSBub2RlLnBhcmFtZXRlcnMucGFyYW1ldGVycztcbiAgICAgIC8vbm90ZSB0aGF0IHdlIGRvICpub3QqIGluY2x1ZGUgcmV0dXJuIHBhcmFtZXRlcnMsIHNpbmNlIHRob3NlIGFyZVxuICAgICAgLy9oYW5kbGVkIGJ5IHRoZSBWYXJpYWJsZURlY2xhcmF0aW9uIGNhc2UgKG5vLCBJIGRvbid0IGtub3cgd2h5IGl0XG4gICAgICAvL3dvcmtzIG91dCB0aGF0IHdheSlcblxuICAgICAgLy93ZSBjYW4gc2tpcCBwcmVhbWJsZUFzc2lnbm1lbnRzIGhlcmUsIHRoYXQgaXNuJ3QgdXNlZCBpbiB0aGlzIGNhc2VcbiAgICAgIGFzc2lnbm1lbnRzID0gYXNzaWduUGFyYW1ldGVycyhwYXJhbWV0ZXJzLCB0b3AsIGN1cnJlbnREZXB0aCk7XG5cbiAgICAgIGRlYnVnKFwiRnVuY3Rpb24gZGVmaW5pdGlvbiBjYXNlXCIpO1xuICAgICAgZGVidWcoXCJhc3NpZ25tZW50cyAlT1wiLCBhc3NpZ25tZW50cyk7XG5cbiAgICAgIHlpZWxkIHB1dChhY3Rpb25zLmFzc2lnbihhc3NpZ25tZW50cykpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIFwiQ29udHJhY3REZWZpbml0aW9uXCI6XG4gICAgICBsZXQgYWxsb2NhdGlvbiA9IGFsbG9jYXRpb25zW25vZGUuaWRdO1xuXG4gICAgICBkZWJ1ZyhcIkNvbnRyYWN0IGRlZmluaXRpb24gY2FzZVwiKTtcbiAgICAgIGRlYnVnKFwiYWxsb2NhdGlvbnMgJU9cIiwgYWxsb2NhdGlvbnMpO1xuICAgICAgZGVidWcoXCJhbGxvY2F0aW9uICVPXCIsIGFsbG9jYXRpb24pO1xuICAgICAgYXNzaWdubWVudHMgPSB7fTtcbiAgICAgIGZvciAobGV0IGlkIGluIGFsbG9jYXRpb24ubWVtYmVycykge1xuICAgICAgICBpZCA9IE51bWJlcihpZCk7IC8vbm90IHN1cmUgd2h5IHdlJ3JlIGdldHRpbmcgdGhlbSBhcyBzdHJpbmdzLCBidXQuLi5cbiAgICAgICAgbGV0IGlkT2JqID0geyBhc3RJZDogaWQsIGFkZHJlc3MgfTtcbiAgICAgICAgbGV0IGZ1bGxJZCA9IHN0YWJsZUtlY2NhazI1NihpZE9iaik7XG4gICAgICAgIC8vd2UgZG9uJ3QgdXNlIG1ha2VBc3NpZ25tZW50IGhlcmUgYXMgd2UgaGFkIHRvIGNvbXB1dGUgdGhlIElEIGFueXdheVxuICAgICAgICBhc3NpZ25tZW50ID0ge1xuICAgICAgICAgIC4uLmlkT2JqLFxuICAgICAgICAgIGlkOiBmdWxsSWQsXG4gICAgICAgICAgcmVmOiB7XG4gICAgICAgICAgICAuLi4oKGN1cnJlbnRBc3NpZ25tZW50cy5ieUlkW2Z1bGxJZF0gfHwge30pLnJlZiB8fCB7fSksXG4gICAgICAgICAgICAuLi5hbGxvY2F0aW9uLm1lbWJlcnNbaWRdLnBvaW50ZXJcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGFzc2lnbm1lbnRzW2Z1bGxJZF0gPSBhc3NpZ25tZW50O1xuICAgICAgfVxuICAgICAgZGVidWcoXCJhc3NpZ25tZW50cyAlT1wiLCBhc3NpZ25tZW50cyk7XG5cbiAgICAgIC8vdGhpcyBjYXNlIGRvZXNuJ3QgbmVlZCBwcmVhbWJsZUFzc2lnbm1lbnRzIGVpdGhlclxuICAgICAgeWllbGQgcHV0KGFjdGlvbnMuYXNzaWduKGFzc2lnbm1lbnRzKSk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgXCJGdW5jdGlvblR5cGVOYW1lXCI6XG4gICAgICAvL0hBQ0tcbiAgICAgIC8vZm9yIHNvbWUgcmVhc29ucywgZm9yIGRlY2xhcmF0aW9ucyBvZiBsb2NhbCB2YXJpYWJsZXMgb2YgZnVuY3Rpb24gdHlwZSxcbiAgICAgIC8vd2UgbGFuZCBvbiB0aGUgRnVuY3Rpb25UeXBlTmFtZSBpbnN0ZWFkIG9mIHRoZSBWYXJpYWJsZURlY2xhcmF0aW9uLFxuICAgICAgLy9zbyB3ZSByZXBsYWNlIHRoZSBub2RlIHdpdGggaXRzIHBhcmVudCAodGhlIFZhcmlhYmxlRGVjbGFyYXRpb24pXG4gICAgICBub2RlID0gc2NvcGVzW3Njb3Blc1tub2RlLmlkXS5wYXJlbnRJZF0uZGVmaW5pdGlvbjtcbiAgICAgIC8vbGV0J3MgZG8gYSBxdWljayBjaGVjayB0aGF0IGl0ICppcyogYSBWYXJpYWJsZURlY2xhcmF0aW9uIGJlZm9yZVxuICAgICAgLy9jb250aW51aW5nXG4gICAgICBpZiAobm9kZS5ub2RlVHlwZSAhPT0gXCJWYXJpYWJsZURlY2xhcmF0aW9uXCIpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgLy9vdGhlcndpc2UsIGRlbGliZXJhdGVseSBmYWxsIHRocm91Z2ggdG8gdGhlIFZhcmlhYmxlRGVjbGFyYXRpb24gY2FzZVxuICAgIC8vTk9URTogREVMSUJFUkFURSBGQUxMLVRIUk9VR0hcbiAgICBjYXNlIFwiVmFyaWFibGVEZWNsYXJhdGlvblwiOlxuICAgICAgbGV0IHZhcklkID0gbm9kZS5pZDtcbiAgICAgIGRlYnVnKFwiVmFyaWFibGUgZGVjbGFyYXRpb24gY2FzZVwiKTtcbiAgICAgIGRlYnVnKFwiY3VycmVudERlcHRoICVkIHZhcklkICVkXCIsIGN1cnJlbnREZXB0aCwgdmFySWQpO1xuXG4gICAgICAvL05PVEU6IFdlJ3JlIGdvaW5nIHRvIG1ha2UgdGhlIGFzc2lnbm1lbnQgY29uZGl0aW9uYWwgaGVyZTsgaGVyZSdzIHdoeS5cbiAgICAgIC8vVGhlcmUncyBhIGJ1ZyB3aGVyZSBjYWxsaW5nIHRoZSBhdXRvZ2VuZXJhdGVkIGFjY2Vzc29yIGZvciBhIHB1YmxpY1xuICAgICAgLy9jb250cmFjdCB2YXJpYWJsZSBjYXVzZXMgdGhlIGRlYnVnZ2VyIHRvIHNlZSB0d28gYWRkaXRpb25hbFxuICAgICAgLy9kZWNsYXJhdGlvbnMgZm9yIHRoYXQgdmFyaWFibGUuLi4gd2hpY2ggdGhpcyBjb2RlIHJlYWRzIGFzIGxvY2FsXG4gICAgICAvL3ZhcmlhYmxlIGRlY2xhcmF0aW9ucy4gIFJhdGhlciB0aGFuIHByZXZlbnQgdGhpcyBhdCB0aGUgc291cmNlLCB3ZSdyZVxuICAgICAgLy9qdXN0IGdvaW5nIHRvIGNoZWNrIGZvciBpdCBoZXJlLCBieSBub3QgYWRkaW5nIGEgbG9jYWwgdmFyaWFibGUgaWYgc2FpZFxuICAgICAgLy92YXJpYWJsZSBpcyBhbHJlYWR5IGEgY29udHJhY3QgdmFyaWFibGUuXG5cbiAgICAgIGlmIChcbiAgICAgICAgY3VycmVudEFzc2lnbm1lbnRzLmJ5QXN0SWRbdmFySWRdICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgY3VycmVudEFzc2lnbm1lbnRzLmJ5QXN0SWRbdmFySWRdLnNvbWUoXG4gICAgICAgICAgaWQgPT4gY3VycmVudEFzc2lnbm1lbnRzLmJ5SWRbaWRdLmFkZHJlc3MgIT09IHVuZGVmaW5lZFxuICAgICAgICApXG4gICAgICApIHtcbiAgICAgICAgZGVidWcoXCJhbHJlYWR5IGEgY29udHJhY3QgdmFyaWFibGUhXCIpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgLy9vdGhlcndpc2UsIGdvIGFoZWFkIGFuZCBtYWtlIHRoZSBhc3NpZ25tZW50XG4gICAgICBhc3NpZ25tZW50ID0gbWFrZUFzc2lnbm1lbnQoXG4gICAgICAgIHsgYXN0SWQ6IHZhcklkLCBzdGFja2ZyYW1lOiBjdXJyZW50RGVwdGggfSxcbiAgICAgICAge1xuICAgICAgICAgIHN0YWNrOiB7XG4gICAgICAgICAgICBmcm9tOiB0b3AgLSBEZWNvZGVVdGlscy5EZWZpbml0aW9uLnN0YWNrU2l6ZShub2RlKSArIDEsXG4gICAgICAgICAgICB0bzogdG9wXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICApO1xuICAgICAgYXNzaWdubWVudHMgPSB7IFthc3NpZ25tZW50LmlkXTogYXNzaWdubWVudCB9O1xuICAgICAgLy90aGlzIGNhc2UgZG9lc24ndCBuZWVkIHByZWFtYmxlQXNzaWdubWVudHMgZWl0aGVyXG4gICAgICBkZWJ1ZyhcImFzc2lnbm1lbnRzOiAlT1wiLCBhc3NpZ25tZW50cyk7XG4gICAgICB5aWVsZCBwdXQoYWN0aW9ucy5hc3NpZ24oYXNzaWdubWVudHMpKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBcIkluZGV4QWNjZXNzXCI6XG4gICAgICAvLyB0byB0cmFjayBgbWFwcGluZ2AgdHlwZXMga25vd24gaW5kaWNlc1xuICAgICAgLy8gKGFuZCBhbHNvICpzb21lKiBrbm93biBpbmRpY2VzIGZvciBhcnJheXMpXG5cbiAgICAgIC8vSEFDSzogd2UgdXNlIHRoZSBhbHRlcm5hdGUgc3RhY2sgaW4gdGhpcyBjYXNlXG5cbiAgICAgIGRlYnVnKFwiSW5kZXggYWNjZXNzIGNhc2VcIik7XG5cbiAgICAgIC8vd2UncmUgZ29pbmcgdG8gc3RhcnQgYnkgZG9pbmcgdGhlIHNhbWUgdGhpbmcgYXMgaW4gdGhlIGRlZmF1bHQgY2FzZVxuICAgICAgLy8oc2VlIGJlbG93KSAtLSBnZXR0aW5nIHRoaW5ncyByZWFkeSBmb3IgYW4gYXNzaWdubWVudC4gIFRoZW4gd2UncmVcbiAgICAgIC8vZ29pbmcgdG8gZm9yZ2V0IHRoaXMgZm9yIGEgYml0IHdoaWxlIHdlIGhhbmRsZSB0aGUgcmVzdC4uLlxuICAgICAgYXNzaWdubWVudHMgPSB7XG4gICAgICAgIC4uLnByZWFtYmxlQXNzaWdubWVudHMsXG4gICAgICAgIC4uLmxpdGVyYWxBc3NpZ25tZW50cyhub2RlLCBhbHRlcm5hdGVTdGFjaywgY3VycmVudERlcHRoKVxuICAgICAgfTtcblxuICAgICAgLy93ZSdsbCBuZWVkIHRoaXNcbiAgICAgIGJhc2VFeHByZXNzaW9uID0gbm9kZS5iYXNlRXhwcmVzc2lvbjtcblxuICAgICAgLy9idXQgZmlyc3QsIGEgZGl2ZXJzaW9uIC0tIGlzIHRoaXMgc29tZXRoaW5nIHRoYXQgY291bGQgbm90ICpwb3NzaWJseSpcbiAgICAgIC8vbGVhZCB0byBhIG1hcHBpbmc/ICBpLmUuLCBlaXRoZXIgYSBieXRlcywgb3IgYW4gYXJyYXkgb2Ygbm9uLXJlZmVyZW5jZVxuICAgICAgLy90eXBlcywgb3IgYSBub24tc3RvcmFnZSBhcnJheT9cbiAgICAgIC8vaWYgc28sIHdlJ2xsIGp1c3QgZG8gdGhlIGFzc2lnbiBhbmQgcXVpdCBvdXQgZWFybHlcbiAgICAgIC8vKG5vdGU6IHdlIHdyaXRlIGl0IHRoaXMgd2F5IGJlY2F1c2UgbWFwcGluZ3MgYXJlbid0IGNhdWdodCBieVxuICAgICAgLy9pc1JlZmVyZW5jZSlcbiAgICAgIGlmIChcbiAgICAgICAgRGVjb2RlVXRpbHMuRGVmaW5pdGlvbi50eXBlQ2xhc3MoYmFzZUV4cHJlc3Npb24pID09PSBcImJ5dGVzXCIgfHxcbiAgICAgICAgKERlY29kZVV0aWxzLkRlZmluaXRpb24udHlwZUNsYXNzKGJhc2VFeHByZXNzaW9uKSA9PT0gXCJhcnJheVwiICYmXG4gICAgICAgICAgKERlY29kZVV0aWxzLkRlZmluaXRpb24uaXNSZWZlcmVuY2Uobm9kZSlcbiAgICAgICAgICAgID8gRGVjb2RlVXRpbHMuRGVmaW5pdGlvbi5yZWZlcmVuY2VUeXBlKGJhc2VFeHByZXNzaW9uKSAhPT0gXCJzdG9yYWdlXCJcbiAgICAgICAgICAgIDogIURlY29kZVV0aWxzLkRlZmluaXRpb24uaXNNYXBwaW5nKG5vZGUpKSlcbiAgICAgICkge1xuICAgICAgICBkZWJ1ZyhcIkluZGV4IGNhc2UgYmFpbGVkIG91dCBlYXJseVwiKTtcbiAgICAgICAgZGVidWcoXCJ0eXBlQ2xhc3MgJXNcIiwgRGVjb2RlVXRpbHMuRGVmaW5pdGlvbi50eXBlQ2xhc3MoYmFzZUV4cHJlc3Npb24pKTtcbiAgICAgICAgZGVidWcoXG4gICAgICAgICAgXCJyZWZlcmVuY2VUeXBlICVzXCIsXG4gICAgICAgICAgRGVjb2RlVXRpbHMuRGVmaW5pdGlvbi5yZWZlcmVuY2VUeXBlKGJhc2VFeHByZXNzaW9uKVxuICAgICAgICApO1xuICAgICAgICBkZWJ1ZyhcImlzUmVmZXJlbmNlKG5vZGUpICVvXCIsIERlY29kZVV0aWxzLkRlZmluaXRpb24uaXNSZWZlcmVuY2Uobm9kZSkpO1xuICAgICAgICB5aWVsZCBwdXQoYWN0aW9ucy5hc3NpZ24oYXNzaWdubWVudHMpKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGxldCBrZXlEZWZpbml0aW9uID0gRGVjb2RlVXRpbHMuRGVmaW5pdGlvbi5rZXlEZWZpbml0aW9uKFxuICAgICAgICBiYXNlRXhwcmVzc2lvbixcbiAgICAgICAgc2NvcGVzXG4gICAgICApO1xuICAgICAgLy9pZiB3ZSdyZSBkZWFsaW5nIHdpdGggYW4gYXJyYXksIHRoaXMgd2lsbCBqdXN0IGhhY2sgdXAgYSB1aW50IGRlZmluaXRpb25cbiAgICAgIC8vOilcblxuICAgICAgLy9iZWdpbiBzdWJzZWN0aW9uOiBrZXkgZGVjb2RpbmdcbiAgICAgIC8vKEkgdHJpZWQgZmFjdG9yaW5nIHRoaXMgb3V0IGludG8gaXRzIG93biBzYWdhIGJ1dCBpdCBkaWRuJ3Qgd29yayB3aGVuIElcbiAgICAgIC8vZGlkIDpQIClcblxuICAgICAgbGV0IGluZGV4VmFsdWU7XG4gICAgICBsZXQgaW5kZXhEZWZpbml0aW9uID0gbm9kZS5pbmRleEV4cHJlc3Npb247XG5cbiAgICAgIC8vd2h5IHRoZSBsb29wPyBzZWUgdGhlIGVuZCBvZiB0aGUgYmxvY2sgaXQgaGVhZHMgZm9yIGFuIGV4cGxhbmF0b3J5XG4gICAgICAvL2NvbW1lbnRcbiAgICAgIHdoaWxlIChpbmRleFZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGV0IGluZGV4SWQgPSBpbmRleERlZmluaXRpb24uaWQ7XG4gICAgICAgIC8vaW5kaWNlcyBuZWVkIHRvIGJlIGlkZW50aWZpZWQgYnkgc3RhY2tmcmFtZVxuICAgICAgICBsZXQgaW5kZXhJZE9iaiA9IHsgYXN0SWQ6IGluZGV4SWQsIHN0YWNrZnJhbWU6IGN1cnJlbnREZXB0aCB9O1xuICAgICAgICBsZXQgZnVsbEluZGV4SWQgPSBzdGFibGVLZWNjYWsyNTYoaW5kZXhJZE9iaik7XG5cbiAgICAgICAgY29uc3QgaW5kZXhSZWZlcmVuY2UgPSAoY3VycmVudEFzc2lnbm1lbnRzLmJ5SWRbZnVsbEluZGV4SWRdIHx8IHt9KS5yZWY7XG5cbiAgICAgICAgaWYgKERlY29kZVV0aWxzLkRlZmluaXRpb24uaXNTaW1wbGVDb25zdGFudChpbmRleERlZmluaXRpb24pKSB7XG4gICAgICAgICAgLy93aGlsZSB0aGUgbWFpbiBjYXNlIGlzIHRoZSBuZXh0IG9uZSwgd2hlcmUgd2UgbG9vayBmb3IgYSBwcmlvclxuICAgICAgICAgIC8vYXNzaWdubWVudCwgd2UgbmVlZCB0aGlzIGNhc2UgKGFuZCBuZWVkIGl0IGZpcnN0KSBmb3IgdHdvIHJlYXNvbnM6XG4gICAgICAgICAgLy8xLiBzb21lIGNvbnN0YW50IGV4cHJlc3Npb25zIChzcGVjaWZpY2FsbHksIHN0cmluZyBhbmQgaGV4IGxpdGVyYWxzKVxuICAgICAgICAgIC8vYXJlbid0IHNvdXJjZW1hcHBlZCB0byBhbmQgc28gd29uJ3QgaGF2ZSBhIHByaW9yIGFzc2lnbm1lbnRcbiAgICAgICAgICAvLzIuIGlmIHRoZSBrZXkgdHlwZSBpcyBieXRlc04gYnV0IHRoZSBleHByZXNzaW9uIGlzIGNvbnN0YW50LCB0aGVcbiAgICAgICAgICAvL3ZhbHVlIHdpbGwgZ28gb24gdGhlIHN0YWNrICpsZWZ0Ki1wYWRkZWQgaW5zdGVhZCBvZiByaWdodC1wYWRkZWQsXG4gICAgICAgICAgLy9zbyBsb29raW5nIGZvciBhIHByaW9yIGFzc2lnbm1lbnQgd2lsbCByZWFkIHRoZSB3cm9uZyB2YWx1ZS5cbiAgICAgICAgICAvL3NvIGluc3RlYWQgaXQncyBwcmVmZXJhYmxlIHRvIHVzZSB0aGUgY29uc3RhbnQgZGlyZWN0bHkuXG4gICAgICAgICAgZGVidWcoXCJhYm91dCB0byBkZWNvZGUgc2ltcGxlIGxpdGVyYWxcIik7XG4gICAgICAgICAgaW5kZXhWYWx1ZSA9IHlpZWxkKiBkZWNvZGUoa2V5RGVmaW5pdGlvbiwge1xuICAgICAgICAgICAgZGVmaW5pdGlvbjogaW5kZXhEZWZpbml0aW9uXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSBpZiAoaW5kZXhSZWZlcmVuY2UpIHtcbiAgICAgICAgICAvL2lmIGEgcHJpb3IgYXNzaWdubWVudCBpcyBmb3VuZFxuICAgICAgICAgIGxldCBzcGxpY2VkRGVmaW5pdGlvbjtcbiAgICAgICAgICAvL2luIGdlbmVyYWwsIHdlIHdhbnQgdG8gZGVjb2RlIHVzaW5nIHRoZSBrZXkgZGVmaW5pdGlvbiwgbm90IHRoZSBpbmRleFxuICAgICAgICAgIC8vZGVmaW5pdGlvbi4gaG93ZXZlciwgdGhlIGtleSBkZWZpbml0aW9uIG1heSBoYXZlIHRoZSB3cm9uZyBsb2NhdGlvblxuICAgICAgICAgIC8vb24gaXQuICBzbywgd2hlbiBhcHBsaWNhYmxlLCB3ZSBzcGxpY2UgdGhlIGluZGV4IGRlZmluaXRpb24gbG9jYXRpb25cbiAgICAgICAgICAvL29udG8gdGhlIGtleSBkZWZpbml0aW9uIGxvY2F0aW9uLlxuICAgICAgICAgIGlmIChEZWNvZGVVdGlscy5EZWZpbml0aW9uLmlzUmVmZXJlbmNlKGluZGV4RGVmaW5pdGlvbikpIHtcbiAgICAgICAgICAgIHNwbGljZWREZWZpbml0aW9uID0gRGVjb2RlVXRpbHMuRGVmaW5pdGlvbi5zcGxpY2VMb2NhdGlvbihcbiAgICAgICAgICAgICAga2V5RGVmaW5pdGlvbixcbiAgICAgICAgICAgICAgRGVjb2RlVXRpbHMuRGVmaW5pdGlvbi5yZWZlcmVuY2VUeXBlKGluZGV4RGVmaW5pdGlvbilcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICAvL3dlIGNvdWxkIHB1dCBjb2RlIGhlcmUgdG8gYWRkIG9uIHRoZSBcIl9wdHJcIiBlbmRpbmcgd2hlbiBhYnNlbnQsXG4gICAgICAgICAgICAvL2J1dCB3ZSBwcmVzZW50bHkgaWdub3JlIHRoYXQgZW5kaW5nLCBzbyB3ZSdsbCBza2lwIHRoYXRcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3BsaWNlZERlZmluaXRpb24gPSBrZXlEZWZpbml0aW9uO1xuICAgICAgICAgIH1cbiAgICAgICAgICBkZWJ1ZyhcImFib3V0IHRvIGRlY29kZVwiKTtcbiAgICAgICAgICBpbmRleFZhbHVlID0geWllbGQqIGRlY29kZShzcGxpY2VkRGVmaW5pdGlvbiwgaW5kZXhSZWZlcmVuY2UpO1xuICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgIGluZGV4RGVmaW5pdGlvbi5yZWZlcmVuY2VkRGVjbGFyYXRpb24gJiZcbiAgICAgICAgICBzY29wZXNbaW5kZXhEZWZpbml0aW9uLnJlZmVyZW5jZURlY2xhcmF0aW9uXVxuICAgICAgICApIHtcbiAgICAgICAgICAvL3RoZXJlJ3Mgb25lIG1vcmUgcmVhc29uIHdlIG1pZ2h0IGhhdmUgZmFpbGVkIHRvIGRlY29kZSBpdDogaXQgbWlnaHQgYmUgYVxuICAgICAgICAgIC8vY29uc3RhbnQgc3RhdGUgdmFyaWFibGUuICBVbmZvcnR1bmF0ZWx5LCB3ZSBkb24ndCBrbm93IGhvdyB0byBkZWNvZGUgYWxsXG4gICAgICAgICAgLy90aG9zZSBhdCB0aGUgbW9tZW50LCBidXQgd2UgY2FuIGhhbmRsZSB0aGUgb25lcyB3ZSBkbyBrbm93IGhvdyB0byBkZWNvZGUuXG4gICAgICAgICAgLy9JbiB0aGUgZnV0dXJlIGhvcGVmdWxseSB3ZSB3aWxsIGRlY29kZSBhbGwgb2YgdGhlbVxuICAgICAgICAgIGRlYnVnKFxuICAgICAgICAgICAgXCJyZWZlcmVuY2VkRGVjbGFyYXRpb24gJWRcIixcbiAgICAgICAgICAgIGluZGV4RGVmaW5pdGlvbi5yZWZlcmVuY2VkRGVjbGFyYXRpb25cbiAgICAgICAgICApO1xuICAgICAgICAgIGxldCBpbmRleENvbnN0YW50RGVjbGFyYXRpb24gPVxuICAgICAgICAgICAgc2NvcGVzW2luZGV4RGVmaW5pdGlvbi5yZWZlcmVuY2VkRGVjbGFyYXRpb25dLmRlZmluaXRpb247XG4gICAgICAgICAgZGVidWcoXCJpbmRleENvbnN0YW50RGVjbGFyYXRpb24gJU9cIiwgaW5kZXhDb25zdGFudERlY2xhcmF0aW9uKTtcbiAgICAgICAgICBpZiAoaW5kZXhDb25zdGFudERlY2xhcmF0aW9uLmNvbnN0YW50KSB7XG4gICAgICAgICAgICBsZXQgaW5kZXhDb25zdGFudERlZmluaXRpb24gPSBpbmRleENvbnN0YW50RGVjbGFyYXRpb24udmFsdWU7XG4gICAgICAgICAgICAvL25leHQgbGluZSBmaWx0ZXJzIG91dCBjb25zdGFudHMgd2UgZG9uJ3Qga25vdyBob3cgdG8gaGFuZGxlXG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgIERlY29kZVV0aWxzLkRlZmluaXRpb24uaXNTaW1wbGVDb25zdGFudChpbmRleENvbnN0YW50RGVmaW5pdGlvbilcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICBkZWJ1ZyhcImFib3V0IHRvIGRlY29kZSBzaW1wbGUgY29uc3RhbnRcIik7XG4gICAgICAgICAgICAgIGluZGV4VmFsdWUgPSB5aWVsZCogZGVjb2RlKGtleURlZmluaXRpb24sIHtcbiAgICAgICAgICAgICAgICBkZWZpbml0aW9uOiBpbmRleENvbnN0YW50RGVjbGFyYXRpb24udmFsdWVcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vdGhlcmUncyBzdGlsbCBvbmUgbW9yZSByZWFzb24gd2UgbWlnaHQgaGF2ZSBmYWlsZWQgdG8gZGVjb2RlIGl0OlxuICAgICAgICAvL2NlcnRhaW4gKHNpbGVudCkgdHlwZSBjb252ZXJzaW9ucyBhcmVuJ3Qgc291cmNlbWFwcGVkIGVpdGhlci5cbiAgICAgICAgLy8odGhhbmtmdWxseSwgYW55IHR5cGUgY29udmVyc2lvbiB0aGF0IGFjdHVhbGx5ICpkb2VzKiBzb21ldGhpbmcgc2VlbXNcbiAgICAgICAgLy90byBiZSBzb3VyY2VtYXBwZWQuKSAgU28gaWYgd2UndmUgZmFpbGVkIHRvIGRlY29kZSBpdCwgd2UgdHJ5IGFnYWluXG4gICAgICAgIC8vd2l0aCB0aGUgYXJndW1lbnQgb2YgdGhlIHR5cGUgY29udmVyc2lvbiwgaWYgaXQgaXMgb25lOyB3ZSBsZWF2ZVxuICAgICAgICAvL2luZGV4VmFsdWUgdW5kZWZpbmVkIHNvIHRoZSBsb29wIHdpbGwgY29udGludWVcbiAgICAgICAgLy8obm90ZSB0aGF0IHRoaXMgY2FzZSBpcyBsYXN0IGZvciBhIHJlYXNvbjsgaWYgdGhpcyB3ZXJlIGVhcmxpZXIsIGl0XG4gICAgICAgIC8vd291bGQgY2F0Y2ggKm5vbiotc2lsZW50IHR5cGUgY29udmVyc2lvbnMsIHdoaWNoIHdlIHdhbnQgdG8ganVzdCByZWFkXG4gICAgICAgIC8vb2ZmIHRoZSBzdGFjaylcbiAgICAgICAgZWxzZSBpZiAoaW5kZXhEZWZpbml0aW9uLmtpbmQgPT09IFwidHlwZUNvbnZlcnNpb25cIikge1xuICAgICAgICAgIGluZGV4RGVmaW5pdGlvbiA9IGluZGV4RGVmaW5pdGlvbi5hcmd1bWVudHNbMF07XG4gICAgICAgIH1cbiAgICAgICAgLy9vdGhlcndpc2UsIHdlJ3ZlIGp1c3QgdG90YWxseSBmYWlsZWQgdG8gZGVjb2RlIGl0LCBzbyB3ZSBtYXJrXG4gICAgICAgIC8vaW5kZXhWYWx1ZSBhcyBudWxsIChhcyBkaXN0aW5jdCBmcm9tIHVuZGVmaW5lZCkgdG8gaW5kaWNhdGUgdGhpcy4gIEluXG4gICAgICAgIC8vdGhlIGZ1dHVyZSwgd2Ugc2hvdWxkIGJlIGFibGUgdG8gZGVjb2RlIGFsbCBtYXBwaW5nIGtleXMsIGJ1dCB3ZSdyZVxuICAgICAgICAvL25vdCBxdWl0ZSB0aGVyZSB5ZXQsIHNvcnJ5IChiZWNhdXNlIHdlIGNhbid0IHlldCBoYW5kbGUgYWxsIGNvbnN0YW50XG4gICAgICAgIC8vc3RhdGUgdmFyaWFibGVzKVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBpbmRleFZhbHVlID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICAvL25vdywgYXMgbWVudGlvbmVkLCByZXRyeSBpbiB0aGUgdHlwZUNvbnZlcnNpb24gY2FzZVxuICAgICAgfVxuXG4gICAgICAvL2VuZCBzdWJzZWN0aW9uOiBrZXkgZGVjb2RpbmdcblxuICAgICAgZGVidWcoXCJpbmRleCB2YWx1ZSAlT1wiLCBpbmRleFZhbHVlKTtcbiAgICAgIGRlYnVnKFwia2V5RGVmaW5pdGlvbiAlb1wiLCBrZXlEZWZpbml0aW9uKTtcblxuICAgICAgLy93aGV3ISBCdXQgd2UncmUgbm90IGRvbmUgeWV0IC0tIHdlIG5lZWQgdG8gdHVybiB0aGlzIGRlY29kZWQga2V5IGludG9cbiAgICAgIC8vYW4gYWN0dWFsIHBhdGggKGFzc3VtaW5nIHdlICpkaWQqIGRlY29kZSBpdClcbiAgICAgIC8vT0ssIG5vdCBhbiBhY3R1YWwgcGF0aCAtLSB3ZSdyZSBqdXN0IGdvaW5nIHRvIHVzZSBhIHNpbXBsZSBvZmZzZXQgZm9yXG4gICAgICAvL3RoZSBwYXRoLiAgQnV0IHRoYXQncyBPSywgYmVjYXVzZSB0aGUgbWFwcGVkUGF0aHMgcmVkdWNlciB3aWxsIHR1cm5cbiAgICAgIC8vaXQgaW50byBhbiBhY3R1YWwgcGF0aC5cbiAgICAgIGlmIChpbmRleFZhbHVlICE9PSBudWxsKSB7XG4gICAgICAgIHBhdGggPSBmZXRjaEJhc2VQYXRoKFxuICAgICAgICAgIGJhc2VFeHByZXNzaW9uLFxuICAgICAgICAgIG1hcHBlZFBhdGhzLFxuICAgICAgICAgIGN1cnJlbnRBc3NpZ25tZW50cyxcbiAgICAgICAgICBjdXJyZW50RGVwdGhcbiAgICAgICAgKTtcblxuICAgICAgICBsZXQgc2xvdCA9IHsgcGF0aCB9O1xuXG4gICAgICAgIC8vd2UgbmVlZCB0byBkbyB0aGluZ3MgZGlmZmVyZW50bHkgZGVwZW5kaW5nIG9uIHdoZXRoZXIgd2UncmUgZGVhbGluZ1xuICAgICAgICAvL3dpdGggYW4gYXJyYXkgb3IgbWFwcGluZ1xuICAgICAgICBzd2l0Y2ggKERlY29kZVV0aWxzLkRlZmluaXRpb24udHlwZUNsYXNzKGJhc2VFeHByZXNzaW9uKSkge1xuICAgICAgICAgIGNhc2UgXCJhcnJheVwiOlxuICAgICAgICAgICAgc2xvdC5oYXNoUGF0aCA9IERlY29kZVV0aWxzLkRlZmluaXRpb24uaXNEeW5hbWljQXJyYXkoXG4gICAgICAgICAgICAgIGJhc2VFeHByZXNzaW9uXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgc2xvdC5vZmZzZXQgPSBpbmRleFZhbHVlLm11bG4oXG4gICAgICAgICAgICAgIHN0b3JhZ2VTaXplKG5vZGUsIHJlZmVyZW5jZURlY2xhcmF0aW9ucywgYWxsb2NhdGlvbnMpLndvcmRzXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcIm1hcHBpbmdcIjpcbiAgICAgICAgICAgIHNsb3Qua2V5ID0gaW5kZXhWYWx1ZTtcbiAgICAgICAgICAgIHNsb3Qua2V5RW5jb2RpbmcgPSBEZWNvZGVVdGlscy5EZWZpbml0aW9uLmtleUVuY29kaW5nKFxuICAgICAgICAgICAgICBrZXlEZWZpbml0aW9uXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgc2xvdC5vZmZzZXQgPSBuZXcgQk4oMCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgZGVidWcoXCJ1bnJlY29nbml6ZWQgaW5kZXggYWNjZXNzIVwiKTtcbiAgICAgICAgfVxuICAgICAgICBkZWJ1ZyhcInNsb3QgJU9cIiwgc2xvdCk7XG5cbiAgICAgICAgLy9ub3csIG1hcCBpdCEgKGFuZCBkbyB0aGUgYXNzaWduIGFzIHdlbGwpXG4gICAgICAgIHlpZWxkIHB1dChcbiAgICAgICAgICBhY3Rpb25zLm1hcFBhdGhBbmRBc3NpZ24oXG4gICAgICAgICAgICBhZGRyZXNzLFxuICAgICAgICAgICAgc2xvdCxcbiAgICAgICAgICAgIGFzc2lnbm1lbnRzLFxuICAgICAgICAgICAgRGVjb2RlVXRpbHMuRGVmaW5pdGlvbi50eXBlSWRlbnRpZmllcihub2RlKSxcbiAgICAgICAgICAgIERlY29kZVV0aWxzLkRlZmluaXRpb24udHlwZUlkZW50aWZpZXIoYmFzZUV4cHJlc3Npb24pXG4gICAgICAgICAgKVxuICAgICAgICApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy9pZiB3ZSBmYWlsZWQgdG8gZGVjb2RlLCBqdXN0IGRvIHRoZSBhc3NpZ24gZnJvbSBhYm92ZVxuICAgICAgICBkZWJ1ZyhcImZhaWxlZCB0byBkZWNvZGUsIGp1c3QgYXNzaWduaW5nXCIpO1xuICAgICAgICB5aWVsZCBwdXQoYWN0aW9ucy5hc3NpZ24oYXNzaWdubWVudHMpKTtcbiAgICAgIH1cblxuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIFwiTWVtYmVyQWNjZXNzXCI6XG4gICAgICAvL0hBQ0s6IHdlIHVzZSB0aGUgYWx0ZXJuYXRlIHN0YWNrIGluIHRoaXMgY2FzZVxuXG4gICAgICAvL3dlJ3JlIGdvaW5nIHRvIHN0YXJ0IGJ5IGRvaW5nIHRoZSBzYW1lIHRoaW5nIGFzIGluIHRoZSBkZWZhdWx0IGNhc2VcbiAgICAgIC8vKHNlZSBiZWxvdykgLS0gZ2V0dGluZyB0aGluZ3MgcmVhZHkgZm9yIGFuIGFzc2lnbm1lbnQuICBUaGVuIHdlJ3JlXG4gICAgICAvL2dvaW5nIHRvIGZvcmdldCB0aGlzIGZvciBhIGJpdCB3aGlsZSB3ZSBoYW5kbGUgdGhlIHJlc3QuLi5cbiAgICAgIGFzc2lnbm1lbnRzID0ge1xuICAgICAgICAuLi5wcmVhbWJsZUFzc2lnbm1lbnRzLFxuICAgICAgICAuLi5saXRlcmFsQXNzaWdubWVudHMobm9kZSwgYWx0ZXJuYXRlU3RhY2ssIGN1cnJlbnREZXB0aClcbiAgICAgIH07XG5cbiAgICAgIGRlYnVnKFwiTWVtYmVyIGFjY2VzcyBjYXNlXCIpO1xuXG4gICAgICAvL01lbWJlckFjY2VzcyB1c2VzIGV4cHJlc3Npb24sIG5vdCBiYXNlRXhwcmVzc2lvblxuICAgICAgYmFzZUV4cHJlc3Npb24gPSBub2RlLmV4cHJlc3Npb247XG5cbiAgICAgIC8vaWYgdGhpcyBpc24ndCBhIHN0b3JhZ2Ugc3RydWN0LCBvciB0aGUgZWxlbWVudCBpc24ndCBvZiByZWZlcmVuY2UgdHlwZSxcbiAgICAgIC8vd2UnbGwganVzdCBkbyB0aGUgYXNzaWdubWVudCBhbmQgcXVpdCBvdXQgKGFnYWluLCBub3RlIHRoYXQgbWFwcGluZ3NcbiAgICAgIC8vYXJlbid0IGNhdWdodCBieSBpc1JlZmVyZW5jZSlcbiAgICAgIGlmIChcbiAgICAgICAgRGVjb2RlVXRpbHMuRGVmaW5pdGlvbi50eXBlQ2xhc3MoYmFzZUV4cHJlc3Npb24pICE9PSBcInN0cnVjdFwiIHx8XG4gICAgICAgIChEZWNvZGVVdGlscy5EZWZpbml0aW9uLmlzUmVmZXJlbmNlKG5vZGUpXG4gICAgICAgICAgPyBEZWNvZGVVdGlscy5EZWZpbml0aW9uLnJlZmVyZW5jZVR5cGUoYmFzZUV4cHJlc3Npb24pICE9PSBcInN0b3JhZ2VcIlxuICAgICAgICAgIDogIURlY29kZVV0aWxzLkRlZmluaXRpb24uaXNNYXBwaW5nKG5vZGUpKVxuICAgICAgKSB7XG4gICAgICAgIGRlYnVnKFwiTWVtYmVyIGNhc2UgYmFpbGVkIG91dCBlYXJseVwiKTtcbiAgICAgICAgeWllbGQgcHV0KGFjdGlvbnMuYXNzaWduKGFzc2lnbm1lbnRzKSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICAvL2J1dCBpZiBpdCBpcyBhIHN0b3JhZ2Ugc3RydWN0LCB3ZSBoYXZlIHRvIG1hcCB0aGUgcGF0aCBhcyB3ZWxsXG4gICAgICBwYXRoID0gZmV0Y2hCYXNlUGF0aChcbiAgICAgICAgYmFzZUV4cHJlc3Npb24sXG4gICAgICAgIG1hcHBlZFBhdGhzLFxuICAgICAgICBjdXJyZW50QXNzaWdubWVudHMsXG4gICAgICAgIGN1cnJlbnREZXB0aFxuICAgICAgKTtcblxuICAgICAgc2xvdCA9IHsgcGF0aCB9O1xuXG4gICAgICBsZXQgc3RydWN0SWQgPSBEZWNvZGVVdGlscy5EZWZpbml0aW9uLnR5cGVJZChiYXNlRXhwcmVzc2lvbik7XG4gICAgICBsZXQgbWVtYmVyQWxsb2NhdGlvbiA9XG4gICAgICAgIGFsbG9jYXRpb25zW3N0cnVjdElkXS5tZW1iZXJzW25vZGUucmVmZXJlbmNlZERlY2xhcmF0aW9uXTtcblxuICAgICAgc2xvdC5vZmZzZXQgPSBtZW1iZXJBbGxvY2F0aW9uLnBvaW50ZXIuc3RvcmFnZS5mcm9tLnNsb3Qub2Zmc2V0LmNsb25lKCk7XG5cbiAgICAgIGRlYnVnKFwic2xvdCAlb1wiLCBzbG90KTtcbiAgICAgIHlpZWxkIHB1dChcbiAgICAgICAgYWN0aW9ucy5tYXBQYXRoQW5kQXNzaWduKFxuICAgICAgICAgIGFkZHJlc3MsXG4gICAgICAgICAgc2xvdCxcbiAgICAgICAgICBhc3NpZ25tZW50cyxcbiAgICAgICAgICBEZWNvZGVVdGlscy5EZWZpbml0aW9uLnR5cGVJZGVudGlmaWVyKG5vZGUpLFxuICAgICAgICAgIERlY29kZVV0aWxzLkRlZmluaXRpb24udHlwZUlkZW50aWZpZXIoYmFzZUV4cHJlc3Npb24pXG4gICAgICAgIClcbiAgICAgICk7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgaWYgKG5vZGUudHlwZURlc2NyaXB0aW9ucyA9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGRlYnVnKFwiZGVjb2RpbmcgZXhwcmVzc2lvbiB2YWx1ZSAlT1wiLCBub2RlLnR5cGVEZXNjcmlwdGlvbnMpO1xuICAgICAgZGVidWcoXCJkZWZhdWx0IGNhc2VcIik7XG4gICAgICBkZWJ1ZyhcImN1cnJlbnREZXB0aCAlZCBub2RlLmlkICVkXCIsIGN1cnJlbnREZXB0aCwgbm9kZS5pZCk7XG5cbiAgICAgIGFzc2lnbm1lbnRzID0ge1xuICAgICAgICAuLi5wcmVhbWJsZUFzc2lnbm1lbnRzLFxuICAgICAgICAuLi5saXRlcmFsQXNzaWdubWVudHMobm9kZSwgc3RhY2ssIGN1cnJlbnREZXB0aClcbiAgICAgIH07XG4gICAgICB5aWVsZCBwdXQoYWN0aW9ucy5hc3NpZ24oYXNzaWdubWVudHMpKTtcbiAgICAgIGJyZWFrO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiogcmVzZXQoKSB7XG4gIHlpZWxkIHB1dChhY3Rpb25zLnJlc2V0KCkpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24qIHJlY29yZEFsbG9jYXRpb25zKCkge1xuICBjb25zdCBjb250cmFjdHMgPSB5aWVsZCBzZWxlY3QoXG4gICAgZGF0YS52aWV3cy51c2VyRGVmaW5lZFR5cGVzLmNvbnRyYWN0RGVmaW5pdGlvbnNcbiAgKTtcbiAgZGVidWcoXCJjb250cmFjdHMgJU9cIiwgY29udHJhY3RzKTtcbiAgY29uc3QgcmVmZXJlbmNlRGVjbGFyYXRpb25zID0geWllbGQgc2VsZWN0KGRhdGEudmlld3MucmVmZXJlbmNlRGVjbGFyYXRpb25zKTtcbiAgZGVidWcoXCJyZWZlcmVuY2VEZWNsYXJhdGlvbnMgJU9cIiwgcmVmZXJlbmNlRGVjbGFyYXRpb25zKTtcbiAgY29uc3Qgc3RvcmFnZUFsbG9jYXRpb25zID0gZ2V0U3RvcmFnZUFsbG9jYXRpb25zKFxuICAgIHJlZmVyZW5jZURlY2xhcmF0aW9ucyxcbiAgICBjb250cmFjdHNcbiAgKTtcbiAgZGVidWcoXCJzdG9yYWdlQWxsb2NhdGlvbnMgJU9cIiwgc3RvcmFnZUFsbG9jYXRpb25zKTtcbiAgY29uc3QgbWVtb3J5QWxsb2NhdGlvbnMgPSBnZXRNZW1vcnlBbGxvY2F0aW9ucyhyZWZlcmVuY2VEZWNsYXJhdGlvbnMpO1xuICBjb25zdCBjYWxsZGF0YUFsbG9jYXRpb25zID0gZ2V0Q2FsbGRhdGFBbGxvY2F0aW9ucyhyZWZlcmVuY2VEZWNsYXJhdGlvbnMpO1xuICB5aWVsZCBwdXQoXG4gICAgYWN0aW9ucy5hbGxvY2F0ZShzdG9yYWdlQWxsb2NhdGlvbnMsIG1lbW9yeUFsbG9jYXRpb25zLCBjYWxsZGF0YUFsbG9jYXRpb25zKVxuICApO1xufVxuXG5mdW5jdGlvbiBsaXRlcmFsQXNzaWdubWVudHMobm9kZSwgc3RhY2ssIGN1cnJlbnREZXB0aCkge1xuICBsZXQgdG9wID0gc3RhY2subGVuZ3RoIC0gMTtcblxuICBsZXQgbGl0ZXJhbCA9IHJlYWRTdGFjayhcbiAgICBzdGFjayxcbiAgICB0b3AgLSBEZWNvZGVVdGlscy5EZWZpbml0aW9uLnN0YWNrU2l6ZShub2RlKSArIDEsXG4gICAgdG9wXG4gICk7XG5cbiAgbGV0IGFzc2lnbm1lbnQgPSBtYWtlQXNzaWdubWVudChcbiAgICB7IGFzdElkOiBub2RlLmlkLCBzdGFja2ZyYW1lOiBjdXJyZW50RGVwdGggfSxcbiAgICB7IGxpdGVyYWwgfVxuICApO1xuXG4gIHJldHVybiB7IFthc3NpZ25tZW50LmlkXTogYXNzaWdubWVudCB9O1xufVxuXG4vL3Rha2VzIGEgcGFyYW1ldGVyIGxpc3QgYXMgZ2l2ZW4gaW4gdGhlIEFTVFxuZnVuY3Rpb24gYXNzaWduUGFyYW1ldGVycyhwYXJhbWV0ZXJzLCB0b3AsIGZ1bmN0aW9uRGVwdGgpIHtcbiAgbGV0IHJldmVyc2VQYXJhbWV0ZXJzID0gcGFyYW1ldGVycy5zbGljZSgpLnJldmVyc2UoKTtcbiAgLy9yZXZlcnNlIGlzIGluLXBsYWNlLCBzbyB3ZSB1c2Ugc2xpY2UoKSB0byBjbG9uZSBmaXJzdFxuICBkZWJ1ZyhcInJldmVyc2VQYXJhbWV0ZXJzICVvXCIsIHBhcmFtZXRlcnMpO1xuXG4gIGxldCBjdXJyZW50UG9zaXRpb24gPSB0b3A7XG4gIGxldCBhc3NpZ25tZW50cyA9IHt9O1xuXG4gIGZvciAobGV0IHBhcmFtZXRlciBvZiByZXZlcnNlUGFyYW1ldGVycykge1xuICAgIGxldCB3b3JkcyA9IERlY29kZVV0aWxzLkRlZmluaXRpb24uc3RhY2tTaXplKHBhcmFtZXRlcik7XG4gICAgbGV0IHBvaW50ZXIgPSB7XG4gICAgICBzdGFjazoge1xuICAgICAgICBmcm9tOiBjdXJyZW50UG9zaXRpb24gLSB3b3JkcyArIDEsXG4gICAgICAgIHRvOiBjdXJyZW50UG9zaXRpb25cbiAgICAgIH1cbiAgICB9O1xuICAgIGxldCBhc3NpZ25tZW50ID0gbWFrZUFzc2lnbm1lbnQoXG4gICAgICB7IGFzdElkOiBwYXJhbWV0ZXIuaWQsIHN0YWNrZnJhbWU6IGZ1bmN0aW9uRGVwdGggfSxcbiAgICAgIHBvaW50ZXJcbiAgICApO1xuICAgIGFzc2lnbm1lbnRzW2Fzc2lnbm1lbnQuaWRdID0gYXNzaWdubWVudDtcbiAgICBjdXJyZW50UG9zaXRpb24gLT0gd29yZHM7XG4gIH1cbiAgcmV0dXJuIGFzc2lnbm1lbnRzO1xufVxuXG5mdW5jdGlvbiBmZXRjaEJhc2VQYXRoKFxuICBiYXNlTm9kZSxcbiAgbWFwcGVkUGF0aHMsXG4gIGN1cnJlbnRBc3NpZ25tZW50cyxcbiAgY3VycmVudERlcHRoXG4pIHtcbiAgbGV0IGZ1bGxJZCA9IHN0YWJsZUtlY2NhazI1Nih7XG4gICAgYXN0SWQ6IGJhc2VOb2RlLmlkLFxuICAgIHN0YWNrZnJhbWU6IGN1cnJlbnREZXB0aFxuICB9KTtcbiAgZGVidWcoXCJhc3RJZDogJWRcIiwgYmFzZU5vZGUuaWQpO1xuICBkZWJ1ZyhcInN0YWNrZnJhbWU6ICVkXCIsIGN1cnJlbnREZXB0aCk7XG4gIGRlYnVnKFwiZnVsbElkOiAlc1wiLCBmdWxsSWQpO1xuICBkZWJ1ZyhcImN1cnJlbnRBc3NpZ25tZW50czogJU9cIiwgY3VycmVudEFzc2lnbm1lbnRzKTtcbiAgLy9iYXNlIGV4cHJlc3Npb24gaXMgYW4gZXhwcmVzc2lvbiwgYW5kIHNvIGhhcyBhIGxpdGVyYWwgYXNzaWduZWQgdG9cbiAgLy9pdFxuICBsZXQgb2Zmc2V0ID0gRGVjb2RlVXRpbHMuQ29udmVyc2lvbi50b0JOKFxuICAgIGN1cnJlbnRBc3NpZ25tZW50cy5ieUlkW2Z1bGxJZF0ucmVmLmxpdGVyYWxcbiAgKTtcbiAgcmV0dXJuIHsgb2Zmc2V0IH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiogc2FnYSgpIHtcbiAgeWllbGQgdGFrZUV2ZXJ5KFRJQ0ssIHRpY2tTYWdhKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgcHJlZml4TmFtZShcImRhdGFcIiwgc2FnYSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gbGliL2RhdGEvc2FnYXMvaW5kZXguanMiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJiYWJlbC1ydW50aW1lL2hlbHBlcnMvYXN5bmNUb0dlbmVyYXRvclwiKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBleHRlcm5hbCBcImJhYmVsLXJ1bnRpbWUvaGVscGVycy9hc3luY1RvR2VuZXJhdG9yXCJcbi8vIG1vZHVsZSBpZCA9IDE4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcImJhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3QvdmFsdWVzXCIpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGV4dGVybmFsIFwiYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC92YWx1ZXNcIlxuLy8gbW9kdWxlIGlkID0gMTlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiZXhwb3J0IGNvbnN0IEFEVkFOQ0UgPSBcIkFEVkFOQ0VcIjtcbmV4cG9ydCBmdW5jdGlvbiBhZHZhbmNlKGNvdW50KSB7XG4gIHJldHVybiB7IHR5cGU6IEFEVkFOQ0UsIGNvdW50IH07XG59XG5cbmV4cG9ydCBjb25zdCBTVEVQX05FWFQgPSBcIlNURVBfTkVYVFwiO1xuZXhwb3J0IGZ1bmN0aW9uIHN0ZXBOZXh0KCkge1xuICByZXR1cm4geyB0eXBlOiBTVEVQX05FWFQgfTtcbn1cblxuZXhwb3J0IGNvbnN0IFNURVBfT1ZFUiA9IFwiU1RFUF9PVkVSXCI7XG5leHBvcnQgZnVuY3Rpb24gc3RlcE92ZXIoKSB7XG4gIHJldHVybiB7IHR5cGU6IFNURVBfT1ZFUiB9O1xufVxuXG5leHBvcnQgY29uc3QgU1RFUF9JTlRPID0gXCJTVEVQX0lOVE9cIjtcbmV4cG9ydCBmdW5jdGlvbiBzdGVwSW50bygpIHtcbiAgcmV0dXJuIHsgdHlwZTogU1RFUF9JTlRPIH07XG59XG5cbmV4cG9ydCBjb25zdCBTVEVQX09VVCA9IFwiU1RFUF9PVVRcIjtcbmV4cG9ydCBmdW5jdGlvbiBzdGVwT3V0KCkge1xuICByZXR1cm4geyB0eXBlOiBTVEVQX09VVCB9O1xufVxuXG5leHBvcnQgY29uc3QgUkVTRVQgPSBcIlJFU0VUXCI7XG5leHBvcnQgZnVuY3Rpb24gcmVzZXQoKSB7XG4gIHJldHVybiB7IHR5cGU6IFJFU0VUIH07XG59XG5cbmV4cG9ydCBjb25zdCBJTlRFUlJVUFQgPSBcIkNPTlRST0xMRVJfSU5URVJSVVBUXCI7XG5leHBvcnQgZnVuY3Rpb24gaW50ZXJydXB0KCkge1xuICByZXR1cm4geyB0eXBlOiBJTlRFUlJVUFQgfTtcbn1cblxuZXhwb3J0IGNvbnN0IENPTlRJTlVFID0gXCJDT05USU5VRVwiO1xuZXhwb3J0IGZ1bmN0aW9uIGNvbnRpbnVlVW50aWxCcmVha3BvaW50KGJyZWFrcG9pbnRzKSB7XG4gIC8vXCJjb250aW51ZVwiIGlzIG5vdCBhIGxlZ2FsIG5hbWVcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBDT05USU5VRSxcbiAgICBicmVha3BvaW50c1xuICB9O1xufVxuXG5leHBvcnQgY29uc3QgQUREX0JSRUFLUE9JTlQgPSBcIkFERF9CUkVBS1BPSU5UXCI7XG5leHBvcnQgZnVuY3Rpb24gYWRkQnJlYWtwb2ludChicmVha3BvaW50KSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogQUREX0JSRUFLUE9JTlQsXG4gICAgYnJlYWtwb2ludFxuICB9O1xufVxuXG5leHBvcnQgY29uc3QgUkVNT1ZFX0JSRUFLUE9JTlQgPSBcIlJFTU9WRV9CUkVBS1BPSU5UXCI7XG5leHBvcnQgZnVuY3Rpb24gcmVtb3ZlQnJlYWtwb2ludChicmVha3BvaW50KSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogUkVNT1ZFX0JSRUFLUE9JTlQsXG4gICAgYnJlYWtwb2ludFxuICB9O1xufVxuXG5leHBvcnQgY29uc3QgUkVNT1ZFX0FMTF9CUkVBS1BPSU5UUyA9IFwiUkVNT1ZFX0FMTF9CUkVBS1BPSU5UU1wiO1xuZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZUFsbEJyZWFrcG9pbnRzKCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFJFTU9WRV9BTExfQlJFQUtQT0lOVFNcbiAgfTtcbn1cblxuZXhwb3J0IGNvbnN0IFNUQVJUX1NURVBQSU5HID0gXCJTVEFSVF9TVEVQUElOR1wiO1xuZXhwb3J0IGZ1bmN0aW9uIHN0YXJ0U3RlcHBpbmcoKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogU1RBUlRfU1RFUFBJTkdcbiAgfTtcbn1cblxuZXhwb3J0IGNvbnN0IERPTkVfU1RFUFBJTkcgPSBcIkRPTkVfU1RFUFBJTkdcIjtcbmV4cG9ydCBmdW5jdGlvbiBkb25lU3RlcHBpbmcoKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogRE9ORV9TVEVQUElOR1xuICB9O1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIGxpYi9jb250cm9sbGVyL2FjdGlvbnMvaW5kZXguanMiLCJpbXBvcnQgZGVidWdNb2R1bGUgZnJvbSBcImRlYnVnXCI7XG5jb25zdCBkZWJ1ZyA9IGRlYnVnTW9kdWxlKFwiZGVidWdnZXI6ZGF0YTpzZWxlY3RvcnNcIik7XG5cbmltcG9ydCB7IGNyZWF0ZVNlbGVjdG9yVHJlZSwgY3JlYXRlTGVhZiB9IGZyb20gXCJyZXNlbGVjdC10cmVlXCI7XG5pbXBvcnQganNvbnBvaW50ZXIgZnJvbSBcImpzb24tcG9pbnRlclwiO1xuXG5pbXBvcnQgeyBzdGFibGVLZWNjYWsyNTYgfSBmcm9tIFwibGliL2hlbHBlcnNcIjtcblxuaW1wb3J0IGV2bSBmcm9tIFwibGliL2V2bS9zZWxlY3RvcnNcIjtcbmltcG9ydCBzb2xpZGl0eSBmcm9tIFwibGliL3NvbGlkaXR5L3NlbGVjdG9yc1wiO1xuXG5pbXBvcnQgKiBhcyBEZWNvZGVVdGlscyBmcm9tIFwidHJ1ZmZsZS1kZWNvZGUtdXRpbHNcIjtcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5jb25zdCBpZGVudGl0eSA9IHggPT4geDtcblxuZnVuY3Rpb24gZmluZEFuY2VzdG9yT2ZUeXBlKG5vZGUsIHR5cGVzLCBzY29wZXMpIHtcbiAgLy9ub3RlOiBJJ20gbm90IGluY2x1ZGluZyBhbnkgcHJvdGVjdGlvbiBhZ2FpbnN0IG51bGwgaW4gdGhpcyBmdW5jdGlvbi5cbiAgLy9Zb3UgYXJlIGFkdmlzZWQgdG8gaW5jbHVkZSBcIlNvdXJjZVVuaXRcIiBhcyBhIGZhbGxiYWNrIHR5cGUuXG4gIHdoaWxlIChub2RlICYmICF0eXBlcy5pbmNsdWRlcyhub2RlLm5vZGVUeXBlKSkge1xuICAgIG5vZGUgPSBzY29wZXNbc2NvcGVzW25vZGUuaWRdLnBhcmVudElkXS5kZWZpbml0aW9uO1xuICB9XG4gIHJldHVybiBub2RlO1xufVxuXG4vL2dpdmVuIGEgbW9kaWZpZXIgaW52b2NhdGlvbiAob3IgaW5oZXJpdGFuY2Ugc3BlY2lmaWVyKSBub2RlLFxuLy9nZXQgdGhlIG5vZGUgZm9yIHRoZSBhY3R1YWwgbW9kaWZpZXIgKG9yIGNvbnN0cnVjdG9yKVxuZnVuY3Rpb24gbW9kaWZpZXJGb3JJbnZvY2F0aW9uKGludm9jYXRpb24sIHNjb3Blcykge1xuICBsZXQgcmF3SWQ7IC8vcmF3IHJlZmVyZW5jZWREZWNsYXJhdGlvbiBJRCBleHRyYWN0ZWQgZnJvbSB0aGUgQVNULlxuICAvL2lmIGl0J3MgYSBtb2RpZmllciB0aGlzIGlzIHdoYXQgd2Ugd2FudCwgYnV0IGlmIGl0J3MgYmFzZVxuICAvL2NvbnN0cnVjdG9yLCB3ZSdsbCBnZXQgdGhlIGNvbnRyYWN0IGluc3RlYWQsIGFuZCBuZWVkIHRvIGZpbmQgaXRzXG4gIC8vY29uc3RydWN0b3IuXG4gIHN3aXRjaCAoaW52b2NhdGlvbi5ub2RlVHlwZSkge1xuICAgIGNhc2UgXCJNb2RpZmllckludm9jYXRpb25cIjpcbiAgICAgIHJhd0lkID0gaW52b2NhdGlvbi5tb2RpZmllck5hbWUucmVmZXJlbmNlZERlY2xhcmF0aW9uO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcIkluaGVyaXRhbmNlU3BlY2lmaWVyXCI6XG4gICAgICByYXdJZCA9IGludm9jYXRpb24uYmFzZU5hbWUucmVmZXJlbmNlZERlY2xhcmF0aW9uO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIGRlYnVnKFwiYmFkIGludm9jYXRpb24gbm9kZVwiKTtcbiAgfVxuICBsZXQgcmF3Tm9kZSA9IHNjb3Blc1tyYXdJZF0uZGVmaW5pdGlvbjtcbiAgc3dpdGNoIChyYXdOb2RlLm5vZGVUeXBlKSB7XG4gICAgY2FzZSBcIk1vZGlmaWVyRGVmaW5pdGlvblwiOlxuICAgICAgcmV0dXJuIHJhd05vZGU7XG4gICAgY2FzZSBcIkNvbnRyYWN0RGVmaW5pdGlvblwiOlxuICAgICAgcmV0dXJuIHJhd05vZGUubm9kZXMuZmluZChcbiAgICAgICAgbm9kZSA9PlxuICAgICAgICAgIG5vZGUubm9kZVR5cGUgPT09IFwiRnVuY3Rpb25EZWZpbml0aW9uXCIgJiYgbm9kZS5raW5kID09PSBcImNvbnN0cnVjdG9yXCJcbiAgICAgICk7XG4gICAgZGVmYXVsdDpcbiAgICAgIC8vd2Ugc2hvdWxkIG5ldmVyIGhpdCB0aGlzIGNhc2VcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbn1cblxuLy9zZWUgZGF0YS52aWV3cy5jb250ZXh0cyBmb3IgYW4gZXhwbGFuYXRpb25cbmZ1bmN0aW9uIGRlYnVnZ2VyQ29udGV4dFRvRGVjb2RlckNvbnRleHQoY29udGV4dCkge1xuICBsZXQge1xuICAgIGNvbnRyYWN0TmFtZSxcbiAgICBiaW5hcnksXG4gICAgY29udHJhY3RJZCxcbiAgICBjb250cmFjdEtpbmQsXG4gICAgaXNDb25zdHJ1Y3RvcixcbiAgICBhYmlcbiAgfSA9IGNvbnRleHQ7XG4gIHJldHVybiB7XG4gICAgY29udHJhY3ROYW1lLFxuICAgIGJpbmFyeSxcbiAgICBjb250cmFjdElkLFxuICAgIGNvbnRyYWN0S2luZCxcbiAgICBpc0NvbnN0cnVjdG9yLFxuICAgIGFiaTogRGVjb2RlVXRpbHMuQ29udGV4dHMuYWJpVG9GdW5jdGlvbkFiaVdpdGhTaWduYXR1cmVzKGFiaSlcbiAgfTtcbn1cblxuY29uc3QgZGF0YSA9IGNyZWF0ZVNlbGVjdG9yVHJlZSh7XG4gIHN0YXRlOiBzdGF0ZSA9PiBzdGF0ZS5kYXRhLFxuXG4gIC8qKlxuICAgKiBkYXRhLnZpZXdzXG4gICAqL1xuICB2aWV3czoge1xuICAgIC8qXG4gICAgICogZGF0YS52aWV3cy5hdExhc3RJbnN0cnVjdGlvbkZvclNvdXJjZVJhbmdlXG4gICAgICovXG4gICAgYXRMYXN0SW5zdHJ1Y3Rpb25Gb3JTb3VyY2VSYW5nZTogY3JlYXRlTGVhZihcbiAgICAgIFtzb2xpZGl0eS5jdXJyZW50LmlzU291cmNlUmFuZ2VGaW5hbF0sXG4gICAgICBmaW5hbCA9PiBmaW5hbFxuICAgICksXG5cbiAgICAvKipcbiAgICAgKiBkYXRhLnZpZXdzLnNjb3BlcyAobmFtZXNwYWNlKVxuICAgICAqL1xuICAgIHNjb3Blczoge1xuICAgICAgLyoqXG4gICAgICAgKiBkYXRhLnZpZXdzLnNjb3Blcy5pbmxpbmVkIChuYW1lc3BhY2UpXG4gICAgICAgKi9cbiAgICAgIGlubGluZWQ6IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIGRhdGEudmlld3Muc2NvcGVzLmlubGluZWQgKHNlbGVjdG9yKVxuICAgICAgICAgKiBzZWUgZGF0YS5pbmZvLnNjb3BlcyBmb3IgaG93IHRoaXMgZGlmZmVycyBmcm9tIHRoZSByYXcgdmVyc2lvblxuICAgICAgICAgKi9cbiAgICAgICAgXzogY3JlYXRlTGVhZihbXCIvaW5mby9zY29wZXNcIiwgXCIuL3Jhd1wiXSwgKHNjb3BlcywgaW5saW5lZCkgPT5cbiAgICAgICAgICBPYmplY3QuYXNzaWduKFxuICAgICAgICAgICAge30sXG4gICAgICAgICAgICAuLi5PYmplY3QuZW50cmllcyhpbmxpbmVkKS5tYXAoKFtpZCwgaW5mb10pID0+IHtcbiAgICAgICAgICAgICAgbGV0IG5ld0luZm8gPSB7IC4uLmluZm8gfTtcbiAgICAgICAgICAgICAgbmV3SW5mby52YXJpYWJsZXMgPSBzY29wZXNbaWRdLnZhcmlhYmxlcztcbiAgICAgICAgICAgICAgcmV0dXJuIHsgW2lkXTogbmV3SW5mbyB9O1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICApXG4gICAgICAgICksXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIGRhdGEudmlld3Muc2NvcGVzLmlubGluZWQucmF3XG4gICAgICAgICAqL1xuICAgICAgICByYXc6IGNyZWF0ZUxlYWYoXG4gICAgICAgICAgW1wiL2luZm8vc2NvcGVzL3Jhd1wiLCBzb2xpZGl0eS5pbmZvLnNvdXJjZXNdLFxuXG4gICAgICAgICAgKHNjb3Blcywgc291cmNlcykgPT5cbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oXG4gICAgICAgICAgICAgIHt9LFxuICAgICAgICAgICAgICAuLi5PYmplY3QuZW50cmllcyhzY29wZXMpLm1hcCgoW2lkLCBlbnRyeV0pID0+ICh7XG4gICAgICAgICAgICAgICAgW2lkXToge1xuICAgICAgICAgICAgICAgICAgLi4uZW50cnksXG5cbiAgICAgICAgICAgICAgICAgIGRlZmluaXRpb246IGpzb25wb2ludGVyLmdldChcbiAgICAgICAgICAgICAgICAgICAgc291cmNlc1tlbnRyeS5zb3VyY2VJZF0uYXN0LFxuICAgICAgICAgICAgICAgICAgICBlbnRyeS5wb2ludGVyXG4gICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KSlcbiAgICAgICAgICAgIClcbiAgICAgICAgKVxuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKlxuICAgICAqIGRhdGEudmlld3MudXNlckRlZmluZWRUeXBlc1xuICAgICAqL1xuICAgIHVzZXJEZWZpbmVkVHlwZXM6IHtcbiAgICAgIC8qXG4gICAgICAgKiBkYXRhLnZpZXdzLnVzZXJEZWZpbmVkVHlwZXMuY29udHJhY3REZWZpbml0aW9uc1xuICAgICAgICogcmVzdHJpY3QgdG8gY29udHJhY3RzIG9ubHksIGFuZCBnZXQgdGhlaXIgZGVmaW5pdGlvbnNcbiAgICAgICAqL1xuICAgICAgY29udHJhY3REZWZpbml0aW9uczogY3JlYXRlTGVhZihcbiAgICAgICAgW1wiL2luZm8vdXNlckRlZmluZWRUeXBlc1wiLCBcIi92aWV3cy9zY29wZXMvaW5saW5lZFwiXSxcbiAgICAgICAgKHR5cGVJZHMsIHNjb3BlcykgPT5cbiAgICAgICAgICB0eXBlSWRzXG4gICAgICAgICAgICAubWFwKGlkID0+IHNjb3Blc1tpZF0uZGVmaW5pdGlvbilcbiAgICAgICAgICAgIC5maWx0ZXIobm9kZSA9PiBub2RlLm5vZGVUeXBlID09PSBcIkNvbnRyYWN0RGVmaW5pdGlvblwiKVxuICAgICAgKVxuICAgIH0sXG5cbiAgICAvKlxuICAgICAqIGRhdGEudmlld3MucmVmZXJlbmNlRGVjbGFyYXRpb25zXG4gICAgICovXG4gICAgcmVmZXJlbmNlRGVjbGFyYXRpb25zOiBjcmVhdGVMZWFmKFxuICAgICAgW1wiLi9zY29wZXMvaW5saW5lZFwiLCBcIi9pbmZvL3VzZXJEZWZpbmVkVHlwZXNcIl0sXG4gICAgICAoc2NvcGVzLCB1c2VyRGVmaW5lZFR5cGVzKSA9PlxuICAgICAgICBPYmplY3QuYXNzaWduKFxuICAgICAgICAgIHt9LFxuICAgICAgICAgIC4uLnVzZXJEZWZpbmVkVHlwZXMubWFwKGlkID0+ICh7IFtpZF06IHNjb3Blc1tpZF0uZGVmaW5pdGlvbiB9KSlcbiAgICAgICAgKVxuICAgICksXG5cbiAgICAvKipcbiAgICAgKiBkYXRhLnZpZXdzLm1hcHBpbmdLZXlzXG4gICAgICovXG4gICAgbWFwcGluZ0tleXM6IGNyZWF0ZUxlYWYoXG4gICAgICBbXCIvcHJvYy9tYXBwZWRQYXRoc1wiLCBcIi9jdXJyZW50L2FkZHJlc3NcIl0sXG4gICAgICAobWFwcGVkUGF0aHMsIGFkZHJlc3MpID0+XG4gICAgICAgIFtdXG4gICAgICAgICAgLmNvbmNhdChcbiAgICAgICAgICAgIC4uLk9iamVjdC52YWx1ZXMoXG4gICAgICAgICAgICAgIChtYXBwZWRQYXRocy5ieUFkZHJlc3NbYWRkcmVzc10gfHwgeyBieVR5cGU6IHt9IH0pLmJ5VHlwZVxuICAgICAgICAgICAgKS5tYXAoKHsgYnlTbG90QWRkcmVzcyB9KSA9PiBPYmplY3QudmFsdWVzKGJ5U2xvdEFkZHJlc3MpKVxuICAgICAgICAgIClcbiAgICAgICAgICAuZmlsdGVyKHNsb3QgPT4gc2xvdC5rZXkgIT09IHVuZGVmaW5lZClcbiAgICApLFxuXG4gICAgLypcbiAgICAgKiBkYXRhLnZpZXdzLmJsb2NrTnVtYmVyXG4gICAgICogcmV0dXJucyBibG9jayBudW1iZXIgYXMgc3RyaW5nXG4gICAgICovXG4gICAgYmxvY2tOdW1iZXI6IGNyZWF0ZUxlYWYoW2V2bS50cmFuc2FjdGlvbi5nbG9iYWxzLmJsb2NrXSwgYmxvY2sgPT5cbiAgICAgIGJsb2NrLm51bWJlci50b1N0cmluZygpXG4gICAgKSxcblxuICAgIC8qXG4gICAgICogZGF0YS52aWV3cy5pbnN0YW5jZXNcbiAgICAgKiBzYW1lIGFzIGV2bS5jdXJyZW50LmNvZGV4Lmluc3RhbmNlcywgYnV0IHdlIGp1c3QgbWFwIGFkZHJlc3MgPT4gYmluYXJ5LFxuICAgICAqIHdlIGRvbid0IGJvdGhlciB3aXRoIGNvbnRleHQsIGFuZCBhbHNvIHRoZSBjb2RlIGlzIGEgVWludDhBcnJheVxuICAgICAqL1xuICAgIGluc3RhbmNlczogY3JlYXRlTGVhZihbZXZtLmN1cnJlbnQuY29kZXguaW5zdGFuY2VzXSwgaW5zdGFuY2VzID0+XG4gICAgICBPYmplY3QuYXNzaWduKFxuICAgICAgICB7fSxcbiAgICAgICAgLi4uT2JqZWN0LmVudHJpZXMoaW5zdGFuY2VzKS5tYXAoKFthZGRyZXNzLCB7IGJpbmFyeSB9XSkgPT4gKHtcbiAgICAgICAgICBbYWRkcmVzc106IERlY29kZVV0aWxzLkNvbnZlcnNpb24udG9CeXRlcyhiaW5hcnkpXG4gICAgICAgIH0pKVxuICAgICAgKVxuICAgICksXG5cbiAgICAvKlxuICAgICAqIGRhdGEudmlld3MuY29udGV4dHNcbiAgICAgKiBzYW1lIGFzIGV2bS5pbmZvLmNvbnRleHRzLCBidXQ6XG4gICAgICogMC4gd2Ugb25seSBpbmNsdWRlIG5vbi1jb25zdHJ1Y3RvciBjb250ZXh0c1xuICAgICAqIDEuIHdlIG5vdyBpbmRleCBieSBjb250cmFjdCBJRCByYXRoZXIgdGhhbiBoYXNoXG4gICAgICogMi4gd2Ugc3RyaXAgb3V0IGNvbnRleHQsIHNvdXJjZU1hcCwgcHJpbWFyeVNvdXJjZSwgYW5kIGNvbXBpbGVyXG4gICAgICogMy4gd2UgYWx0ZXIgYWJpIGluIHNldmVyYWwgd2F5czpcbiAgICAgKiAzYS4gd2Ugc3RyaXAgYWJpIGRvd24gdG8ganVzdCAob3JkaW5hcnkpIGZ1bmN0aW9uc1xuICAgICAqIDNiLiB3ZSBhdWdtZW50IHRoZXNlIGZ1bmN0aW9ucyB3aXRoIHNpZ25hdHVyZXMgKGhlcmUgbWVhbmluZyBzZWxlY3RvcnMpXG4gICAgICogM2MuIGFiaSBpcyBub3cgYW4gb2JqZWN0LCBub3QgYW4gYXJyYXksIGFuZCBpbmRleGVkIGJ5IHRoZXNlIHNpZ25hdHVyZXNcbiAgICAgKi9cbiAgICBjb250ZXh0czogY3JlYXRlTGVhZihbZXZtLmluZm8uY29udGV4dHNdLCBjb250ZXh0cyA9PlxuICAgICAgT2JqZWN0LmFzc2lnbihcbiAgICAgICAge30sXG4gICAgICAgIC4uLk9iamVjdC52YWx1ZXMoY29udGV4dHMpXG4gICAgICAgICAgLmZpbHRlcihjb250ZXh0ID0+ICFjb250ZXh0LmlzQ29uc3RydWN0b3IpXG4gICAgICAgICAgLm1hcChjb250ZXh0ID0+ICh7XG4gICAgICAgICAgICBbY29udGV4dC5jb250cmFjdElkXTogZGVidWdnZXJDb250ZXh0VG9EZWNvZGVyQ29udGV4dChjb250ZXh0KVxuICAgICAgICAgIH0pKVxuICAgICAgKVxuICAgIClcbiAgfSxcblxuICAvKipcbiAgICogZGF0YS5pbmZvXG4gICAqL1xuICBpbmZvOiB7XG4gICAgLyoqXG4gICAgICogZGF0YS5pbmZvLnNjb3BlcyAobmFtZXNwYWNlKVxuICAgICAqL1xuICAgIHNjb3Blczoge1xuICAgICAgLyoqXG4gICAgICAgKiBkYXRhLmluZm8uc2NvcGVzIChzZWxlY3RvcilcbiAgICAgICAqIHRoZSByYXcgdmVyc2lvbiBpcyBiZWxvdzsgdGhpcyB2ZXJzaW9uIGFjY291bnRzIGZvciBpbmhlcml0YW5jZVxuICAgICAgICogTk9URTogZG9lc24ndCB0aGlzIHNlbGVjdG9yIHJlYWxseSBiZWxvbmcgaW4gZGF0YS52aWV3cz8gIFllcy5cbiAgICAgICAqIEJ1dCwgc2luY2UgaXQncyByZXBsYWNpbmcgdGhlIG9sZCBkYXRhLmluZm8uc2NvcGVzICh3aGljaCBpcyBub3dcbiAgICAgICAqIGRhdGEuaW5mby5zY29wZXMucmF3KSwgSSBkaWRuJ3Qgd2FudCB0byBtb3ZlIGl0LlxuICAgICAgICovXG4gICAgICBfOiBjcmVhdGVMZWFmKFtcIi4vcmF3XCIsIFwiL3ZpZXdzL3Njb3Blcy9pbmxpbmVkL3Jhd1wiXSwgKHNjb3BlcywgaW5saW5lZCkgPT5cbiAgICAgICAgT2JqZWN0LmFzc2lnbihcbiAgICAgICAgICB7fSxcbiAgICAgICAgICAuLi5PYmplY3QuZW50cmllcyhzY29wZXMpLm1hcCgoW2lkLCBzY29wZV0pID0+IHtcbiAgICAgICAgICAgIGxldCBkZWZpbml0aW9uID0gaW5saW5lZFtpZF0uZGVmaW5pdGlvbjtcbiAgICAgICAgICAgIGlmIChkZWZpbml0aW9uLm5vZGVUeXBlICE9PSBcIkNvbnRyYWN0RGVmaW5pdGlvblwiKSB7XG4gICAgICAgICAgICAgIHJldHVybiB7IFtpZF06IHNjb3BlIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvL2lmIHdlJ3ZlIHJlYWNoZWQgdGhpcyBwb2ludCwgd2Ugc2hvdWxkIGJlIGRlYWxpbmcgd2l0aCBhXG4gICAgICAgICAgICAvL2NvbnRyYWN0LCBhbmQgc3BlY2lmaWNhbGx5IGEgY29udHJhY3QgLS0gbm90IGFuIGludGVyZmFjZSBvclxuICAgICAgICAgICAgLy9saWJyYXJ5ICh0aG9zZSBkb24ndCBnZXQgXCJ2YXJpYWJsZXNcIiBlbnRyaWVzIGluIHRoZWlyIHNjb3BlcylcbiAgICAgICAgICAgIGRlYnVnKFwiY29udHJhY3QgaWQgJWRcIiwgaWQpO1xuICAgICAgICAgICAgbGV0IG5ld1Njb3BlID0geyAuLi5zY29wZSB9O1xuICAgICAgICAgICAgLy9ub3RlIHRoYXQgU29saWRpdHkgZ2l2ZXMgdXMgdGhlIGxpbmVhcml6YXRpb24gaW4gb3JkZXIgZnJvbSBtb3N0XG4gICAgICAgICAgICAvL2Rlcml2ZWQgdG8gbW9zdCBiYXNlLCBidXQgd2Ugd2FudCBtb3N0IGJhc2UgdG8gbW9zdCBkZXJpdmVkO1xuICAgICAgICAgICAgLy9hbm5veWluZ2x5LCByZXZlcnNlKCkgaXMgaW4tcGxhY2UsIHNvIHdlIGNsb25lIHdpdGggc2xpY2UoKSBmaXJzdFxuICAgICAgICAgICAgbGV0IGxpbmVhcml6ZWRCYXNlQ29udHJhY3RzRnJvbUJhc2UgPSBkZWZpbml0aW9uLmxpbmVhcml6ZWRCYXNlQ29udHJhY3RzXG4gICAgICAgICAgICAgIC5zbGljZSgpXG4gICAgICAgICAgICAgIC5yZXZlcnNlKCk7XG4gICAgICAgICAgICAvL25vdywgd2UgcHV0IGl0IGFsbCB0b2dldGhlclxuICAgICAgICAgICAgbmV3U2NvcGUudmFyaWFibGVzID0gW11cbiAgICAgICAgICAgICAgLmNvbmNhdChcbiAgICAgICAgICAgICAgICAuLi5saW5lYXJpemVkQmFzZUNvbnRyYWN0c0Zyb21CYXNlLm1hcChcbiAgICAgICAgICAgICAgICAgIGNvbnRyYWN0SWQgPT4gc2NvcGVzW2NvbnRyYWN0SWRdLnZhcmlhYmxlcyB8fCBbXVxuICAgICAgICAgICAgICAgICAgLy93ZSBuZWVkIHRoZSB8fCBbXSBiZWNhdXNlIGNvbnRyYWN0cyB3aXRoIG5vIHN0YXRlIHZhcmlhYmxlc1xuICAgICAgICAgICAgICAgICAgLy9oYXZlIHZhcmlhYmxlcyB1bmRlZmluZWQgcmF0aGVyIHRoYW4gZW1wdHkgbGlrZSB5b3UnZCBleHBlY3RcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgLmZpbHRlcih2YXJpYWJsZSA9PiB7XG4gICAgICAgICAgICAgICAgLy8uLi5leGNlcHQsIEhBQ0ssIGxldCdzIGZpbHRlciBvdXQgdGhvc2UgY29uc3RhbnRzIHdlIGRvbid0IGtub3dcbiAgICAgICAgICAgICAgICAvL2hvdyB0byByZWFkLiAgdGhleSdsbCBqdXN0IGNsdXR0ZXIgdGhpbmdzIHVwLlxuICAgICAgICAgICAgICAgIGRlYnVnKFwidmFyaWFibGUgJU9cIiwgdmFyaWFibGUpO1xuICAgICAgICAgICAgICAgIGxldCBkZWZpbml0aW9uID0gaW5saW5lZFt2YXJpYWJsZS5pZF0uZGVmaW5pdGlvbjtcbiAgICAgICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgICAgIWRlZmluaXRpb24uY29uc3RhbnQgfHxcbiAgICAgICAgICAgICAgICAgIERlY29kZVV0aWxzLkRlZmluaXRpb24uaXNTaW1wbGVDb25zdGFudChkZWZpbml0aW9uLnZhbHVlKVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICByZXR1cm4geyBbaWRdOiBuZXdTY29wZSB9O1xuICAgICAgICAgIH0pXG4gICAgICAgIClcbiAgICAgICksXG5cbiAgICAgIC8qXG4gICAgICAgKiBkYXRhLmluZm8uc2NvcGVzLnJhd1xuICAgICAgICovXG4gICAgICByYXc6IGNyZWF0ZUxlYWYoW1wiL3N0YXRlXCJdLCBzdGF0ZSA9PiBzdGF0ZS5pbmZvLnNjb3Blcy5ieUlkKVxuICAgIH0sXG5cbiAgICAvKlxuICAgICAqIGRhdGEuaW5mby5hbGxvY2F0aW9uc1xuICAgICAqL1xuICAgIGFsbG9jYXRpb25zOiB7XG4gICAgICAvKlxuICAgICAgICogZGF0YS5pbmZvLmFsbG9jYXRpb25zLnN0b3JhZ2VcbiAgICAgICAqL1xuICAgICAgc3RvcmFnZTogY3JlYXRlTGVhZihbXCIvc3RhdGVcIl0sIHN0YXRlID0+IHN0YXRlLmluZm8uYWxsb2NhdGlvbnMuc3RvcmFnZSksXG5cbiAgICAgIC8qXG4gICAgICAgKiBkYXRhLmluZm8uYWxsb2NhdGlvbnMubWVtb3J5XG4gICAgICAgKi9cbiAgICAgIG1lbW9yeTogY3JlYXRlTGVhZihbXCIvc3RhdGVcIl0sIHN0YXRlID0+IHN0YXRlLmluZm8uYWxsb2NhdGlvbnMubWVtb3J5KSxcblxuICAgICAgLypcbiAgICAgICAqIGRhdGEuaW5mby5hbGxvY2F0aW9ucy5jYWxsZGF0YVxuICAgICAgICovXG4gICAgICBjYWxsZGF0YTogY3JlYXRlTGVhZihbXCIvc3RhdGVcIl0sIHN0YXRlID0+IHN0YXRlLmluZm8uYWxsb2NhdGlvbnMuY2FsbGRhdGEpXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGRhdGEuaW5mby51c2VyRGVmaW5lZFR5cGVzXG4gICAgICovXG4gICAgdXNlckRlZmluZWRUeXBlczogY3JlYXRlTGVhZihcbiAgICAgIFtcIi9zdGF0ZVwiXSxcbiAgICAgIHN0YXRlID0+IHN0YXRlLmluZm8udXNlckRlZmluZWRUeXBlc1xuICAgIClcbiAgfSxcblxuICAvKipcbiAgICogZGF0YS5wcm9jXG4gICAqL1xuICBwcm9jOiB7XG4gICAgLyoqXG4gICAgICogZGF0YS5wcm9jLmFzc2lnbm1lbnRzXG4gICAgICovXG4gICAgYXNzaWdubWVudHM6IGNyZWF0ZUxlYWYoXG4gICAgICBbXCIvc3RhdGVcIl0sXG4gICAgICBzdGF0ZSA9PiBzdGF0ZS5wcm9jLmFzc2lnbm1lbnRzXG4gICAgICAvL25vdGU6IHRoaXMgbm8gbG9uZ2VyIGZldGNoZXMganVzdCB0aGUgYnlJZCwgYnV0IHJhdGhlciB0aGUgd2hvbGVcbiAgICAgIC8vYXNzaWdubWVudHMgb2JqZWN0XG4gICAgKSxcblxuICAgIC8qXG4gICAgICogZGF0YS5wcm9jLm1hcHBlZFBhdGhzXG4gICAgICovXG4gICAgbWFwcGVkUGF0aHM6IGNyZWF0ZUxlYWYoW1wiL3N0YXRlXCJdLCBzdGF0ZSA9PiBzdGF0ZS5wcm9jLm1hcHBlZFBhdGhzKSxcblxuICAgIC8qKlxuICAgICAqIGRhdGEucHJvYy5kZWNvZGluZ0tleXNcbiAgICAgKlxuICAgICAqIG51bWJlciBvZiBrZXlzIHRoYXQgYXJlIHN0aWxsIGRlY29kaW5nXG4gICAgICovXG4gICAgZGVjb2RpbmdLZXlzOiBjcmVhdGVMZWFmKFxuICAgICAgW1wiLi9tYXBwZWRQYXRoc1wiXSxcbiAgICAgIG1hcHBlZFBhdGhzID0+IG1hcHBlZFBhdGhzLmRlY29kaW5nU3RhcnRlZFxuICAgIClcbiAgfSxcblxuICAvKipcbiAgICogZGF0YS5jdXJyZW50XG4gICAqL1xuICBjdXJyZW50OiB7XG4gICAgLyoqXG4gICAgICogZGF0YS5jdXJyZW50LnN0YXRlXG4gICAgICovXG4gICAgc3RhdGU6IHtcbiAgICAgIC8qKlxuICAgICAgICogZGF0YS5jdXJyZW50LnN0YXRlLnN0YWNrXG4gICAgICAgKi9cbiAgICAgIHN0YWNrOiBjcmVhdGVMZWFmKFxuICAgICAgICBbZXZtLmN1cnJlbnQuc3RhdGUuc3RhY2tdLFxuXG4gICAgICAgIHdvcmRzID0+ICh3b3JkcyB8fCBbXSkubWFwKHdvcmQgPT4gRGVjb2RlVXRpbHMuQ29udmVyc2lvbi50b0J5dGVzKHdvcmQpKVxuICAgICAgKSxcblxuICAgICAgLyoqXG4gICAgICAgKiBkYXRhLmN1cnJlbnQuc3RhdGUubWVtb3J5XG4gICAgICAgKi9cbiAgICAgIG1lbW9yeTogY3JlYXRlTGVhZihcbiAgICAgICAgW2V2bS5jdXJyZW50LnN0YXRlLm1lbW9yeV0sXG5cbiAgICAgICAgd29yZHMgPT4gRGVjb2RlVXRpbHMuQ29udmVyc2lvbi50b0J5dGVzKHdvcmRzLmpvaW4oXCJcIikpXG4gICAgICApLFxuXG4gICAgICAvKipcbiAgICAgICAqIGRhdGEuY3VycmVudC5zdGF0ZS5jYWxsZGF0YVxuICAgICAgICovXG4gICAgICBjYWxsZGF0YTogY3JlYXRlTGVhZihcbiAgICAgICAgW2V2bS5jdXJyZW50LmNhbGxdLFxuXG4gICAgICAgICh7IGRhdGEgfSkgPT4gRGVjb2RlVXRpbHMuQ29udmVyc2lvbi50b0J5dGVzKGRhdGEpXG4gICAgICApLFxuXG4gICAgICAvKipcbiAgICAgICAqIGRhdGEuY3VycmVudC5zdGF0ZS5zdG9yYWdlXG4gICAgICAgKi9cbiAgICAgIHN0b3JhZ2U6IGNyZWF0ZUxlYWYoXG4gICAgICAgIFtldm0uY3VycmVudC5jb2RleC5zdG9yYWdlXSxcblxuICAgICAgICBtYXBwaW5nID0+XG4gICAgICAgICAgT2JqZWN0LmFzc2lnbihcbiAgICAgICAgICAgIHt9LFxuICAgICAgICAgICAgLi4uT2JqZWN0LmVudHJpZXMobWFwcGluZykubWFwKChbYWRkcmVzcywgd29yZF0pID0+ICh7XG4gICAgICAgICAgICAgIFtgMHgke2FkZHJlc3N9YF06IERlY29kZVV0aWxzLkNvbnZlcnNpb24udG9CeXRlcyh3b3JkKVxuICAgICAgICAgICAgfSkpXG4gICAgICAgICAgKVxuICAgICAgKSxcblxuICAgICAgLypcbiAgICAgICAqIGRhdGEuY3VycmVudC5zdGF0ZS5zcGVjaWFsc1xuICAgICAgICogSSd2ZSBuYW1lZCB0aGVzZSBhZnRlciB0aGUgc29saWRpdHkgdmFyaWFibGVzIHRoZXkgY29ycmVzcG9uZCB0byxcbiAgICAgICAqIHdoaWNoIGFyZSAqbW9zdGx5KiB0aGUgc2FtZSBhcyB0aGUgY29ycmVzcG9uZGluZyBFVk0gb3Bjb2Rlc1xuICAgICAgICogKEZXSVc6IHRoaXMgPSBBRERSRVNTLCBzZW5kZXIgPSBDQUxMRVIsIHZhbHVlID0gQ0FMTFZBTFVFKVxuICAgICAgICovXG4gICAgICBzcGVjaWFsczogY3JlYXRlTGVhZihcbiAgICAgICAgW1wiL2N1cnJlbnQvYWRkcmVzc1wiLCBldm0uY3VycmVudC5jYWxsLCBldm0udHJhbnNhY3Rpb24uZ2xvYmFsc10sXG4gICAgICAgIChhZGRyZXNzLCB7IHNlbmRlciwgdmFsdWUgfSwgeyB0eCwgYmxvY2sgfSkgPT4gKHtcbiAgICAgICAgICB0aGlzOiBEZWNvZGVVdGlscy5Db252ZXJzaW9uLnRvQnl0ZXMoYWRkcmVzcyksXG5cbiAgICAgICAgICBzZW5kZXI6IERlY29kZVV0aWxzLkNvbnZlcnNpb24udG9CeXRlcyhzZW5kZXIpLFxuXG4gICAgICAgICAgdmFsdWU6IERlY29kZVV0aWxzLkNvbnZlcnNpb24udG9CeXRlcyh2YWx1ZSksXG5cbiAgICAgICAgICAvL2xldCdzIGNyYWNrIG9wZW4gdGhhdCB0eCBhbmQgYmxvY2shXG4gICAgICAgICAgLi4uT2JqZWN0LmFzc2lnbihcbiAgICAgICAgICAgIHt9LFxuICAgICAgICAgICAgLi4uT2JqZWN0LmVudHJpZXModHgpLm1hcCgoW3ZhcmlhYmxlLCB2YWx1ZV0pID0+ICh7XG4gICAgICAgICAgICAgIFt2YXJpYWJsZV06IERlY29kZVV0aWxzLkNvbnZlcnNpb24udG9CeXRlcyh2YWx1ZSlcbiAgICAgICAgICAgIH0pKVxuICAgICAgICAgICksXG5cbiAgICAgICAgICAuLi5PYmplY3QuYXNzaWduKFxuICAgICAgICAgICAge30sXG4gICAgICAgICAgICAuLi5PYmplY3QuZW50cmllcyhibG9jaykubWFwKChbdmFyaWFibGUsIHZhbHVlXSkgPT4gKHtcbiAgICAgICAgICAgICAgW3ZhcmlhYmxlXTogRGVjb2RlVXRpbHMuQ29udmVyc2lvbi50b0J5dGVzKHZhbHVlKVxuICAgICAgICAgICAgfSkpXG4gICAgICAgICAgKVxuICAgICAgICB9KVxuICAgICAgKVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBkYXRhLmN1cnJlbnQubm9kZVxuICAgICAqL1xuICAgIG5vZGU6IGNyZWF0ZUxlYWYoW3NvbGlkaXR5LmN1cnJlbnQubm9kZV0sIGlkZW50aXR5KSxcblxuICAgIC8qKlxuICAgICAqIGRhdGEuY3VycmVudC5zY29wZVxuICAgICAqIG9sZCBhbGlhcyBmb3IgZGF0YS5jdXJyZW50Lm5vZGUgKGRlcHJlY2F0ZWQpXG4gICAgICovXG4gICAgc2NvcGU6IGNyZWF0ZUxlYWYoW1wiLi9ub2RlXCJdLCBpZGVudGl0eSksXG5cbiAgICAvKlxuICAgICAqIGRhdGEuY3VycmVudC5jb250cmFjdFxuICAgICAqIHdhcm5pbmc6IG1heSByZXR1cm4gbnVsbCBvciBzaW1pbGFyLCBldmVuIHRob3VnaCBTb3VyY2VVbml0IGlzIGluY2x1ZGVkXG4gICAgICogYXMgZmFsbGJhY2tcbiAgICAgKi9cbiAgICBjb250cmFjdDogY3JlYXRlTGVhZihcbiAgICAgIFtcIi4vbm9kZVwiLCBcIi92aWV3cy9zY29wZXMvaW5saW5lZFwiXSxcbiAgICAgIChub2RlLCBzY29wZXMpID0+IHtcbiAgICAgICAgY29uc3QgdHlwZXMgPSBbXCJDb250cmFjdERlZmluaXRpb25cIiwgXCJTb3VyY2VVbml0XCJdO1xuICAgICAgICAvL1NvdXJjZVVuaXQgaW5jbHVkZWQgYXMgZmFsbGJhY2tcbiAgICAgICAgcmV0dXJuIGZpbmRBbmNlc3Rvck9mVHlwZShub2RlLCB0eXBlcywgc2NvcGVzKTtcbiAgICAgIH1cbiAgICApLFxuXG4gICAgLyoqXG4gICAgICogZGF0YS5jdXJyZW50LmZ1bmN0aW9uRGVwdGhcbiAgICAgKi9cblxuICAgIGZ1bmN0aW9uRGVwdGg6IGNyZWF0ZUxlYWYoW3NvbGlkaXR5LmN1cnJlbnQuZnVuY3Rpb25EZXB0aF0sIGlkZW50aXR5KSxcblxuICAgIC8qKlxuICAgICAqIGRhdGEuY3VycmVudC5hZGRyZXNzXG4gICAgICogTk9URTogdGhpcyBpcyB0aGUgU1RPUkFHRSBhZGRyZXNzIGZvciB0aGUgY3VycmVudCBjYWxsLCBub3QgdGhlIENPREVcbiAgICAgKiBhZGRyZXNzXG4gICAgICovXG5cbiAgICBhZGRyZXNzOiBjcmVhdGVMZWFmKFtldm0uY3VycmVudC5jYWxsXSwgY2FsbCA9PiBjYWxsLnN0b3JhZ2VBZGRyZXNzKSxcblxuICAgIC8qXG4gICAgICogZGF0YS5jdXJyZW50LmZ1bmN0aW9uc0J5UHJvZ3JhbUNvdW50ZXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbnNCeVByb2dyYW1Db3VudGVyOiBjcmVhdGVMZWFmKFxuICAgICAgW3NvbGlkaXR5LmN1cnJlbnQuZnVuY3Rpb25zQnlQcm9ncmFtQ291bnRlcl0sXG4gICAgICBmdW5jdGlvbnMgPT4gZnVuY3Rpb25zXG4gICAgKSxcblxuICAgIC8qXG4gICAgICogZGF0YS5jdXJyZW50LmNvbnRleHRcbiAgICAgKi9cbiAgICBjb250ZXh0OiBjcmVhdGVMZWFmKFtldm0uY3VycmVudC5jb250ZXh0XSwgZGVidWdnZXJDb250ZXh0VG9EZWNvZGVyQ29udGV4dCksXG5cbiAgICAvKlxuICAgICAqIGRhdGEuY3VycmVudC5hYm91dFRvTW9kaWZ5XG4gICAgICogSEFDS1xuICAgICAqIFRoaXMgc2VsZWN0b3IgaXMgdXNlZCB0byBjYXRjaCB0aG9zZSB0aW1lcyB3aGVuIHdlIGdvIHN0cmFpZ2h0IGZyb20gYVxuICAgICAqIG1vZGlmaWVyIGludm9jYXRpb24gaW50byB0aGUgbW9kaWZpZXIgaXRzZWxmLCBza2lwcGluZyBvdmVyIHRoZVxuICAgICAqIGRlZmluaXRpb24gbm9kZSAodGhpcyBpbmNsdWRlcyBiYXNlIGNvbnN0cnVjdG9yIGNhbGxzKS4gIFNvIGl0IHNob3VsZFxuICAgICAqIHJldHVybiB0cnVlIHdoZW46XG4gICAgICogMS4gd2UncmUgb24gdGhlIG5vZGUgY29ycmVzcG9uZGluZyB0byBhbiBhcmd1bWVudCB0byBhIG1vZGlmaWVyXG4gICAgICogaW52b2NhdGlvbiBvciBiYXNlIGNvbnN0cnVjdG9yIGNhbGwsIG9yLCBpZiBzYWlkIGFyZ3VtZW50IGlzIGEgdHlwZVxuICAgICAqIGNvbnZlcnNpb24sIGl0cyBhcmd1bWVudCAob3IgbmVzdGVkIGFyZ3VtZW50KVxuICAgICAqIDIuIHRoZSBuZXh0IG5vZGUgaXMgbm90IGEgRnVuY3Rpb25EZWZpbml0aW9uLCBNb2RpZmllckRlZmluaXRpb24sIG9yXG4gICAgICogaW4gdGhlIHNhbWUgbW9kaWZpZXIgLyBiYXNlIGNvbnN0cnVjdG9yIGludm9jYXRpb25cbiAgICAgKi9cbiAgICBhYm91dFRvTW9kaWZ5OiBjcmVhdGVMZWFmKFxuICAgICAgW1xuICAgICAgICBcIi4vbm9kZVwiLFxuICAgICAgICBcIi4vbW9kaWZpZXJJbnZvY2F0aW9uXCIsXG4gICAgICAgIFwiLi9tb2RpZmllckFyZ3VtZW50SW5kZXhcIixcbiAgICAgICAgXCIvbmV4dC9ub2RlXCIsXG4gICAgICAgIFwiL25leHQvbW9kaWZpZXJJbnZvY2F0aW9uXCIsXG4gICAgICAgIGV2bS5jdXJyZW50LnN0ZXAuaXNDb250ZXh0Q2hhbmdlXG4gICAgICBdLFxuICAgICAgKG5vZGUsIGludm9jYXRpb24sIGluZGV4LCBuZXh0LCBuZXh0SW52b2NhdGlvbiwgaXNDb250ZXh0Q2hhbmdlKSA9PiB7XG4gICAgICAgIC8vZW5zdXJlOiBjdXJyZW50IGluc3RydWN0aW9uIGlzIG5vdCBhIGNvbnRleHQgY2hhbmdlIChiZWNhdXNlIGlmIGl0IGlzXG4gICAgICAgIC8vd2UgY2Fubm90IHJlbHkgb24gdGhlIGRhdGEubmV4dCBzZWxlY3RvcnMsIGJ1dCBhbHNvIGlmIGl0IGlzIHdlIGtub3dcbiAgICAgICAgLy93ZSdyZSBub3QgYWJvdXQgdG8gY2FsbCBhIG1vZGlmaWVyIG9yIGJhc2UgY29uc3RydWN0b3IhKVxuICAgICAgICAvL3dlIGFsc28gd2FudCB0byByZXR1cm4gZmFsc2UgaWYgd2UgY2FuJ3QgZmluZCB0aGluZ3MgZm9yIHdoYXRldmVyXG4gICAgICAgIC8vcmVhc29uXG4gICAgICAgIGlmIChcbiAgICAgICAgICBpc0NvbnRleHRDaGFuZ2UgfHxcbiAgICAgICAgICAhbm9kZSB8fFxuICAgICAgICAgICFuZXh0IHx8XG4gICAgICAgICAgIWludm9jYXRpb24gfHxcbiAgICAgICAgICAhbmV4dEludm9jYXRpb25cbiAgICAgICAgKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy9lbnN1cmU6IGN1cnJlbnQgcG9zaXRpb24gaXMgaW4gYSBNb2RpZmllckludm9jYXRpb24gb3JcbiAgICAgICAgLy9Jbmhlcml0YW5jZVNwZWNpZmllciAocmVjYWxsIHRoYXQgU291cmNlVW5pdCB3YXMgaW5jbHVkZWQgYXNcbiAgICAgICAgLy9mYWxsYmFjaylcbiAgICAgICAgaWYgKGludm9jYXRpb24ubm9kZVR5cGUgPT09IFwiU291cmNlVW5pdFwiKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy9lbnN1cmU6IG5leHQgbm9kZSBpcyBub3QgYSBmdW5jdGlvbiBkZWZpbml0aW9uIG9yIG1vZGlmaWVyIGRlZmluaXRpb25cbiAgICAgICAgaWYgKFxuICAgICAgICAgIG5leHQubm9kZVR5cGUgPT09IFwiRnVuY3Rpb25EZWZpbml0aW9uXCIgfHxcbiAgICAgICAgICBuZXh0Lm5vZGVUeXBlID09PSBcIk1vZGlmaWVyRGVmaW5pdGlvblwiXG4gICAgICAgICkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vZW5zdXJlOiBuZXh0IG5vZGUgaXMgbm90IGluIHRoZSBzYW1lIGludm9jYXRpb25cbiAgICAgICAgaWYgKFxuICAgICAgICAgIG5leHRJbnZvY2F0aW9uLm5vZGVUeXBlICE9PSBcIlNvdXJjZVVuaXRcIiAmJlxuICAgICAgICAgIG5leHRJbnZvY2F0aW9uLmlkID09PSBpbnZvY2F0aW9uLmlkXG4gICAgICAgICkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vbm93OiBhcmUgd2Ugb24gdGhlIG5vZGUgY29ycmVzcG9uZGluZyB0byBhbiBhcmd1bWVudCwgb3IsIGlmXG4gICAgICAgIC8vaXQncyBhIHR5cGUgY29udmVyc2lvbiwgaXRzIG5lc3RlZCBhcmd1bWVudD9cbiAgICAgICAgaWYgKGluZGV4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGFyZ3VtZW50ID0gaW52b2NhdGlvbi5hcmd1bWVudHNbaW5kZXhdO1xuICAgICAgICB3aGlsZSAoYXJndW1lbnQua2luZCA9PT0gXCJ0eXBlQ29udmVyc2lvblwiKSB7XG4gICAgICAgICAgaWYgKG5vZGUuaWQgPT09IGFyZ3VtZW50LmlkKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYXJndW1lbnQgPSBhcmd1bWVudC5hcmd1bWVudHNbMF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5vZGUuaWQgPT09IGFyZ3VtZW50LmlkO1xuICAgICAgfVxuICAgICksXG5cbiAgICAvKlxuICAgICAqIGRhdGEuY3VycmVudC5tb2RpZmllckludm9jYXRpb25cbiAgICAgKi9cbiAgICBtb2RpZmllckludm9jYXRpb246IGNyZWF0ZUxlYWYoXG4gICAgICBbXCIuL25vZGVcIiwgXCIvdmlld3Mvc2NvcGVzL2lubGluZWRcIl0sXG4gICAgICAobm9kZSwgc2NvcGVzKSA9PiB7XG4gICAgICAgIGNvbnN0IHR5cGVzID0gW1xuICAgICAgICAgIFwiTW9kaWZpZXJJbnZvY2F0aW9uXCIsXG4gICAgICAgICAgXCJJbmhlcml0YW5jZVNwZWNpZmllclwiLFxuICAgICAgICAgIFwiU291cmNlVW5pdFwiXG4gICAgICAgIF07XG4gICAgICAgIC8vYWdhaW4sIFNvdXJjZVVuaXQgaW5jbHVkZWQgYXMgZmFsbGJhY2tcbiAgICAgICAgcmV0dXJuIGZpbmRBbmNlc3Rvck9mVHlwZShub2RlLCB0eXBlcywgc2NvcGVzKTtcbiAgICAgIH1cbiAgICApLFxuXG4gICAgLyoqXG4gICAgICogZGF0YS5jdXJyZW50Lm1vZGlmaWVyQXJndW1lbnRJbmRleFxuICAgICAqIGdldHMgdGhlIGluZGV4IG9mIHRoZSBjdXJyZW50IG1vZGlmaWVyIGFyZ3VtZW50IHRoYXQgeW91J3JlIGluXG4gICAgICogKHVuZGVmaW5lZCB3aGVuIG5vdCBpbiBhIG1vZGlmaWVyIGFyZ3VtZW50KVxuICAgICAqL1xuICAgIG1vZGlmaWVyQXJndW1lbnRJbmRleDogY3JlYXRlTGVhZihcbiAgICAgIFtcIi9pbmZvL3Njb3Blc1wiLCBcIi4vbm9kZVwiLCBcIi4vbW9kaWZpZXJJbnZvY2F0aW9uXCJdLFxuICAgICAgKHNjb3Blcywgbm9kZSwgaW52b2NhdGlvbikgPT4ge1xuICAgICAgICBpZiAoaW52b2NhdGlvbi5ub2RlVHlwZSA9PT0gXCJTb3VyY2VVbml0XCIpIHtcbiAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IHBvaW50ZXIgPSBzY29wZXNbbm9kZS5pZF0ucG9pbnRlcjtcbiAgICAgICAgbGV0IGludm9jYXRpb25Qb2ludGVyID0gc2NvcGVzW2ludm9jYXRpb24uaWRdLnBvaW50ZXI7XG5cbiAgICAgICAgLy9zbGljZSB0aGUgaW52b2NhdGlvbiBwb2ludGVyIG9mZiB0aGUgYmVnaW5uaW5nXG4gICAgICAgIGxldCBkaWZmZXJlbmNlID0gcG9pbnRlci5yZXBsYWNlKGludm9jYXRpb25Qb2ludGVyLCBcIlwiKTtcbiAgICAgICAgZGVidWcoXCJkaWZmZXJlbmNlICVzXCIsIGRpZmZlcmVuY2UpO1xuICAgICAgICBsZXQgcmF3SW5kZXggPSBkaWZmZXJlbmNlLm1hdGNoKC9eXFwvYXJndW1lbnRzXFwvKFxcZCspLyk7XG4gICAgICAgIC8vbm90ZSB0aGF0IHRoYXQgXFxkKyBpcyBncmVlZHlcbiAgICAgICAgZGVidWcoXCJyYXdJbmRleCAlb1wiLCByYXdJbmRleCk7XG4gICAgICAgIGlmIChyYXdJbmRleCA9PT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhcnNlSW50KHJhd0luZGV4WzFdKTtcbiAgICAgIH1cbiAgICApLFxuXG4gICAgLypcbiAgICAgKiBkYXRhLmN1cnJlbnQubW9kaWZpZXJCZWluZ0ludm9rZWRcbiAgICAgKiBnZXRzIHRoZSBub2RlIGNvcnJlc3BvbmRpbmcgdG8gdGhlIG1vZGlmaWVyIG9yIGJhc2UgY29uc3RydWN0b3JcbiAgICAgKiBiZWluZyBpbnZva2VkXG4gICAgICovXG4gICAgbW9kaWZpZXJCZWluZ0ludm9rZWQ6IGNyZWF0ZUxlYWYoXG4gICAgICBbXCIuL21vZGlmaWVySW52b2NhdGlvblwiLCBcIi92aWV3cy9zY29wZXMvaW5saW5lZFwiXSxcbiAgICAgIChpbnZvY2F0aW9uLCBzY29wZXMpID0+IHtcbiAgICAgICAgaWYgKCFpbnZvY2F0aW9uIHx8IGludm9jYXRpb24ubm9kZVR5cGUgPT09IFwiU291cmNlVW5pdFwiKSB7XG4gICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBtb2RpZmllckZvckludm9jYXRpb24oaW52b2NhdGlvbiwgc2NvcGVzKTtcbiAgICAgIH1cbiAgICApLFxuXG4gICAgLyoqXG4gICAgICogZGF0YS5jdXJyZW50LmlkZW50aWZpZXJzIChuYW1lc3BhY2UpXG4gICAgICovXG4gICAgaWRlbnRpZmllcnM6IHtcbiAgICAgIC8qKlxuICAgICAgICogZGF0YS5jdXJyZW50LmlkZW50aWZpZXJzIChzZWxlY3RvcilcbiAgICAgICAqXG4gICAgICAgKiByZXR1cm5zIGlkZW50aWZlcnMgYW5kIGNvcnJlc3BvbmRpbmcgZGVmaW5pdGlvbiBub2RlIElEIG9yIGJ1aWx0aW4gbmFtZVxuICAgICAgICogKG9iamVjdCBlbnRyaWVzIGxvb2sgbGlrZSBbbmFtZV06IHthc3RJZDogaWR9IG9yIGxpa2UgW25hbWVdOiB7YnVpbHRpbjogbmFtZX1cbiAgICAgICAqL1xuICAgICAgXzogY3JlYXRlTGVhZihcbiAgICAgICAgW1wiL3ZpZXdzL3Njb3Blcy9pbmxpbmVkXCIsIFwiL2N1cnJlbnQvbm9kZVwiXSxcblxuICAgICAgICAoc2NvcGVzLCBzY29wZSkgPT4ge1xuICAgICAgICAgIGxldCB2YXJpYWJsZXMgPSB7fTtcbiAgICAgICAgICBpZiAoc2NvcGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbGV0IGN1ciA9IHNjb3BlLmlkO1xuXG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgIHZhcmlhYmxlcyA9IE9iamVjdC5hc3NpZ24oXG4gICAgICAgICAgICAgICAgdmFyaWFibGVzLFxuICAgICAgICAgICAgICAgIC4uLihzY29wZXNbY3VyXS52YXJpYWJsZXMgfHwgW10pXG4gICAgICAgICAgICAgICAgICAuZmlsdGVyKHYgPT4gdi5uYW1lICE9PSBcIlwiKSAvL2V4Y2x1ZGUgYW5vbnltb3VzIG91dHB1dCBwYXJhbXNcbiAgICAgICAgICAgICAgICAgIC5maWx0ZXIodiA9PiB2YXJpYWJsZXNbdi5uYW1lXSA9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgICAubWFwKHYgPT4gKHsgW3YubmFtZV06IHsgYXN0SWQ6IHYuaWQgfSB9KSlcbiAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICBjdXIgPSBzY29wZXNbY3VyXS5wYXJlbnRJZDtcbiAgICAgICAgICAgIH0gd2hpbGUgKGN1ciAhPSBudWxsKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBsZXQgYnVpbHRpbnMgPSB7XG4gICAgICAgICAgICBtc2c6IHsgYnVpbHRpbjogXCJtc2dcIiB9LFxuICAgICAgICAgICAgdHg6IHsgYnVpbHRpbjogXCJ0eFwiIH0sXG4gICAgICAgICAgICBibG9jazogeyBidWlsdGluOiBcImJsb2NrXCIgfSxcbiAgICAgICAgICAgIHRoaXM6IHsgYnVpbHRpbjogXCJ0aGlzXCIgfSxcbiAgICAgICAgICAgIG5vdzogeyBidWlsdGluOiBcIm5vd1wiIH1cbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgcmV0dXJuIHsgLi4udmFyaWFibGVzLCAuLi5idWlsdGlucyB9O1xuICAgICAgICB9XG4gICAgICApLFxuXG4gICAgICAvKipcbiAgICAgICAqIGRhdGEuY3VycmVudC5pZGVudGlmaWVycy5kZWZpbml0aW9ucyAobmFtZXNwYWNlKVxuICAgICAgICovXG4gICAgICBkZWZpbml0aW9uczoge1xuICAgICAgICAvKiBkYXRhLmN1cnJlbnQuaWRlbnRpZmllcnMuZGVmaW5pdGlvbnMgKHNlbGVjdG9yKVxuICAgICAgICAgKiBkZWZpbml0aW9ucyBmb3IgY3VycmVudCB2YXJpYWJsZXMsIGJ5IGlkZW50aWZpZXJcbiAgICAgICAgICovXG4gICAgICAgIF86IGNyZWF0ZUxlYWYoXG4gICAgICAgICAgW1wiL3ZpZXdzL3Njb3Blcy9pbmxpbmVkXCIsIFwiLi4vX1wiLCBcIi4vdGhpc1wiXSxcblxuICAgICAgICAgIChzY29wZXMsIGlkZW50aWZpZXJzLCB0aGlzRGVmaW5pdGlvbikgPT4ge1xuICAgICAgICAgICAgbGV0IHZhcmlhYmxlcyA9IE9iamVjdC5hc3NpZ24oXG4gICAgICAgICAgICAgIHt9LFxuICAgICAgICAgICAgICAuLi5PYmplY3QuZW50cmllcyhpZGVudGlmaWVycykubWFwKChbaWRlbnRpZmllciwgeyBhc3RJZCB9XSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChhc3RJZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAvL3dpbGwgYmUgdW5kZWZpbmVkIGZvciBidWlsdGluc1xuICAgICAgICAgICAgICAgICAgbGV0IHsgZGVmaW5pdGlvbiB9ID0gc2NvcGVzW2FzdElkXTtcbiAgICAgICAgICAgICAgICAgIHJldHVybiB7IFtpZGVudGlmaWVyXTogZGVmaW5pdGlvbiB9O1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4ge307IC8vc2tpcCBvdmVyIGJ1aWx0aW5zOyB3ZSdsbCBoYW5kbGUgdGhvc2Ugc2VwYXJhdGVseVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBsZXQgYnVpbHRpbnMgPSB7XG4gICAgICAgICAgICAgIG1zZzogRGVjb2RlVXRpbHMuRGVmaW5pdGlvbi5NU0dfREVGSU5JVElPTixcbiAgICAgICAgICAgICAgdHg6IERlY29kZVV0aWxzLkRlZmluaXRpb24uVFhfREVGSU5JVElPTixcbiAgICAgICAgICAgICAgYmxvY2s6IERlY29kZVV0aWxzLkRlZmluaXRpb24uQkxPQ0tfREVGSU5JVElPTixcbiAgICAgICAgICAgICAgbm93OiBEZWNvZGVVdGlscy5EZWZpbml0aW9uLnNwb29mVWludERlZmluaXRpb24oXCJub3dcIilcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvL29ubHkgaW5jbHVkZSB0aGlzIHdoZW4gaXQgaGFzIGEgcHJvcGVyIGRlZmluaXRpb25cbiAgICAgICAgICAgIGlmICh0aGlzRGVmaW5pdGlvbikge1xuICAgICAgICAgICAgICBidWlsdGlucy50aGlzID0gdGhpc0RlZmluaXRpb247XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4geyAuLi52YXJpYWJsZXMsIC4uLmJ1aWx0aW5zIH07XG4gICAgICAgICAgfVxuICAgICAgICApLFxuXG4gICAgICAgIC8qXG4gICAgICAgICAqIGRhdGEuY3VycmVudC5pZGVudGlmaWVycy5kZWZpbml0aW9ucy50aGlzXG4gICAgICAgICAqXG4gICAgICAgICAqIHJldHVybnMgYSBzcG9vZmVkIGRlZmluaXRpb24gZm9yIHRoZSB0aGlzIHZhcmlhYmxlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzOiBjcmVhdGVMZWFmKFxuICAgICAgICAgIFtcIi9jdXJyZW50L2NvbnRyYWN0XCJdLFxuICAgICAgICAgIGNvbnRyYWN0Tm9kZSA9PlxuICAgICAgICAgICAgY29udHJhY3ROb2RlICYmIGNvbnRyYWN0Tm9kZS5ub2RlVHlwZSA9PT0gXCJDb250cmFjdERlZmluaXRpb25cIlxuICAgICAgICAgICAgICA/IERlY29kZVV0aWxzLkRlZmluaXRpb24uc3Bvb2ZUaGlzRGVmaW5pdGlvbihcbiAgICAgICAgICAgICAgICAgIGNvbnRyYWN0Tm9kZS5uYW1lLFxuICAgICAgICAgICAgICAgICAgY29udHJhY3ROb2RlLmlkXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICA6IG51bGxcbiAgICAgICAgKVxuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiBkYXRhLmN1cnJlbnQuaWRlbnRpZmllcnMucmVmc1xuICAgICAgICpcbiAgICAgICAqIGN1cnJlbnQgdmFyaWFibGVzJyB2YWx1ZSByZWZzXG4gICAgICAgKi9cbiAgICAgIHJlZnM6IGNyZWF0ZUxlYWYoXG4gICAgICAgIFtcbiAgICAgICAgICBcIi9wcm9jL2Fzc2lnbm1lbnRzXCIsXG4gICAgICAgICAgXCIuL19cIixcbiAgICAgICAgICBcIi9jdXJyZW50L2Z1bmN0aW9uRGVwdGhcIiwgLy9mb3IgcHJ1bmluZyB0aGluZ3MgdG9vIGRlZXAgb24gc3RhY2tcbiAgICAgICAgICBcIi9jdXJyZW50L2FkZHJlc3NcIiAvL2ZvciBjb250cmFjdCB2YXJpYWJsZXNcbiAgICAgICAgXSxcblxuICAgICAgICAoYXNzaWdubWVudHMsIGlkZW50aWZpZXJzLCBjdXJyZW50RGVwdGgsIGFkZHJlc3MpID0+XG4gICAgICAgICAgT2JqZWN0LmFzc2lnbihcbiAgICAgICAgICAgIHt9LFxuICAgICAgICAgICAgLi4uT2JqZWN0LmVudHJpZXMoaWRlbnRpZmllcnMpLm1hcChcbiAgICAgICAgICAgICAgKFtpZGVudGlmaWVyLCB7IGFzdElkLCBidWlsdGluIH1dKSA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IGlkO1xuXG4gICAgICAgICAgICAgICAgLy9pcyB0aGlzIGFuIG9yZGluYXJ5IHZhcmlhYmxlIG9yIGEgYnVpbHRpbj9cbiAgICAgICAgICAgICAgICBpZiAoYXN0SWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgLy9pZiBub3QgYSBidWlsdGluLCBmaXJzdCBjaGVjayBpZiBpdCdzIGEgY29udHJhY3QgdmFyXG4gICAgICAgICAgICAgICAgICBsZXQgbWF0Y2hJZHMgPSAoYXNzaWdubWVudHMuYnlBc3RJZFthc3RJZF0gfHwgW10pLmZpbHRlcihcbiAgICAgICAgICAgICAgICAgICAgaWRIYXNoID0+IGFzc2lnbm1lbnRzLmJ5SWRbaWRIYXNoXS5hZGRyZXNzID09PSBhZGRyZXNzXG4gICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoSWRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgaWQgPSBtYXRjaElkc1swXTsgLy90aGVyZSBzaG91bGQgb25seSBiZSBvbmUhXG4gICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgIC8vaWYgbm90IGNvbnRyYWN0LCBpdCdzIGxvY2FsLCBzbyBmaW5kIHRoZSBpbm5lcm1vc3RcbiAgICAgICAgICAgICAgICAgIC8vKGJ1dCBub3QgYmV5b25kIGN1cnJlbnQgZGVwdGgpXG4gICAgICAgICAgICAgICAgICBpZiAoaWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgbWF0Y2hGcmFtZXMgPSAoYXNzaWdubWVudHMuYnlBc3RJZFthc3RJZF0gfHwgW10pXG4gICAgICAgICAgICAgICAgICAgICAgLm1hcChpZCA9PiBhc3NpZ25tZW50cy5ieUlkW2lkXS5zdGFja2ZyYW1lKVxuICAgICAgICAgICAgICAgICAgICAgIC5maWx0ZXIoc3RhY2tmcmFtZSA9PiBzdGFja2ZyYW1lICE9PSB1bmRlZmluZWQpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChtYXRjaEZyYW1lcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgLy90aGlzIGNoZWNrIGlzbid0ICpyZWFsbHkqXG4gICAgICAgICAgICAgICAgICAgICAgLy9uZWNlc3NhcnksIGJ1dCBtYXkgYXMgd2VsbCBwcmV2ZW50IHN0dXBpZCBzdHVmZlxuICAgICAgICAgICAgICAgICAgICAgIGxldCBtYXhNYXRjaCA9IE1hdGgubWluKFxuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudERlcHRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgTWF0aC5tYXgoLi4ubWF0Y2hGcmFtZXMpXG4gICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICBpZCA9IHN0YWJsZUtlY2NhazI1Nih7IGFzdElkLCBzdGFja2ZyYW1lOiBtYXhNYXRjaCB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAvL290aGVyd2lzZSwgaXQncyBhIGJ1aWx0aW5cbiAgICAgICAgICAgICAgICAgIC8vTk9URTogZm9yIG5vdyB3ZSBhc3N1bWUgdGhlcmUgaXMgb25seSBvbmUgYXNzaWdubWVudCBwZXJcbiAgICAgICAgICAgICAgICAgIC8vYnVpbHRpbiwgYnV0IHRoaXMgd2lsbCBjaGFuZ2UgaW4gdGhlIGZ1dHVyZVxuICAgICAgICAgICAgICAgICAgaWQgPSBhc3NpZ25tZW50cy5ieUJ1aWx0aW5bYnVpbHRpbl1bMF07XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy9pZiB3ZSBzdGlsbCBkaWRuJ3QgZmluZCBpdCwgb2ggd2VsbFxuXG4gICAgICAgICAgICAgICAgbGV0IHsgcmVmIH0gPSBhc3NpZ25tZW50cy5ieUlkW2lkXSB8fCB7fTtcbiAgICAgICAgICAgICAgICBpZiAoIXJlZikge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgW2lkZW50aWZpZXJdOiByZWZcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICApXG4gICAgICAgICAgKVxuICAgICAgKVxuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogZGF0YS5uZXh0XG4gICAqL1xuICBuZXh0OiB7XG4gICAgLyoqXG4gICAgICogZGF0YS5uZXh0LnN0YXRlXG4gICAgICogWWVzLCBJJ20ganVzdCByZXBlYXRpbmcgdGhlIGNvZGUgZm9yIGRhdGEuY3VycmVudC5zdGF0ZS5zdGFjayBoZXJlO1xuICAgICAqIG5vdCB3b3J0aCB0aGUgdHJvdWJsZSB0byBmYWN0b3Igb3V0XG4gICAgICovXG4gICAgc3RhdGU6IHtcbiAgICAgIC8qKlxuICAgICAgICogZGF0YS5uZXh0LnN0YXRlLnN0YWNrXG4gICAgICAgKi9cbiAgICAgIHN0YWNrOiBjcmVhdGVMZWFmKFxuICAgICAgICBbZXZtLm5leHQuc3RhdGUuc3RhY2tdLFxuXG4gICAgICAgIHdvcmRzID0+ICh3b3JkcyB8fCBbXSkubWFwKHdvcmQgPT4gRGVjb2RlVXRpbHMuQ29udmVyc2lvbi50b0J5dGVzKHdvcmQpKVxuICAgICAgKVxuICAgIH0sXG5cbiAgICAvL0hBQ0sgV0FSTklOR1xuICAgIC8vdGhlIGZvbGxvd2luZyBzZWxlY3RvcnMgZGVwZW5kIG9uIHNvbGlkaXR5Lm5leHRcbiAgICAvL2RvIG5vdCB1c2UgdGhlbSB3aGVuIHRoZSBjdXJyZW50IGluc3RydWN0aW9uIGlzIGEgY29udGV4dCBjaGFuZ2UhXG5cbiAgICAvKipcbiAgICAgKiBkYXRhLm5leHQubm9kZVxuICAgICAqL1xuICAgIG5vZGU6IGNyZWF0ZUxlYWYoW3NvbGlkaXR5Lm5leHQubm9kZV0sIGlkZW50aXR5KSxcblxuICAgIC8qKlxuICAgICAqIGRhdGEubmV4dC5tb2RpZmllckludm9jYXRpb25cbiAgICAgKiBOb3RlOiB5ZXMsIEknbSBqdXN0IHJlcGVhdGluZyB0aGUgY29kZSBmcm9tIGRhdGEuY3VycmVudCBoZXJlIGJ1dCB3aXRoXG4gICAgICogaW52YWxpZCBhZGRlZFxuICAgICAqL1xuICAgIG1vZGlmaWVySW52b2NhdGlvbjogY3JlYXRlTGVhZihcbiAgICAgIFtcIi4vbm9kZVwiLCBcIi92aWV3cy9zY29wZXMvaW5saW5lZFwiLCBldm0uY3VycmVudC5zdGVwLmlzQ29udGV4dENoYW5nZV0sXG4gICAgICAobm9kZSwgc2NvcGVzLCBpbnZhbGlkKSA9PiB7XG4gICAgICAgIC8vZG9uJ3QgYXR0ZW1wdCB0aGlzIGF0IGEgY29udGV4dCBjaGFuZ2UhXG4gICAgICAgIC8vKGFsc28gZG9uJ3QgYXR0ZW1wdCB0aGlzIGlmIHdlIGNhbid0IGZpbmQgdGhlIG5vZGUgZm9yIHdoYXRldmVyXG4gICAgICAgIC8vcmVhc29uKVxuICAgICAgICBpZiAoaW52YWxpZCB8fCAhbm9kZSkge1xuICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdHlwZXMgPSBbXG4gICAgICAgICAgXCJNb2RpZmllckludm9jYXRpb25cIixcbiAgICAgICAgICBcIkluaGVyaXRhbmNlU3BlY2lmaWVyXCIsXG4gICAgICAgICAgXCJTb3VyY2VVbml0XCJcbiAgICAgICAgXTtcbiAgICAgICAgLy9hZ2FpbiwgU291cmNlVW5pdCBpbmNsdWRlZCBhcyBmYWxsYmFja1xuICAgICAgICByZXR1cm4gZmluZEFuY2VzdG9yT2ZUeXBlKG5vZGUsIHR5cGVzLCBzY29wZXMpO1xuICAgICAgfVxuICAgICksXG5cbiAgICAvKlxuICAgICAqIGRhdGEubmV4dC5tb2RpZmllckJlaW5nSW52b2tlZFxuICAgICAqL1xuICAgIG1vZGlmaWVyQmVpbmdJbnZva2VkOiBjcmVhdGVMZWFmKFxuICAgICAgW1xuICAgICAgICBcIi4vbW9kaWZpZXJJbnZvY2F0aW9uXCIsXG4gICAgICAgIFwiL3ZpZXdzL3Njb3Blcy9pbmxpbmVkXCIsXG4gICAgICAgIGV2bS5jdXJyZW50LnN0ZXAuaXNDb250ZXh0Q2hhbmdlXG4gICAgICBdLFxuICAgICAgKGludm9jYXRpb24sIHNjb3BlcywgaW52YWxpZCkgPT4ge1xuICAgICAgICBpZiAoaW52YWxpZCB8fCAhaW52b2NhdGlvbiB8fCBpbnZvY2F0aW9uLm5vZGVUeXBlID09PSBcIlNvdXJjZVVuaXRcIikge1xuICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbW9kaWZpZXJGb3JJbnZvY2F0aW9uKGludm9jYXRpb24sIHNjb3Blcyk7XG4gICAgICB9XG4gICAgKVxuICAgIC8vRU5EIEhBQ0sgV0FSTklOR1xuICB9LFxuXG4gIC8qKlxuICAgKiBkYXRhLm5leHRNYXBwZWRcbiAgICovXG4gIG5leHRNYXBwZWQ6IHtcbiAgICAvKipcbiAgICAgKiBkYXRhLm5leHRNYXBwZWQuc3RhdGVcbiAgICAgKiBZZXMsIEknbSBqdXN0IHJlcGVhdGluZyB0aGUgY29kZSBmb3IgZGF0YS5jdXJyZW50LnN0YXRlLnN0YWNrIGhlcmU7XG4gICAgICogbm90IHdvcnRoIHRoZSB0cm91YmxlIHRvIGZhY3RvciBvdXRcbiAgICAgKiBIQUNLOiB0aGlzIGFzc3VtZXMgd2UncmUgbm90IGFib3V0IHRvIGNoYW5nZSBjb250ZXh0ISBkb24ndCB1c2UgdGhpcyBpZiB3ZVxuICAgICAqIGFyZSFcbiAgICAgKi9cbiAgICBzdGF0ZToge1xuICAgICAgLyoqXG4gICAgICAgKiBkYXRhLm5leHRNYXBwZWQuc3RhdGUuc3RhY2tcbiAgICAgICAqL1xuICAgICAgc3RhY2s6IGNyZWF0ZUxlYWYoXG4gICAgICAgIFtzb2xpZGl0eS5jdXJyZW50Lm5leHRNYXBwZWRdLFxuXG4gICAgICAgIHN0ZXAgPT5cbiAgICAgICAgICAoKHN0ZXAgfHwge30pLnN0YWNrIHx8IFtdKS5tYXAod29yZCA9PlxuICAgICAgICAgICAgRGVjb2RlVXRpbHMuQ29udmVyc2lvbi50b0J5dGVzKHdvcmQpXG4gICAgICAgICAgKVxuICAgICAgKVxuICAgIH1cbiAgfVxufSk7XG5cbmV4cG9ydCBkZWZhdWx0IGRhdGE7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gbGliL2RhdGEvc2VsZWN0b3JzL2luZGV4LmpzIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwianNvbi1wb2ludGVyXCIpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGV4dGVybmFsIFwianNvbi1wb2ludGVyXCJcbi8vIG1vZHVsZSBpZCA9IDIyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCBkZWJ1Z01vZHVsZSBmcm9tIFwiZGVidWdcIjtcbmNvbnN0IGRlYnVnID0gZGVidWdNb2R1bGUoXCJkZWJ1Z2dlcjpldm06c2FnYXNcIik7XG5cbmltcG9ydCB7IHB1dCwgdGFrZUV2ZXJ5LCBzZWxlY3QgfSBmcm9tIFwicmVkdXgtc2FnYS9lZmZlY3RzXCI7XG5pbXBvcnQgeyBwcmVmaXhOYW1lLCBrZWNjYWsyNTYgfSBmcm9tIFwibGliL2hlbHBlcnNcIjtcblxuaW1wb3J0IHsgVElDSyB9IGZyb20gXCJsaWIvdHJhY2UvYWN0aW9uc1wiO1xuaW1wb3J0ICogYXMgYWN0aW9ucyBmcm9tIFwiLi4vYWN0aW9uc1wiO1xuXG5pbXBvcnQgZXZtIGZyb20gXCIuLi9zZWxlY3RvcnNcIjtcblxuaW1wb3J0ICogYXMgdHJhY2UgZnJvbSBcImxpYi90cmFjZS9zYWdhc1wiO1xuXG4vKipcbiAqIEFkZHMgRVZNIGJ5dGVjb2RlIGNvbnRleHRcbiAqXG4gKiBAcmV0dXJuIHtzdHJpbmd9IElEICgweC1wcmVmaXhlZCBrZWNjYWsgb2YgYmluYXJ5KVxuICovXG5leHBvcnQgZnVuY3Rpb24qIGFkZENvbnRleHQoY29udGV4dCkge1xuICBjb25zdCBjb250ZXh0SGFzaCA9IGtlY2NhazI1Nih7IHR5cGU6IFwic3RyaW5nXCIsIHZhbHVlOiBjb250ZXh0LmJpbmFyeSB9KTtcbiAgLy9OT1RFOiB3ZSB0YWtlIGhhc2ggYXMgKnN0cmluZyosIG5vdCBhcyBieXRlcywgYmVjYXVzZSB0aGUgYmluYXJ5IG1heVxuICAvL2NvbnRhaW4gbGluayByZWZlcmVuY2VzIVxuXG4gIGRlYnVnKFwiY29udGV4dCAlT1wiLCBjb250ZXh0KTtcbiAgeWllbGQgcHV0KGFjdGlvbnMuYWRkQ29udGV4dChjb250ZXh0KSk7XG5cbiAgcmV0dXJuIGNvbnRleHRIYXNoO1xufVxuXG5leHBvcnQgZnVuY3Rpb24qIG5vcm1hbGl6ZUNvbnRleHRzKCkge1xuICB5aWVsZCBwdXQoYWN0aW9ucy5ub3JtYWxpemVDb250ZXh0cygpKTtcbn1cblxuLyoqXG4gKiBBZGRzIGtub3duIGRlcGxveWVkIGluc3RhbmNlIG9mIGJpbmFyeSBhdCBhZGRyZXNzXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGJpbmFyeSAtIG1heSBiZSB1bmRlZmluZWQgKGUuZy4gcHJlY29tcGlsZXMpXG4gKiBAcmV0dXJuIHtzdHJpbmd9IElEICgweC1wcmVmaXhlZCBrZWNjYWsgb2YgYmluYXJ5KVxuICovXG5leHBvcnQgZnVuY3Rpb24qIGFkZEluc3RhbmNlKGFkZHJlc3MsIGJpbmFyeSkge1xuICBsZXQgc2VhcmNoID0geWllbGQgc2VsZWN0KGV2bS5pbmZvLmJpbmFyaWVzLnNlYXJjaCk7XG4gIGxldCBjb250ZXh0ID0gc2VhcmNoKGJpbmFyeSk7XG5cbiAgLy9ub3csIHdoZXRoZXIgd2UgbmVlZGVkIGEgbmV3IGNvbnRleHQgb3Igbm90LCBhZGQgdGhlIGluc3RhbmNlXG4gIHlpZWxkIHB1dChhY3Rpb25zLmFkZEluc3RhbmNlKGFkZHJlc3MsIGNvbnRleHQsIGJpbmFyeSkpO1xuXG4gIHJldHVybiBjb250ZXh0O1xufVxuXG5leHBvcnQgZnVuY3Rpb24qIGJlZ2luKHtcbiAgYWRkcmVzcyxcbiAgYmluYXJ5LFxuICBkYXRhLFxuICBzdG9yYWdlQWRkcmVzcyxcbiAgc3RhdHVzLFxuICBzZW5kZXIsXG4gIHZhbHVlLFxuICBnYXNwcmljZSxcbiAgYmxvY2tcbn0pIHtcbiAgeWllbGQgcHV0KGFjdGlvbnMuc2F2ZUdsb2JhbHMoc2VuZGVyLCBnYXNwcmljZSwgYmxvY2spKTtcbiAgeWllbGQgcHV0KGFjdGlvbnMuc2F2ZVN0YXR1cyhzdGF0dXMpKTtcbiAgZGVidWcoXCJjb2RleDogJU9cIiwgeWllbGQgc2VsZWN0KGV2bS5jdXJyZW50LmNvZGV4KSk7XG4gIGlmIChhZGRyZXNzKSB7XG4gICAgeWllbGQgcHV0KGFjdGlvbnMuY2FsbChhZGRyZXNzLCBkYXRhLCBzdG9yYWdlQWRkcmVzcywgc2VuZGVyLCB2YWx1ZSkpO1xuICB9IGVsc2Uge1xuICAgIHlpZWxkIHB1dChhY3Rpb25zLmNyZWF0ZShiaW5hcnksIHN0b3JhZ2VBZGRyZXNzLCBzZW5kZXIsIHZhbHVlKSk7XG4gIH1cbn1cblxuZnVuY3Rpb24qIHRpY2tTYWdhKCkge1xuICBkZWJ1ZyhcImdvdCBUSUNLXCIpO1xuXG4gIHlpZWxkKiBjYWxsc3RhY2tBbmRDb2RleFNhZ2EoKTtcbiAgeWllbGQqIHRyYWNlLnNpZ25hbFRpY2tTYWdhQ29tcGxldGlvbigpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24qIGNhbGxzdGFja0FuZENvZGV4U2FnYSgpIHtcbiAgaWYgKHlpZWxkIHNlbGVjdChldm0uY3VycmVudC5zdGVwLmlzRXhjZXB0aW9uYWxIYWx0aW5nKSkge1xuICAgIC8vbGV0J3MgaGFuZGxlIHRoaXMgY2FzZSBmaXJzdCBzbyB3ZSBjYW4gYmUgc3VyZSBldmVyeXRoaW5nIGVsc2UgaXMgKm5vdCpcbiAgICAvL2FuIGV4Y2VwdGlvbmFsIGhhbHRcbiAgICBkZWJ1ZyhcImV4Y2VwdGlvbmFsIGhhbHQhXCIpO1xuXG4gICAgeWllbGQgcHV0KGFjdGlvbnMuZmFpbCgpKTtcbiAgfSBlbHNlIGlmICh5aWVsZCBzZWxlY3QoZXZtLmN1cnJlbnQuc3RlcC5pc0NhbGwpKSB7XG4gICAgZGVidWcoXCJnb3QgY2FsbFwiKTtcbiAgICAvLyBpZiB0aGVyZSBpcyBubyBiaW5hcnkgKGUuZy4gaW4gdGhlIGNhc2Ugb2YgcHJlY29tcGlsZWQgY29udHJhY3RzIG9yXG4gICAgLy8gZXh0ZXJuYWxseSBvd25lZCBhY2NvdW50cyksIHRoZW4gdGhlcmUgd2lsbCBiZSBubyB0cmFjZSBzdGVwcyBmb3IgdGhlXG4gICAgLy8gY2FsbGVkIGNvZGUsIGFuZCBzbyB3ZSBzaG91bGRuJ3QgdGVsbCB0aGUgZGVidWdnZXIgdGhhdCB3ZSdyZSBlbnRlcmluZ1xuICAgIC8vIGFub3RoZXIgZXhlY3V0aW9uIGNvbnRleHRcbiAgICBpZiAoeWllbGQgc2VsZWN0KGV2bS5jdXJyZW50LnN0ZXAuY2FsbHNQcmVjb21waWxlT3JFeHRlcm5hbCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBsZXQgYWRkcmVzcyA9IHlpZWxkIHNlbGVjdChldm0uY3VycmVudC5zdGVwLmNhbGxBZGRyZXNzKTtcbiAgICBsZXQgZGF0YSA9IHlpZWxkIHNlbGVjdChldm0uY3VycmVudC5zdGVwLmNhbGxEYXRhKTtcblxuICAgIGRlYnVnKFwiY2FsbGluZyBhZGRyZXNzICVzXCIsIGFkZHJlc3MpO1xuXG4gICAgaWYgKHlpZWxkIHNlbGVjdChldm0uY3VycmVudC5zdGVwLmlzRGVsZWdhdGVDYWxsU3RyaWN0KSkge1xuICAgICAgLy9pZiBkZWxlZ2F0aW5nLCBsZWF2ZSBzdG9yYWdlQWRkcmVzcywgc2VuZGVyLCBhbmQgdmFsdWUgdGhlIHNhbWVcbiAgICAgIGxldCB7IHN0b3JhZ2VBZGRyZXNzLCBzZW5kZXIsIHZhbHVlIH0gPSB5aWVsZCBzZWxlY3QoZXZtLmN1cnJlbnQuY2FsbCk7XG4gICAgICB5aWVsZCBwdXQoYWN0aW9ucy5jYWxsKGFkZHJlc3MsIGRhdGEsIHN0b3JhZ2VBZGRyZXNzLCBzZW5kZXIsIHZhbHVlKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vdGhpcyBicmFuY2ggY292ZXJzIENBTEwsIENBTExDT0RFLCBhbmQgU1RBVElDQ0FMTFxuICAgICAgbGV0IGN1cnJlbnRDYWxsID0geWllbGQgc2VsZWN0KGV2bS5jdXJyZW50LmNhbGwpO1xuICAgICAgbGV0IHN0b3JhZ2VBZGRyZXNzID0gKHlpZWxkIHNlbGVjdChldm0uY3VycmVudC5zdGVwLmlzRGVsZWdhdGVDYWxsQnJvYWQpKVxuICAgICAgICA/IGN1cnJlbnRDYWxsLnN0b3JhZ2VBZGRyZXNzIC8vZm9yIENBTExDT0RFXG4gICAgICAgIDogYWRkcmVzcztcbiAgICAgIGxldCBzZW5kZXIgPSBjdXJyZW50Q2FsbC5zdG9yYWdlQWRkcmVzczsgLy9ub3QgdGhlIGNvZGUgYWRkcmVzcyFcbiAgICAgIGxldCB2YWx1ZSA9IHlpZWxkIHNlbGVjdChldm0uY3VycmVudC5zdGVwLmNhbGxWYWx1ZSk7IC8vMCBpZiBzdGF0aWNcbiAgICAgIHlpZWxkIHB1dChhY3Rpb25zLmNhbGwoYWRkcmVzcywgZGF0YSwgc3RvcmFnZUFkZHJlc3MsIHNlbmRlciwgdmFsdWUpKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoeWllbGQgc2VsZWN0KGV2bS5jdXJyZW50LnN0ZXAuaXNDcmVhdGUpKSB7XG4gICAgZGVidWcoXCJnb3QgY3JlYXRlXCIpO1xuICAgIGxldCBiaW5hcnkgPSB5aWVsZCBzZWxlY3QoZXZtLmN1cnJlbnQuc3RlcC5jcmVhdGVCaW5hcnkpO1xuICAgIGxldCBjcmVhdGVkQWRkcmVzcyA9IHlpZWxkIHNlbGVjdChldm0uY3VycmVudC5zdGVwLmNyZWF0ZWRBZGRyZXNzKTtcbiAgICBsZXQgdmFsdWUgPSB5aWVsZCBzZWxlY3QoZXZtLmN1cnJlbnQuc3RlcC5jcmVhdGVWYWx1ZSk7XG4gICAgbGV0IHNlbmRlciA9ICh5aWVsZCBzZWxlY3QoZXZtLmN1cnJlbnQuY2FsbCkpLnN0b3JhZ2VBZGRyZXNzO1xuICAgIC8vbm90IHRoZSBjb2RlIGFkZHJlc3MhXG5cbiAgICB5aWVsZCBwdXQoYWN0aW9ucy5jcmVhdGUoYmluYXJ5LCBjcmVhdGVkQWRkcmVzcywgc2VuZGVyLCB2YWx1ZSkpO1xuICAgIC8vYXMgYWJvdmUsIHN0b3JhZ2VBZGRyZXNzIGhhbmRsZXMgd2hlbiBjYWxsaW5nIGZyb20gYSBjcmVhdGlvbiBjYWxsXG4gIH0gZWxzZSBpZiAoeWllbGQgc2VsZWN0KGV2bS5jdXJyZW50LnN0ZXAuaXNIYWx0aW5nKSkge1xuICAgIGRlYnVnKFwiZ290IHJldHVyblwiKTtcblxuICAgIGxldCB7IGJpbmFyeSwgc3RvcmFnZUFkZHJlc3MgfSA9IHlpZWxkIHNlbGVjdChldm0uY3VycmVudC5jYWxsKTtcblxuICAgIGlmIChiaW5hcnkpIHtcbiAgICAgIC8vaWYgd2UncmUgcmV0dXJuaW5nIGZyb20gYSBzdWNjZXNzZnVsIGNyZWF0aW9uIGNhbGwsIGxldCdzIGxvZyB0aGVcbiAgICAgIC8vcmVzdWx0XG4gICAgICBsZXQgcmV0dXJuZWRCaW5hcnkgPSB5aWVsZCBzZWxlY3QoZXZtLmN1cnJlbnQuc3RlcC5yZXR1cm5WYWx1ZSk7XG4gICAgICBsZXQgc2VhcmNoID0geWllbGQgc2VsZWN0KGV2bS5pbmZvLmJpbmFyaWVzLnNlYXJjaCk7XG4gICAgICBsZXQgcmV0dXJuZWRDb250ZXh0ID0gc2VhcmNoKHJldHVybmVkQmluYXJ5KTtcbiAgICAgIHlpZWxkIHB1dChcbiAgICAgICAgYWN0aW9ucy5yZXR1cm5DcmVhdGUoc3RvcmFnZUFkZHJlc3MsIHJldHVybmVkQmluYXJ5LCByZXR1cm5lZENvbnRleHQpXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICB5aWVsZCBwdXQoYWN0aW9ucy5yZXR1cm5DYWxsKCkpO1xuICAgIH1cbiAgfSBlbHNlIGlmICh5aWVsZCBzZWxlY3QoZXZtLmN1cnJlbnQuc3RlcC50b3VjaGVzU3RvcmFnZSkpIHtcbiAgICBsZXQgc3RvcmFnZUFkZHJlc3MgPSAoeWllbGQgc2VsZWN0KGV2bS5jdXJyZW50LmNhbGwpKS5zdG9yYWdlQWRkcmVzcztcbiAgICBsZXQgc2xvdCA9IHlpZWxkIHNlbGVjdChldm0uY3VycmVudC5zdGVwLnN0b3JhZ2VBZmZlY3RlZCk7XG4gICAgLy9ub3RlIHdlIGdldCBuZXh0IHN0b3JhZ2UsIHNpbmNlIHdlJ3JlIHVwZGF0aW5nIHRvIHRoYXRcbiAgICBsZXQgc3RvcmFnZSA9IHlpZWxkIHNlbGVjdChldm0ubmV4dC5zdGF0ZS5zdG9yYWdlKTtcbiAgICAvL25vcm1hbGx5IHdlJ2QgbmVlZCBhIDAgZmFsbGJhY2sgZm9yIHRoaXMgbmV4dCBsaW5lLCBidXQgaW4gdGhpcyBjYXNlIHdlXG4gICAgLy9jYW4gYmUgc3VyZSB0aGUgdmFsdWUgd2lsbCBiZSB0aGVyZSwgc2luY2Ugd2UncmUgdG91Y2hpbmcgdGhhdCBzdG9yYWdlXG4gICAgaWYgKHlpZWxkIHNlbGVjdChldm0uY3VycmVudC5zdGVwLmlzU3RvcmUpKSB7XG4gICAgICB5aWVsZCBwdXQoYWN0aW9ucy5zdG9yZShzdG9yYWdlQWRkcmVzcywgc2xvdCwgc3RvcmFnZVtzbG90XSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvL290aGVyd2lzZSwgaXQncyBhIGxvYWRcbiAgICAgIHlpZWxkIHB1dChhY3Rpb25zLmxvYWQoc3RvcmFnZUFkZHJlc3MsIHNsb3QsIHN0b3JhZ2Vbc2xvdF0pKTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uKiByZXNldCgpIHtcbiAgbGV0IGluaXRpYWxDYWxsID0geWllbGQgc2VsZWN0KGV2bS50cmFuc2FjdGlvbi5pbml0aWFsQ2FsbCk7XG4gIHlpZWxkIHB1dChhY3Rpb25zLnJlc2V0KCkpO1xuICB5aWVsZCBwdXQoaW5pdGlhbENhbGwpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24qIHVubG9hZCgpIHtcbiAgeWllbGQgcHV0KGFjdGlvbnMudW5sb2FkVHJhbnNhY3Rpb24oKSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiogc2FnYSgpIHtcbiAgeWllbGQgdGFrZUV2ZXJ5KFRJQ0ssIHRpY2tTYWdhKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgcHJlZml4TmFtZShcImV2bVwiLCBzYWdhKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBsaWIvZXZtL3NhZ2FzL2luZGV4LmpzIiwiaW1wb3J0IGRlYnVnTW9kdWxlIGZyb20gXCJkZWJ1Z1wiO1xuY29uc3QgZGVidWcgPSBkZWJ1Z01vZHVsZShcImRlYnVnZ2VyOmNvbnRyb2xsZXI6c2VsZWN0b3JzXCIpOyAvL2VzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcblxuaW1wb3J0IHsgY3JlYXRlU2VsZWN0b3JUcmVlLCBjcmVhdGVMZWFmIH0gZnJvbSBcInJlc2VsZWN0LXRyZWVcIjtcblxuaW1wb3J0IGV2bSBmcm9tIFwibGliL2V2bS9zZWxlY3RvcnNcIjtcbmltcG9ydCBzb2xpZGl0eSBmcm9tIFwibGliL3NvbGlkaXR5L3NlbGVjdG9yc1wiO1xuaW1wb3J0IHRyYWNlIGZyb20gXCJsaWIvdHJhY2Uvc2VsZWN0b3JzXCI7XG5cbmltcG9ydCB7IGFueU5vblNraXBwZWRJblJhbmdlIH0gZnJvbSBcImxpYi9hc3QvbWFwXCI7XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuY29uc3QgaWRlbnRpdHkgPSB4ID0+IHg7XG5cbi8qKlxuICogY29udHJvbGxlclxuICovXG5jb25zdCBjb250cm9sbGVyID0gY3JlYXRlU2VsZWN0b3JUcmVlKHtcbiAgLyoqXG4gICAqIGNvbnRyb2xsZXIuc3RhdGVcbiAgICovXG4gIHN0YXRlOiBzdGF0ZSA9PiBzdGF0ZS5jb250cm9sbGVyLFxuICAvKipcbiAgICogY29udHJvbGxlci5jdXJyZW50XG4gICAqL1xuICBjdXJyZW50OiB7XG4gICAgLyoqXG4gICAgICogY29udHJvbGxlci5jdXJyZW50LmZ1bmN0aW9uRGVwdGhcbiAgICAgKi9cbiAgICBmdW5jdGlvbkRlcHRoOiBjcmVhdGVMZWFmKFtzb2xpZGl0eS5jdXJyZW50LmZ1bmN0aW9uRGVwdGhdLCBpZGVudGl0eSksXG5cbiAgICAvKipcbiAgICAgKiBjb250cm9sbGVyLmN1cnJlbnQuZXhlY3V0aW9uQ29udGV4dFxuICAgICAqL1xuICAgIGV4ZWN1dGlvbkNvbnRleHQ6IGNyZWF0ZUxlYWYoW2V2bS5jdXJyZW50LmNhbGxdLCBpZGVudGl0eSksXG5cbiAgICAvKipcbiAgICAgKiBjb250cm9sbGVyLmN1cnJlbnQud2lsbEp1bXBcbiAgICAgKi9cbiAgICB3aWxsSnVtcDogY3JlYXRlTGVhZihbZXZtLmN1cnJlbnQuc3RlcC5pc0p1bXBdLCBpZGVudGl0eSksXG5cbiAgICAvKipcbiAgICAgKiBjb250cm9sbGVyLmN1cnJlbnQubG9jYXRpb25cbiAgICAgKi9cbiAgICBsb2NhdGlvbjoge1xuICAgICAgLyoqXG4gICAgICAgKiBjb250cm9sbGVyLmN1cnJlbnQubG9jYXRpb24uc291cmNlUmFuZ2VcbiAgICAgICAqL1xuICAgICAgc291cmNlUmFuZ2U6IGNyZWF0ZUxlYWYoXG4gICAgICAgIFtzb2xpZGl0eS5jdXJyZW50LnNvdXJjZVJhbmdlLCBcIi9jdXJyZW50L3RyYWNlL2xvYWRlZFwiXSxcbiAgICAgICAgKHJhbmdlLCBsb2FkZWQpID0+IChsb2FkZWQgPyByYW5nZSA6IG51bGwpXG4gICAgICApLFxuXG4gICAgICAvKipcbiAgICAgICAqIGNvbnRyb2xsZXIuY3VycmVudC5sb2NhdGlvbi5zb3VyY2VcbiAgICAgICAqL1xuICAgICAgc291cmNlOiBjcmVhdGVMZWFmKFxuICAgICAgICBbc29saWRpdHkuY3VycmVudC5zb3VyY2UsIFwiL2N1cnJlbnQvdHJhY2UvbG9hZGVkXCJdLFxuICAgICAgICAoc291cmNlLCBsb2FkZWQpID0+IChsb2FkZWQgPyBzb3VyY2UgOiBudWxsKVxuICAgICAgKSxcblxuICAgICAgLyoqXG4gICAgICAgKiBjb250cm9sbGVyLmN1cnJlbnQubG9jYXRpb24ubm9kZVxuICAgICAgICovXG4gICAgICBub2RlOiBjcmVhdGVMZWFmKFxuICAgICAgICBbc29saWRpdHkuY3VycmVudC5ub2RlLCBcIi9jdXJyZW50L3RyYWNlL2xvYWRlZFwiXSxcbiAgICAgICAgKG5vZGUsIGxvYWRlZCkgPT4gKGxvYWRlZCA/IG5vZGUgOiBudWxsKVxuICAgICAgKSxcblxuICAgICAgLyoqXG4gICAgICAgKiBjb250cm9sbGVyLmN1cnJlbnQubG9jYXRpb24uaXNNdWx0aWxpbmVcbiAgICAgICAqL1xuICAgICAgaXNNdWx0aWxpbmU6IGNyZWF0ZUxlYWYoXG4gICAgICAgIFtzb2xpZGl0eS5jdXJyZW50LmlzTXVsdGlsaW5lLCBcIi9jdXJyZW50L3RyYWNlL2xvYWRlZFwiXSxcbiAgICAgICAgKHJhdywgbG9hZGVkKSA9PiAobG9hZGVkID8gcmF3IDogZmFsc2UpXG4gICAgICApXG4gICAgfSxcblxuICAgIC8qXG4gICAgICogY29udHJvbGxlci5jdXJyZW50LnRyYWNlXG4gICAgICovXG4gICAgdHJhY2U6IHtcbiAgICAgIC8qKlxuICAgICAgICogY29udHJvbGxlci5jdXJyZW50LnRyYWNlLmZpbmlzaGVkXG4gICAgICAgKi9cbiAgICAgIGZpbmlzaGVkOiBjcmVhdGVMZWFmKFt0cmFjZS5maW5pc2hlZF0sIGlkZW50aXR5KSxcblxuICAgICAgLyoqXG4gICAgICAgKiBjb250cm9sbGVyLmN1cnJlbnQudHJhY2UubG9hZGVkXG4gICAgICAgKi9cbiAgICAgIGxvYWRlZDogY3JlYXRlTGVhZihbdHJhY2UubG9hZGVkXSwgaWRlbnRpdHkpXG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBjb250cm9sbGVyLmJyZWFrcG9pbnRzIChuYW1lc3BhY2UpXG4gICAqL1xuICBicmVha3BvaW50czoge1xuICAgIC8qKlxuICAgICAqIGNvbnRyb2xsZXIuYnJlYWtwb2ludHMgKHNlbGVjdG9yKVxuICAgICAqL1xuICAgIF86IGNyZWF0ZUxlYWYoW1wiL3N0YXRlXCJdLCBzdGF0ZSA9PiBzdGF0ZS5icmVha3BvaW50cyksXG5cbiAgICAvKipcbiAgICAgKiBjb250cm9sbGVyLmJyZWFrcG9pbnRzLnJlc29sdmVyIChzZWxlY3RvcilcbiAgICAgKiB0aGlzIHNlbGVjdG9yIHJldHVybnMgYSBmdW5jdGlvbiB0aGF0IGFkanVzdHMgYSBnaXZlbiBsaW5lLWJhc2VkXG4gICAgICogYnJlYWtwb2ludCAob24gbm9kZS1iYXNlZCBicmVha3BvaW50cyBpdCBzaW1wbHkgcmV0dXJucyB0aGUgaW5wdXQpIGJ5XG4gICAgICogcmVwZWF0ZWRseSBtb3ZpbmcgaXQgZG93biBhIGxpbmUgdW50aWwgaXQgbGFuZHMgb24gYSBsaW5lIHdoZXJlIHRoZXJlJ3NcbiAgICAgKiBhY3R1YWxseSBzb21ld2hlcmUgdG8gYnJlYWsuICBpZiBubyBzdWNoIGxpbmUgZXhpc3RzIGJleW9uZCB0aGF0IHBvaW50LCBpdFxuICAgICAqIHJldHVybnMgbnVsbCBpbnN0ZWFkLlxuICAgICAqL1xuICAgIHJlc29sdmVyOiBjcmVhdGVMZWFmKFtzb2xpZGl0eS5pbmZvLnNvdXJjZXNdLCBzb3VyY2VzID0+IGJyZWFrcG9pbnQgPT4ge1xuICAgICAgbGV0IGFkanVzdGVkQnJlYWtwb2ludDtcbiAgICAgIGlmIChicmVha3BvaW50Lm5vZGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBsZXQgbGluZSA9IGJyZWFrcG9pbnQubGluZTtcbiAgICAgICAgbGV0IHsgc291cmNlLCBhc3QgfSA9IHNvdXJjZXNbYnJlYWtwb2ludC5zb3VyY2VJZF07XG4gICAgICAgIGxldCBsaW5lTGVuZ3RocyA9IHNvdXJjZS5zcGxpdChcIlxcblwiKS5tYXAobGluZSA9PiBsaW5lLmxlbmd0aCk7XG4gICAgICAgIC8vd2h5IGRvZXMgbmVpdGhlciBKUyBub3IgbG9kYXNoIGhhdmUgYSBzY2FuIGZ1bmN0aW9uIGxpa2UgSGFza2VsbD8/XG4gICAgICAgIC8vZ3Vlc3Mgd2UnbGwgaGF2ZSB0byBkbyBvdXIgc2NhbiBtYW51YWxseVxuICAgICAgICBsZXQgbGluZVN0YXJ0cyA9IFswXTtcbiAgICAgICAgZm9yIChsZXQgbGVuZ3RoIG9mIGxpbmVMZW5ndGhzKSB7XG4gICAgICAgICAgbGluZVN0YXJ0cy5wdXNoKGxpbmVTdGFydHNbbGluZVN0YXJ0cy5sZW5ndGggLSAxXSArIGxlbmd0aCArIDEpO1xuICAgICAgICAgIC8vKzEgZm9yIHRoZSAvbiBpdHNlbGZcbiAgICAgICAgfVxuICAgICAgICBkZWJ1ZyhcbiAgICAgICAgICBcImxpbmU6ICVzXCIsXG4gICAgICAgICAgc291cmNlLnNsaWNlKGxpbmVTdGFydHNbbGluZV0sIGxpbmVTdGFydHNbbGluZV0gKyBsaW5lTGVuZ3Roc1tsaW5lXSlcbiAgICAgICAgKTtcbiAgICAgICAgd2hpbGUgKFxuICAgICAgICAgIGxpbmUgPCBsaW5lTGVuZ3Rocy5sZW5ndGggJiZcbiAgICAgICAgICAhYW55Tm9uU2tpcHBlZEluUmFuZ2UoYXN0LCBsaW5lU3RhcnRzW2xpbmVdLCBsaW5lTGVuZ3Roc1tsaW5lXSlcbiAgICAgICAgKSB7XG4gICAgICAgICAgZGVidWcoXCJpbmNyZW1lbnRpbmdcIik7XG4gICAgICAgICAgbGluZSsrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsaW5lID49IGxpbmVMZW5ndGhzLmxlbmd0aCkge1xuICAgICAgICAgIGFkanVzdGVkQnJlYWtwb2ludCA9IG51bGw7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYWRqdXN0ZWRCcmVha3BvaW50ID0geyAuLi5icmVha3BvaW50LCBsaW5lIH07XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlYnVnKFwibm9kZS1iYXNlZCBicmVha3BvaW50XCIpO1xuICAgICAgICBhZGp1c3RlZEJyZWFrcG9pbnQgPSBicmVha3BvaW50O1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFkanVzdGVkQnJlYWtwb2ludDtcbiAgICB9KVxuICB9LFxuXG4gIC8qKlxuICAgKiBjb250cm9sbGVyLmZpbmlzaGVkXG4gICAqIGRlcHJlY2F0ZWQgYWxpYXMgZm9yIGNvbnRyb2xsZXIuY3VycmVudC50cmFjZS5maW5pc2hlZFxuICAgKi9cbiAgZmluaXNoZWQ6IGNyZWF0ZUxlYWYoW1wiL2N1cnJlbnQvZmluaXNoZWRcIl0sIGZpbmlzaGVkID0+IGZpbmlzaGVkKSxcblxuICAvKipcbiAgICogY29udHJvbGxlci5pc1N0ZXBwaW5nXG4gICAqL1xuICBpc1N0ZXBwaW5nOiBjcmVhdGVMZWFmKFtcIi4vc3RhdGVcIl0sIHN0YXRlID0+IHN0YXRlLmlzU3RlcHBpbmcpXG59KTtcblxuZXhwb3J0IGRlZmF1bHQgY29udHJvbGxlcjtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBsaWIvY29udHJvbGxlci9zZWxlY3RvcnMvaW5kZXguanMiLCJpbXBvcnQgZGVidWdNb2R1bGUgZnJvbSBcImRlYnVnXCI7XG5jb25zdCBkZWJ1ZyA9IGRlYnVnTW9kdWxlKFwiZGVidWdnZXI6YXN0Om1hcFwiKTtcblxuaW1wb3J0IEludGVydmFsVHJlZSBmcm9tIFwibm9kZS1pbnRlcnZhbC10cmVlXCI7XG5pbXBvcnQganNvbnBvaW50ZXIgZnJvbSBcImpzb24tcG9pbnRlclwiO1xuaW1wb3J0IHsgaXNTa2lwcGVkTm9kZVR5cGUgfSBmcm9tIFwibGliL2hlbHBlcnNcIjtcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0UmFuZ2Uobm9kZSkge1xuICAvLyBzcmM6IFwiPHN0YXJ0Pjo8bGVuZ3RoPjo8Xz5cIlxuICAvLyByZXR1cm5zIFtzdGFydCwgZW5kXVxuICBsZXQgW3N0YXJ0LCBsZW5ndGhdID0gbm9kZS5zcmNcbiAgICAuc3BsaXQoXCI6XCIpXG4gICAgLnNsaWNlKDAsIDIpXG4gICAgLm1hcChpID0+IHBhcnNlSW50KGkpKTtcblxuICByZXR1cm4gW3N0YXJ0LCBzdGFydCArIGxlbmd0aF07XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJhbmdlTm9kZXMobm9kZSwgcG9pbnRlciA9IFwiXCIpIHtcbiAgaWYgKG5vZGUgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgIHJldHVybiBbXS5jb25jYXQoXG4gICAgICAuLi5ub2RlLm1hcCgoc3ViLCBpKSA9PiByYW5nZU5vZGVzKHN1YiwgYCR7cG9pbnRlcn0vJHtpfWApKVxuICAgICk7XG4gIH0gZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIE9iamVjdCkge1xuICAgIGxldCByZXN1bHRzID0gW107XG5cbiAgICBpZiAobm9kZS5zcmMgIT09IHVuZGVmaW5lZCAmJiBub2RlLmlkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vdGhlcmUgYXJlIHNvbWUgXCJwc2V1ZG8tbm9kZXNcIiB3aXRoIGEgc3JjIGJ1dCBubyBpZC5cbiAgICAgIC8vdGhlc2Ugd2lsbCBjYXVzZSBwcm9ibGVtcywgc28gd2Ugd2FudCB0byBleGNsdWRlIHRoZW0uXG4gICAgICAvLyh0byBteSBrbm93bGVkZ2UgdGhpcyBvbmx5IGhhcHBlbnMgd2l0aCB0aGUgZXh0ZXJuYWxSZWZlcmVuY2VzXG4gICAgICAvL3RvIGFuIElubGluZUFzc2VtYmx5IG5vZGUsIHNvIGV4Y2x1ZGluZyB0aGVtIGp1c3QgbWVhbnMgd2UgZmluZFxuICAgICAgLy90aGUgSW5saW5lQXNzZW1ibHkgbm9kZSBpbnN0ZWFkLCB3aGljaCBpcyBmaW5lKVxuICAgICAgcmVzdWx0cy5wdXNoKHsgcG9pbnRlciwgcmFuZ2U6IGdldFJhbmdlKG5vZGUpIH0pO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHRzLmNvbmNhdChcbiAgICAgIC4uLk9iamVjdC5rZXlzKG5vZGUpLm1hcChrZXkgPT5cbiAgICAgICAgcmFuZ2VOb2Rlcyhub2RlW2tleV0sIGAke3BvaW50ZXJ9LyR7a2V5fWApXG4gICAgICApXG4gICAgKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gW107XG4gIH1cbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gZmluZE92ZXJsYXBwaW5nUmFuZ2Uobm9kZSwgc291cmNlU3RhcnQsIHNvdXJjZUxlbmd0aCkge1xuICBsZXQgcmFuZ2VzID0gcmFuZ2VOb2Rlcyhub2RlKTtcbiAgbGV0IHRyZWUgPSBuZXcgSW50ZXJ2YWxUcmVlKCk7XG5cbiAgZm9yIChsZXQgeyByYW5nZSwgcG9pbnRlciB9IG9mIHJhbmdlcykge1xuICAgIGxldCBbc3RhcnQsIGVuZF0gPSByYW5nZTtcbiAgICB0cmVlLmluc2VydChzdGFydCwgZW5kLCB7IHJhbmdlLCBwb2ludGVyIH0pO1xuICB9XG5cbiAgbGV0IHNvdXJjZUVuZCA9IHNvdXJjZVN0YXJ0ICsgc291cmNlTGVuZ3RoO1xuXG4gIHJldHVybiB0cmVlLnNlYXJjaChzb3VyY2VTdGFydCwgc291cmNlRW5kKTtcbiAgLy9yZXR1cm5zIGV2ZXJ5dGhpbmcgb3ZlcmxhcHBpbmcgdGhlIGdpdmVuIHJhbmdlXG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZpbmRSYW5nZShub2RlLCBzb3VyY2VTdGFydCwgc291cmNlTGVuZ3RoKSB7XG4gIC8vIGZpbmQgbm9kZXMgdGhhdCBmdWxseSBjb250YWluIHJlcXVlc3RlZCByYW5nZSxcbiAgLy8gcmV0dXJuIGxvbmdlc3QgcG9pbnRlclxuICBsZXQgc291cmNlRW5kID0gc291cmNlU3RhcnQgKyBzb3VyY2VMZW5ndGg7XG4gIHJldHVybiBmaW5kT3ZlcmxhcHBpbmdSYW5nZShub2RlLCBzb3VyY2VTdGFydCwgc291cmNlTGVuZ3RoKVxuICAgIC5maWx0ZXIoKHsgcmFuZ2UgfSkgPT4gc291cmNlU3RhcnQgPj0gcmFuZ2VbMF0gJiYgc291cmNlRW5kIDw9IHJhbmdlWzFdKVxuICAgIC5tYXAoKHsgcG9pbnRlciB9KSA9PiBwb2ludGVyKVxuICAgIC5yZWR1Y2UoKGEsIGIpID0+IChhLmxlbmd0aCA+IGIubGVuZ3RoID8gYSA6IGIpLCBcIlwiKTtcbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gYW55Tm9uU2tpcHBlZEluUmFuZ2Uobm9kZSwgc291cmNlU3RhcnQsIHNvdXJjZUxlbmd0aCkge1xuICBsZXQgc291cmNlRW5kID0gc291cmNlU3RhcnQgKyBzb3VyY2VMZW5ndGg7XG4gIHJldHVybiBmaW5kT3ZlcmxhcHBpbmdSYW5nZShub2RlLCBzb3VyY2VTdGFydCwgc291cmNlTGVuZ3RoKS5zb21lKFxuICAgICh7IHJhbmdlLCBwb2ludGVyIH0pID0+XG4gICAgICBzb3VyY2VTdGFydCA8PSByYW5nZVswXSAmJiAvL3dlIHdhbnQgdG8gZ28gYnkgc3RhcnRpbmcgbGluZVxuICAgICAgcmFuZ2VbMF0gPCBzb3VyY2VFbmQgJiZcbiAgICAgICFpc1NraXBwZWROb2RlVHlwZShqc29ucG9pbnRlci5nZXQobm9kZSwgcG9pbnRlcikpXG4gICAgLy9OT1RFOiB0aGlzIGRvZXNuJ3QgYWN0dWFsbHkgY2F0Y2ggZXZlcnl0aGluZyBza2lwcGVkISAgQnV0IGRvaW5nIGJldHRlclxuICAgIC8vaXMgaGFyZFxuICApO1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIGxpYi9hc3QvbWFwLmpzIiwiaW1wb3J0IGRlYnVnTW9kdWxlIGZyb20gXCJkZWJ1Z1wiO1xuY29uc3QgZGVidWcgPSBkZWJ1Z01vZHVsZShcImRlYnVnZ2VyOnNlc3Npb246c2VsZWN0b3JzXCIpO1xuXG5pbXBvcnQgeyBjcmVhdGVTZWxlY3RvclRyZWUsIGNyZWF0ZUxlYWYgfSBmcm9tIFwicmVzZWxlY3QtdHJlZVwiO1xuXG5pbXBvcnQgZXZtIGZyb20gXCJsaWIvZXZtL3NlbGVjdG9yc1wiO1xuaW1wb3J0IHRyYWNlIGZyb20gXCJsaWIvdHJhY2Uvc2VsZWN0b3JzXCI7XG5pbXBvcnQgc29saWRpdHkgZnJvbSBcImxpYi9zb2xpZGl0eS9zZWxlY3RvcnNcIjtcblxuY29uc3Qgc2Vzc2lvbiA9IGNyZWF0ZVNlbGVjdG9yVHJlZSh7XG4gIC8qXG4gICAqIHNlc3Npb24uc3RhdGVcbiAgICovXG4gIHN0YXRlOiBzdGF0ZSA9PiBzdGF0ZS5zZXNzaW9uLFxuXG4gIC8qKlxuICAgKiBzZXNzaW9uLmluZm9cbiAgICovXG4gIGluZm86IHtcbiAgICAvKipcbiAgICAgKiBzZXNzaW9uLmluZm8uYWZmZWN0ZWRJbnN0YW5jZXNcbiAgICAgKi9cbiAgICBhZmZlY3RlZEluc3RhbmNlczogY3JlYXRlTGVhZihcbiAgICAgIFtldm0uY3VycmVudC5jb2RleC5pbnN0YW5jZXMsIGV2bS5pbmZvLmNvbnRleHRzLCBzb2xpZGl0eS5pbmZvLnNvdXJjZXNdLFxuXG4gICAgICAoaW5zdGFuY2VzLCBjb250ZXh0cywgc291cmNlcykgPT5cbiAgICAgICAgT2JqZWN0LmFzc2lnbihcbiAgICAgICAgICB7fSxcbiAgICAgICAgICAuLi5PYmplY3QuZW50cmllcyhpbnN0YW5jZXMpLm1hcChcbiAgICAgICAgICAgIChbYWRkcmVzcywgeyBjb250ZXh0OiBjb250ZXh0SWQsIGJpbmFyeSB9XSkgPT4ge1xuICAgICAgICAgICAgICBkZWJ1ZyhcImluc3RhbmNlcyAlT1wiLCBpbnN0YW5jZXMpO1xuICAgICAgICAgICAgICBkZWJ1ZyhcImNvbnRleHRzICVPXCIsIGNvbnRleHRzKTtcbiAgICAgICAgICAgICAgbGV0IGNvbnRleHQgPSBjb250ZXh0c1tjb250ZXh0SWRdO1xuICAgICAgICAgICAgICBpZiAoIWNvbnRleHQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBbYWRkcmVzc106IHsgYmluYXJ5IH0gfTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBsZXQgeyBjb250cmFjdE5hbWUsIHByaW1hcnlTb3VyY2UgfSA9IGNvbnRleHQ7XG5cbiAgICAgICAgICAgICAgbGV0IHNvdXJjZSA9XG4gICAgICAgICAgICAgICAgcHJpbWFyeVNvdXJjZSAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgICA/IHNvdXJjZXNbcHJpbWFyeVNvdXJjZV1cbiAgICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuXG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgW2FkZHJlc3NdOiB7XG4gICAgICAgICAgICAgICAgICBjb250cmFjdE5hbWUsXG4gICAgICAgICAgICAgICAgICBzb3VyY2UsXG4gICAgICAgICAgICAgICAgICBiaW5hcnlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgKVxuICAgICAgICApXG4gICAgKVxuICB9LFxuXG4gIC8qKlxuICAgKiBzZXNzaW9uLnRyYW5zYWN0aW9uIChuYW1lc3BhY2UpXG4gICAqL1xuICB0cmFuc2FjdGlvbjoge1xuICAgIC8qKlxuICAgICAqIHNlc3Npb24udHJhbnNhY3Rpb24gKHNlbGVjdG9yKVxuICAgICAqIGNvbnRhaW5zIHRoZSB3ZWIzIHRyYW5zYWN0aW9uIG9iamVjdFxuICAgICAqL1xuICAgIF86IGNyZWF0ZUxlYWYoW1wiL3N0YXRlXCJdLCBzdGF0ZSA9PiBzdGF0ZS50cmFuc2FjdGlvbiksXG5cbiAgICAvKipcbiAgICAgKiBzZXNzaW9uLnRyYW5zYWN0aW9uLnJlY2VpcHRcbiAgICAgKiBjb250YWlucyB0aGUgd2ViMyByZWNlaXB0IG9iamVjdFxuICAgICAqL1xuICAgIHJlY2VpcHQ6IGNyZWF0ZUxlYWYoW1wiL3N0YXRlXCJdLCBzdGF0ZSA9PiBzdGF0ZS5yZWNlaXB0KSxcblxuICAgIC8qKlxuICAgICAqIHNlc3Npb24udHJhbnNhY3Rpb24uYmxvY2tcbiAgICAgKiBjb250YWlucyB0aGUgd2ViMyBibG9jayBvYmplY3RcbiAgICAgKi9cbiAgICBibG9jazogY3JlYXRlTGVhZihbXCIvc3RhdGVcIl0sIHN0YXRlID0+IHN0YXRlLmJsb2NrKVxuICB9LFxuXG4gIC8qXG4gICAqIHNlc3Npb24uc3RhdHVzIChuYW1lc3BhY2UpXG4gICAqL1xuICBzdGF0dXM6IHtcbiAgICAvKlxuICAgICAqIHNlc3Npb24uc3RhdHVzLnJlYWR5T3JFcnJvclxuICAgICAqL1xuICAgIHJlYWR5T3JFcnJvcjogY3JlYXRlTGVhZihbXCIvc3RhdGVcIl0sIHN0YXRlID0+IHN0YXRlLnJlYWR5KSxcblxuICAgIC8qXG4gICAgICogc2Vzc2lvbi5zdGF0dXMucmVhZHlcbiAgICAgKi9cbiAgICByZWFkeTogY3JlYXRlTGVhZihcbiAgICAgIFtcIi4vcmVhZHlPckVycm9yXCIsIFwiLi9pc0Vycm9yXCJdLFxuICAgICAgKHJlYWR5T3JFcnJvciwgZXJyb3IpID0+IHJlYWR5T3JFcnJvciAmJiAhZXJyb3JcbiAgICApLFxuXG4gICAgLypcbiAgICAgKiBzZXNzaW9uLnN0YXR1cy53YWl0aW5nXG4gICAgICovXG4gICAgd2FpdGluZzogY3JlYXRlTGVhZihbXCIvc3RhdGVcIl0sIHN0YXRlID0+ICFzdGF0ZS5yZWFkeSksXG5cbiAgICAvKlxuICAgICAqIHNlc3Npb24uc3RhdHVzLmVycm9yXG4gICAgICovXG4gICAgZXJyb3I6IGNyZWF0ZUxlYWYoW1wiL3N0YXRlXCJdLCBzdGF0ZSA9PiBzdGF0ZS5sYXN0TG9hZGluZ0Vycm9yKSxcblxuICAgIC8qXG4gICAgICogc2Vzc2lvbi5zdGF0dXMuaXNFcnJvclxuICAgICAqL1xuICAgIGlzRXJyb3I6IGNyZWF0ZUxlYWYoW1wiLi9lcnJvclwiXSwgZXJyb3IgPT4gZXJyb3IgIT09IG51bGwpLFxuXG4gICAgLypcbiAgICAgKiBzZXNzaW9uLnN0YXR1cy5zdWNjZXNzXG4gICAgICovXG4gICAgc3VjY2VzczogY3JlYXRlTGVhZihbXCIuL2Vycm9yXCJdLCBlcnJvciA9PiBlcnJvciA9PT0gbnVsbCksXG5cbiAgICAvKlxuICAgICAqIHNlc3Npb24uc3RhdHVzLmVycm9yZWRcbiAgICAgKi9cbiAgICBlcnJvcmVkOiBjcmVhdGVMZWFmKFxuICAgICAgW1wiLi9yZWFkeU9yRXJyb3JcIiwgXCIuL2lzRXJyb3JcIl0sXG4gICAgICAocmVhZHlPckVycm9yLCBlcnJvcikgPT4gcmVhZHlPckVycm9yICYmIGVycm9yXG4gICAgKSxcblxuICAgIC8qXG4gICAgICogc2Vzc2lvbi5zdGF0dXMubG9hZGVkXG4gICAgICovXG4gICAgbG9hZGVkOiBjcmVhdGVMZWFmKFt0cmFjZS5sb2FkZWRdLCBsb2FkZWQgPT4gbG9hZGVkKSxcblxuICAgIC8qXG4gICAgICogc2Vzc2lvbi5zdGF0dXMucHJvamVjdEluZm9Db21wdXRlZFxuICAgICAqL1xuICAgIHByb2plY3RJbmZvQ29tcHV0ZWQ6IGNyZWF0ZUxlYWYoXG4gICAgICBbXCIvc3RhdGVcIl0sXG4gICAgICBzdGF0ZSA9PiBzdGF0ZS5wcm9qZWN0SW5mb0NvbXB1dGVkXG4gICAgKVxuICB9XG59KTtcblxuZXhwb3J0IGRlZmF1bHQgc2Vzc2lvbjtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBsaWIvc2Vzc2lvbi9zZWxlY3RvcnMvaW5kZXguanMiLCJleHBvcnQgY29uc3QgU0NPUEUgPSBcIlNDT1BFXCI7XG5leHBvcnQgZnVuY3Rpb24gc2NvcGUoaWQsIHBvaW50ZXIsIHBhcmVudElkLCBzb3VyY2VJZCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFNDT1BFLFxuICAgIGlkLFxuICAgIHBvaW50ZXIsXG4gICAgcGFyZW50SWQsXG4gICAgc291cmNlSWRcbiAgfTtcbn1cblxuZXhwb3J0IGNvbnN0IERFQ0xBUkUgPSBcIkRFQ0xBUkVfVkFSSUFCTEVcIjtcbmV4cG9ydCBmdW5jdGlvbiBkZWNsYXJlKG5vZGUpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBERUNMQVJFLFxuICAgIG5vZGVcbiAgfTtcbn1cblxuZXhwb3J0IGNvbnN0IEFTU0lHTiA9IFwiQVNTSUdOXCI7XG5leHBvcnQgZnVuY3Rpb24gYXNzaWduKGFzc2lnbm1lbnRzKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogQVNTSUdOLFxuICAgIGFzc2lnbm1lbnRzXG4gIH07XG59XG5cbmV4cG9ydCBjb25zdCBNQVBfUEFUSF9BTkRfQVNTSUdOID0gXCJNQVBfUEFUSF9BTkRfQVNTSUdOXCI7XG5leHBvcnQgZnVuY3Rpb24gbWFwUGF0aEFuZEFzc2lnbihcbiAgYWRkcmVzcyxcbiAgc2xvdCxcbiAgYXNzaWdubWVudHMsXG4gIHR5cGVJZGVudGlmaWVyLFxuICBwYXJlbnRUeXBlXG4pIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBNQVBfUEFUSF9BTkRfQVNTSUdOLFxuICAgIGFkZHJlc3MsXG4gICAgc2xvdCxcbiAgICBhc3NpZ25tZW50cyxcbiAgICB0eXBlSWRlbnRpZmllcixcbiAgICBwYXJlbnRUeXBlXG4gIH07XG59XG5cbmV4cG9ydCBjb25zdCBSRVNFVCA9IFwiREFUQV9SRVNFVFwiO1xuZXhwb3J0IGZ1bmN0aW9uIHJlc2V0KCkge1xuICByZXR1cm4geyB0eXBlOiBSRVNFVCB9O1xufVxuXG5leHBvcnQgY29uc3QgREVGSU5FX1RZUEUgPSBcIkRFRklORV9UWVBFXCI7XG5leHBvcnQgZnVuY3Rpb24gZGVmaW5lVHlwZShub2RlKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogREVGSU5FX1RZUEUsXG4gICAgbm9kZVxuICB9O1xufVxuXG5leHBvcnQgY29uc3QgQUxMT0NBVEUgPSBcIkFMTE9DQVRFXCI7XG5leHBvcnQgZnVuY3Rpb24gYWxsb2NhdGUoc3RvcmFnZSwgbWVtb3J5LCBjYWxsZGF0YSkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IEFMTE9DQVRFLFxuICAgIHN0b3JhZ2UsXG4gICAgbWVtb3J5LFxuICAgIGNhbGxkYXRhXG4gIH07XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gbGliL2RhdGEvYWN0aW9ucy9pbmRleC5qcyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcImJhYmVsLXJ1bnRpbWUvY29yZS1qcy9zZXRcIik7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZXh0ZXJuYWwgXCJiYWJlbC1ydW50aW1lL2NvcmUtanMvc2V0XCJcbi8vIG1vZHVsZSBpZCA9IDI4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImV4cG9ydCBjb25zdCBBRERfQ09OVEVYVCA9IFwiRVZNX0FERF9DT05URVhUXCI7XG5leHBvcnQgZnVuY3Rpb24gYWRkQ29udGV4dCh7XG4gIGNvbnRyYWN0TmFtZSxcbiAgYmluYXJ5LFxuICBzb3VyY2VNYXAsXG4gIGNvbXBpbGVyLFxuICBhYmksXG4gIGNvbnRyYWN0SWQsXG4gIGNvbnRyYWN0S2luZCxcbiAgaXNDb25zdHJ1Y3RvclxufSkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IEFERF9DT05URVhULFxuICAgIGNvbnRyYWN0TmFtZSxcbiAgICBiaW5hcnksXG4gICAgc291cmNlTWFwLFxuICAgIGNvbXBpbGVyLFxuICAgIGFiaSxcbiAgICBjb250cmFjdElkLFxuICAgIGNvbnRyYWN0S2luZCxcbiAgICBpc0NvbnN0cnVjdG9yXG4gIH07XG59XG5cbmV4cG9ydCBjb25zdCBOT1JNQUxJWkVfQ09OVEVYVFMgPSBcIkVWTV9OT1JNQUxJWkVfQ09OVEVYVFNcIjtcbmV4cG9ydCBmdW5jdGlvbiBub3JtYWxpemVDb250ZXh0cygpIHtcbiAgcmV0dXJuIHsgdHlwZTogTk9STUFMSVpFX0NPTlRFWFRTIH07XG59XG5cbmV4cG9ydCBjb25zdCBBRERfSU5TVEFOQ0UgPSBcIkVWTV9BRERfSU5TVEFOQ0VcIjtcbmV4cG9ydCBmdW5jdGlvbiBhZGRJbnN0YW5jZShhZGRyZXNzLCBjb250ZXh0LCBiaW5hcnkpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBBRERfSU5TVEFOQ0UsXG4gICAgYWRkcmVzcyxcbiAgICBjb250ZXh0LFxuICAgIGJpbmFyeVxuICB9O1xufVxuXG5leHBvcnQgY29uc3QgU0FWRV9HTE9CQUxTID0gXCJTQVZFX0dMT0JBTFNcIjtcbmV4cG9ydCBmdW5jdGlvbiBzYXZlR2xvYmFscyhvcmlnaW4sIGdhc3ByaWNlLCBibG9jaykge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFNBVkVfR0xPQkFMUyxcbiAgICBvcmlnaW4sXG4gICAgZ2FzcHJpY2UsXG4gICAgYmxvY2tcbiAgfTtcbn1cblxuZXhwb3J0IGNvbnN0IFNBVkVfU1RBVFVTID0gXCJTQVZFX1NUQVRVU1wiO1xuZXhwb3J0IGZ1bmN0aW9uIHNhdmVTdGF0dXMoc3RhdHVzKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogU0FWRV9TVEFUVVMsXG4gICAgc3RhdHVzXG4gIH07XG59XG5cbmV4cG9ydCBjb25zdCBDQUxMID0gXCJDQUxMXCI7XG5leHBvcnQgZnVuY3Rpb24gY2FsbChhZGRyZXNzLCBkYXRhLCBzdG9yYWdlQWRkcmVzcywgc2VuZGVyLCB2YWx1ZSkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IENBTEwsXG4gICAgYWRkcmVzcyxcbiAgICBkYXRhLFxuICAgIHN0b3JhZ2VBZGRyZXNzLFxuICAgIHNlbmRlcixcbiAgICB2YWx1ZVxuICB9O1xufVxuXG5leHBvcnQgY29uc3QgQ1JFQVRFID0gXCJDUkVBVEVcIjtcbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGUoYmluYXJ5LCBzdG9yYWdlQWRkcmVzcywgc2VuZGVyLCB2YWx1ZSkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IENSRUFURSxcbiAgICBiaW5hcnksXG4gICAgc3RvcmFnZUFkZHJlc3MsXG4gICAgc2VuZGVyLFxuICAgIHZhbHVlXG4gIH07XG59XG5cbmV4cG9ydCBjb25zdCBSRVRVUk5fQ0FMTCA9IFwiUkVUVVJOX0NBTExcIjtcbmV4cG9ydCBmdW5jdGlvbiByZXR1cm5DYWxsKCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFJFVFVSTl9DQUxMXG4gIH07XG59XG5cbmV4cG9ydCBjb25zdCBSRVRVUk5fQ1JFQVRFID0gXCJSRVRVUk5fQ1JFQVRFXCI7XG5leHBvcnQgZnVuY3Rpb24gcmV0dXJuQ3JlYXRlKGFkZHJlc3MsIGNvZGUsIGNvbnRleHQpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBSRVRVUk5fQ1JFQVRFLFxuICAgIGFkZHJlc3MsXG4gICAgY29kZSxcbiAgICBjb250ZXh0XG4gIH07XG59XG5cbmV4cG9ydCBjb25zdCBGQUlMID0gXCJGQUlMXCI7XG5leHBvcnQgZnVuY3Rpb24gZmFpbCgpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBGQUlMXG4gIH07XG59XG5cbmV4cG9ydCBjb25zdCBTVE9SRSA9IFwiU1RPUkVcIjtcbmV4cG9ydCBmdW5jdGlvbiBzdG9yZShhZGRyZXNzLCBzbG90LCB2YWx1ZSkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFNUT1JFLFxuICAgIGFkZHJlc3MsXG4gICAgc2xvdCxcbiAgICB2YWx1ZVxuICB9O1xufVxuXG5leHBvcnQgY29uc3QgTE9BRCA9IFwiTE9BRFwiO1xuZXhwb3J0IGZ1bmN0aW9uIGxvYWQoYWRkcmVzcywgc2xvdCwgdmFsdWUpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBMT0FELFxuICAgIGFkZHJlc3MsXG4gICAgc2xvdCxcbiAgICB2YWx1ZVxuICB9O1xufVxuXG5leHBvcnQgY29uc3QgUkVTRVQgPSBcIkVWTV9SRVNFVFwiO1xuZXhwb3J0IGZ1bmN0aW9uIHJlc2V0KHN0b3JhZ2VBZGRyZXNzKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogUkVTRVQsXG4gICAgc3RvcmFnZUFkZHJlc3NcbiAgfTtcbn1cblxuZXhwb3J0IGNvbnN0IFVOTE9BRF9UUkFOU0FDVElPTiA9IFwiRVZNX1VOTE9BRF9UUkFOU0FDVElPTlwiO1xuZXhwb3J0IGZ1bmN0aW9uIHVubG9hZFRyYW5zYWN0aW9uKCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFVOTE9BRF9UUkFOU0FDVElPTlxuICB9O1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIGxpYi9ldm0vYWN0aW9ucy9pbmRleC5qcyIsImltcG9ydCBkZWJ1Z01vZHVsZSBmcm9tIFwiZGVidWdcIjtcbmNvbnN0IGRlYnVnID0gZGVidWdNb2R1bGUoXCJkZWJ1Z2dlcjp3ZWIzOnNhZ2FzXCIpO1xuXG5pbXBvcnQge1xuICBhbGwsXG4gIHRha2VFdmVyeSxcbiAgYXBwbHksXG4gIGZvcmssXG4gIGpvaW4sXG4gIHRha2UsXG4gIHB1dFxufSBmcm9tIFwicmVkdXgtc2FnYS9lZmZlY3RzXCI7XG5pbXBvcnQgeyBwcmVmaXhOYW1lIH0gZnJvbSBcImxpYi9oZWxwZXJzXCI7XG5cbmltcG9ydCAqIGFzIGFjdGlvbnMgZnJvbSBcIi4uL2FjdGlvbnNcIjtcbmltcG9ydCAqIGFzIHNlc3Npb24gZnJvbSBcImxpYi9zZXNzaW9uL2FjdGlvbnNcIjtcblxuaW1wb3J0IEJOIGZyb20gXCJibi5qc1wiO1xuaW1wb3J0IFdlYjMgZnJvbSBcIndlYjNcIjsgLy9qdXN0IGZvciB1dGlscyFcbmltcG9ydCAqIGFzIERlY29kZVV0aWxzIGZyb20gXCJ0cnVmZmxlLWRlY29kZS11dGlsc1wiO1xuXG5pbXBvcnQgV2ViM0FkYXB0ZXIgZnJvbSBcIi4uL2FkYXB0ZXJcIjtcblxuZnVuY3Rpb24qIGZldGNoVHJhbnNhY3Rpb25JbmZvKGFkYXB0ZXIsIHsgdHhIYXNoIH0pIHtcbiAgZGVidWcoXCJpbnNwZWN0aW5nIHRyYW5zYWN0aW9uXCIpO1xuICB2YXIgdHJhY2U7XG4gIHRyeSB7XG4gICAgdHJhY2UgPSB5aWVsZCBhcHBseShhZGFwdGVyLCBhZGFwdGVyLmdldFRyYWNlLCBbdHhIYXNoXSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBkZWJ1ZyhcInB1dHRpbmcgZXJyb3JcIik7XG4gICAgeWllbGQgcHV0KGFjdGlvbnMuZXJyb3IoZSkpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGRlYnVnKFwiZ290IHRyYWNlXCIpO1xuICB5aWVsZCBwdXQoYWN0aW9ucy5yZWNlaXZlVHJhY2UodHJhY2UpKTtcblxuICBsZXQgdHggPSB5aWVsZCBhcHBseShhZGFwdGVyLCBhZGFwdGVyLmdldFRyYW5zYWN0aW9uLCBbdHhIYXNoXSk7XG4gIGRlYnVnKFwidHggJU9cIiwgdHgpO1xuICBsZXQgcmVjZWlwdCA9IHlpZWxkIGFwcGx5KGFkYXB0ZXIsIGFkYXB0ZXIuZ2V0UmVjZWlwdCwgW3R4SGFzaF0pO1xuICBkZWJ1ZyhcInJlY2VpcHQgJU9cIiwgcmVjZWlwdCk7XG4gIGxldCBibG9jayA9IHlpZWxkIGFwcGx5KGFkYXB0ZXIsIGFkYXB0ZXIuZ2V0QmxvY2ssIFt0eC5ibG9ja051bWJlcl0pO1xuICBkZWJ1ZyhcImJsb2NrICVPXCIsIGJsb2NrKTtcblxuICB5aWVsZCBwdXQoc2Vzc2lvbi5zYXZlVHJhbnNhY3Rpb24odHgpKTtcbiAgeWllbGQgcHV0KHNlc3Npb24uc2F2ZVJlY2VpcHQocmVjZWlwdCkpO1xuICB5aWVsZCBwdXQoc2Vzc2lvbi5zYXZlQmxvY2soYmxvY2spKTtcblxuICAvL3RoZXNlIG9uZXMgZ2V0IGdyb3VwZWQgdG9nZXRoZXIgZm9yIGNvbnZlbmllbmNlXG4gIGxldCBzb2xpZGl0eUJsb2NrID0ge1xuICAgIGNvaW5iYXNlOiBibG9jay5taW5lcixcbiAgICBkaWZmaWN1bHR5OiBuZXcgQk4oYmxvY2suZGlmZmljdWx0eSksXG4gICAgZ2FzbGltaXQ6IG5ldyBCTihibG9jay5nYXNMaW1pdCksXG4gICAgbnVtYmVyOiBuZXcgQk4oYmxvY2subnVtYmVyKSxcbiAgICB0aW1lc3RhbXA6IG5ldyBCTihibG9jay50aW1lc3RhbXApXG4gIH07XG5cbiAgaWYgKHR4LnRvICE9IG51bGwpIHtcbiAgICB5aWVsZCBwdXQoXG4gICAgICBhY3Rpb25zLnJlY2VpdmVDYWxsKHtcbiAgICAgICAgYWRkcmVzczogdHgudG8sXG4gICAgICAgIGRhdGE6IHR4LmlucHV0LFxuICAgICAgICBzdG9yYWdlQWRkcmVzczogdHgudG8sXG4gICAgICAgIHN0YXR1czogcmVjZWlwdC5zdGF0dXMsXG4gICAgICAgIHNlbmRlcjogdHguZnJvbSxcbiAgICAgICAgdmFsdWU6IG5ldyBCTih0eC52YWx1ZSksXG4gICAgICAgIGdhc3ByaWNlOiBuZXcgQk4odHguZ2FzUHJpY2UpLFxuICAgICAgICBibG9jazogc29saWRpdHlCbG9ja1xuICAgICAgfSlcbiAgICApO1xuICB9IGVsc2Uge1xuICAgIGxldCBzdG9yYWdlQWRkcmVzcyA9IFdlYjMudXRpbHMuaXNBZGRyZXNzKHJlY2VpcHQuY29udHJhY3RBZGRyZXNzKVxuICAgICAgPyByZWNlaXB0LmNvbnRyYWN0QWRkcmVzc1xuICAgICAgOiBEZWNvZGVVdGlscy5FVk0uWkVST19BRERSRVNTO1xuICAgIHlpZWxkIHB1dChcbiAgICAgIGFjdGlvbnMucmVjZWl2ZUNhbGwoe1xuICAgICAgICBiaW5hcnk6IHR4LmlucHV0LFxuICAgICAgICBzdG9yYWdlQWRkcmVzcyxcbiAgICAgICAgc3RhdHVzOiByZWNlaXB0LnN0YXR1cyxcbiAgICAgICAgc2VuZGVyOiB0eC5mcm9tLFxuICAgICAgICB2YWx1ZTogbmV3IEJOKHR4LnZhbHVlKSxcbiAgICAgICAgZ2FzcHJpY2U6IG5ldyBCTih0eC5nYXNQcmljZSksXG4gICAgICAgIGJsb2NrOiBzb2xpZGl0eUJsb2NrXG4gICAgICB9KVxuICAgICk7XG4gIH1cbn1cblxuZnVuY3Rpb24qIGZldGNoQmluYXJ5KGFkYXB0ZXIsIHsgYWRkcmVzcywgYmxvY2sgfSkge1xuICBkZWJ1ZyhcImZldGNoaW5nIGJpbmFyeSBmb3IgJXNcIiwgYWRkcmVzcyk7XG4gIGxldCBiaW5hcnkgPSB5aWVsZCBhcHBseShhZGFwdGVyLCBhZGFwdGVyLmdldERlcGxveWVkQ29kZSwgW2FkZHJlc3MsIGJsb2NrXSk7XG5cbiAgZGVidWcoXCJyZWNlaXZlZCBiaW5hcnkgZm9yICVzXCIsIGFkZHJlc3MpO1xuICB5aWVsZCBwdXQoYWN0aW9ucy5yZWNlaXZlQmluYXJ5KGFkZHJlc3MsIGJpbmFyeSkpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24qIGluc3BlY3RUcmFuc2FjdGlvbih0eEhhc2gpIHtcbiAgeWllbGQgcHV0KGFjdGlvbnMuaW5zcGVjdCh0eEhhc2gpKTtcblxuICBsZXQgYWN0aW9uID0geWllbGQgdGFrZShbYWN0aW9ucy5SRUNFSVZFX1RSQUNFLCBhY3Rpb25zLkVSUk9SX1dFQjNdKTtcbiAgZGVidWcoXCJhY3Rpb24gJW9cIiwgYWN0aW9uKTtcblxuICB2YXIgdHJhY2U7XG4gIGlmIChhY3Rpb24udHlwZSA9PSBhY3Rpb25zLlJFQ0VJVkVfVFJBQ0UpIHtcbiAgICB0cmFjZSA9IGFjdGlvbi50cmFjZTtcbiAgICBkZWJ1ZyhcInJlY2VpdmVkIHRyYWNlXCIpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB7IGVycm9yOiBhY3Rpb24uZXJyb3IgfTtcbiAgfVxuXG4gIGxldCB7XG4gICAgYWRkcmVzcyxcbiAgICBiaW5hcnksXG4gICAgZGF0YSxcbiAgICBzdG9yYWdlQWRkcmVzcyxcbiAgICBzdGF0dXMsXG4gICAgc2VuZGVyLFxuICAgIHZhbHVlLFxuICAgIGdhc3ByaWNlLFxuICAgIGJsb2NrXG4gIH0gPSB5aWVsZCB0YWtlKGFjdGlvbnMuUkVDRUlWRV9DQUxMKTtcbiAgZGVidWcoXCJyZWNlaXZlZCBjYWxsXCIpO1xuXG4gIHJldHVybiB7XG4gICAgdHJhY2UsXG4gICAgYWRkcmVzcyxcbiAgICBiaW5hcnksXG4gICAgZGF0YSxcbiAgICBzdG9yYWdlQWRkcmVzcyxcbiAgICBzdGF0dXMsXG4gICAgc2VuZGVyLFxuICAgIHZhbHVlLFxuICAgIGdhc3ByaWNlLFxuICAgIGJsb2NrXG4gIH07XG59XG5cbi8vTk9URTogdGhlIGJsb2NrIGFyZ3VtZW50IGlzIG9wdGlvbmFsXG5leHBvcnQgZnVuY3Rpb24qIG9idGFpbkJpbmFyaWVzKGFkZHJlc3NlcywgYmxvY2spIHtcbiAgbGV0IHRhc2tzID0geWllbGQgYWxsKGFkZHJlc3Nlcy5tYXAoYWRkcmVzcyA9PiBmb3JrKHJlY2VpdmVCaW5hcnksIGFkZHJlc3MpKSk7XG5cbiAgZGVidWcoXCJyZXF1ZXN0aW5nIGJpbmFyaWVzXCIpO1xuICB5aWVsZCBhbGwoYWRkcmVzc2VzLm1hcChhZGRyZXNzID0+IHB1dChhY3Rpb25zLmZldGNoQmluYXJ5KGFkZHJlc3MsIGJsb2NrKSkpKTtcblxuICBsZXQgYmluYXJpZXMgPSBbXTtcbiAgYmluYXJpZXMgPSB5aWVsZCBqb2luKHRhc2tzKTtcblxuICBkZWJ1ZyhcImJpbmFyaWVzICVvXCIsIGJpbmFyaWVzKTtcblxuICByZXR1cm4gYmluYXJpZXM7XG59XG5cbmZ1bmN0aW9uKiByZWNlaXZlQmluYXJ5KGFkZHJlc3MpIHtcbiAgbGV0IHsgYmluYXJ5IH0gPSB5aWVsZCB0YWtlKFxuICAgIGFjdGlvbiA9PiBhY3Rpb24udHlwZSA9PSBhY3Rpb25zLlJFQ0VJVkVfQklOQVJZICYmIGFjdGlvbi5hZGRyZXNzID09IGFkZHJlc3NcbiAgKTtcbiAgZGVidWcoXCJnb3QgYmluYXJ5IGZvciAlc1wiLCBhZGRyZXNzKTtcblxuICByZXR1cm4gYmluYXJ5O1xufVxuXG5leHBvcnQgZnVuY3Rpb24qIGluaXQocHJvdmlkZXIpIHtcbiAgeWllbGQgcHV0KGFjdGlvbnMuaW5pdChwcm92aWRlcikpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24qIHNhZ2EoKSB7XG4gIC8vIHdhaXQgZm9yIHdlYjMgaW5pdCBzaWduYWxcbiAgbGV0IHsgcHJvdmlkZXIgfSA9IHlpZWxkIHRha2UoYWN0aW9ucy5JTklUX1dFQjMpO1xuICBsZXQgYWRhcHRlciA9IG5ldyBXZWIzQWRhcHRlcihwcm92aWRlcik7XG5cbiAgeWllbGQgdGFrZUV2ZXJ5KGFjdGlvbnMuSU5TUEVDVCwgZmV0Y2hUcmFuc2FjdGlvbkluZm8sIGFkYXB0ZXIpO1xuICB5aWVsZCB0YWtlRXZlcnkoYWN0aW9ucy5GRVRDSF9CSU5BUlksIGZldGNoQmluYXJ5LCBhZGFwdGVyKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgcHJlZml4TmFtZShcIndlYjNcIiwgc2FnYSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gbGliL3dlYjMvc2FnYXMvaW5kZXguanMiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJ3ZWIzXCIpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGV4dGVybmFsIFwid2ViM1wiXG4vLyBtb2R1bGUgaWQgPSAzMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJ0cnVmZmxlLWRlY29kZXJcIik7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZXh0ZXJuYWwgXCJ0cnVmZmxlLWRlY29kZXJcIlxuLy8gbW9kdWxlIGlkID0gMzJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IGRlYnVnTW9kdWxlIGZyb20gXCJkZWJ1Z1wiO1xuY29uc3QgZGVidWcgPSBkZWJ1Z01vZHVsZShcImRlYnVnZ2VyOmNvbnRyb2xsZXI6c2FnYXNcIik7XG5cbmltcG9ydCB7IHB1dCwgY2FsbCwgcmFjZSwgdGFrZSwgc2VsZWN0IH0gZnJvbSBcInJlZHV4LXNhZ2EvZWZmZWN0c1wiO1xuXG5pbXBvcnQgeyBwcmVmaXhOYW1lLCBpc0RlbGliZXJhdGVseVNraXBwZWROb2RlVHlwZSB9IGZyb20gXCJsaWIvaGVscGVyc1wiO1xuXG5pbXBvcnQgKiBhcyB0cmFjZSBmcm9tIFwibGliL3RyYWNlL3NhZ2FzXCI7XG5pbXBvcnQgKiBhcyBkYXRhIGZyb20gXCJsaWIvZGF0YS9zYWdhc1wiO1xuaW1wb3J0ICogYXMgZXZtIGZyb20gXCJsaWIvZXZtL3NhZ2FzXCI7XG5pbXBvcnQgKiBhcyBzb2xpZGl0eSBmcm9tIFwibGliL3NvbGlkaXR5L3NhZ2FzXCI7XG5cbmltcG9ydCAqIGFzIGFjdGlvbnMgZnJvbSBcIi4uL2FjdGlvbnNcIjtcblxuaW1wb3J0IGNvbnRyb2xsZXIgZnJvbSBcIi4uL3NlbGVjdG9yc1wiO1xuXG5jb25zdCBTVEVQX1NBR0FTID0ge1xuICBbYWN0aW9ucy5BRFZBTkNFXTogYWR2YW5jZSxcbiAgW2FjdGlvbnMuU1RFUF9ORVhUXTogc3RlcE5leHQsXG4gIFthY3Rpb25zLlNURVBfT1ZFUl06IHN0ZXBPdmVyLFxuICBbYWN0aW9ucy5TVEVQX0lOVE9dOiBzdGVwSW50byxcbiAgW2FjdGlvbnMuU1RFUF9PVVRdOiBzdGVwT3V0LFxuICBbYWN0aW9ucy5DT05USU5VRV06IGNvbnRpbnVlVW50aWxCcmVha3BvaW50XG59O1xuXG5leHBvcnQgZnVuY3Rpb24qIHNhZ2EoKSB7XG4gIHdoaWxlICh0cnVlKSB7XG4gICAgZGVidWcoXCJ3YWl0aW5nIGZvciBjb250cm9sIGFjdGlvblwiKTtcbiAgICBsZXQgYWN0aW9uID0geWllbGQgdGFrZShPYmplY3Qua2V5cyhTVEVQX1NBR0FTKSk7XG4gICAgaWYgKCEoeWllbGQgc2VsZWN0KGNvbnRyb2xsZXIuY3VycmVudC50cmFjZS5sb2FkZWQpKSkge1xuICAgICAgY29udGludWU7IC8vd2hpbGUgbm8gdHJhY2UgaXMgbG9hZGVkLCBzdGVwIGFjdGlvbnMgYXJlIGlnbm9yZWRcbiAgICB9XG4gICAgZGVidWcoXCJnb3QgY29udHJvbCBhY3Rpb25cIik7XG4gICAgbGV0IHNhZ2EgPSBTVEVQX1NBR0FTW2FjdGlvbi50eXBlXTtcblxuICAgIHlpZWxkIHB1dChhY3Rpb25zLnN0YXJ0U3RlcHBpbmcoKSk7XG4gICAgeWllbGQgcmFjZSh7XG4gICAgICBleGVjOiBjYWxsKHNhZ2EsIGFjdGlvbiksIC8vbm90IGFsbCB3aWxsIHVzZSB0aGlzXG4gICAgICBpbnRlcnJ1cHQ6IHRha2UoYWN0aW9ucy5JTlRFUlJVUFQpXG4gICAgfSk7XG4gICAgeWllbGQgcHV0KGFjdGlvbnMuZG9uZVN0ZXBwaW5nKCkpO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IHByZWZpeE5hbWUoXCJjb250cm9sbGVyXCIsIHNhZ2EpO1xuXG4vKlxuICogQWR2YW5jZSB0aGUgc3RhdGUgYnkgdGhlIGdpdmVuIG51bWJlciBvZiBpbnN0cnVjdGlvbnMgKGJ1dCBub3QgcGFzdCB0aGUgZW5kKVxuICogKGlmIG5vIGNvdW50IGdpdmVuLCBhZHZhbmNlIDEpXG4gKi9cbmZ1bmN0aW9uKiBhZHZhbmNlKGFjdGlvbikge1xuICBsZXQgY291bnQgPVxuICAgIGFjdGlvbiAhPT0gdW5kZWZpbmVkICYmIGFjdGlvbi5jb3VudCAhPT0gdW5kZWZpbmVkID8gYWN0aW9uLmNvdW50IDogMTtcbiAgLy9kZWZhdWx0IGlzLCBhcyBtZW50aW9uZWQsIHRvIGFkdmFuY2UgMVxuICBmb3IgKFxuICAgIGxldCBpID0gMDtcbiAgICBpIDwgY291bnQgJiYgISh5aWVsZCBzZWxlY3QoY29udHJvbGxlci5jdXJyZW50LnRyYWNlLmZpbmlzaGVkKSk7XG4gICAgaSsrXG4gICkge1xuICAgIHlpZWxkKiB0cmFjZS5hZHZhbmNlKCk7XG4gIH1cbn1cblxuLyoqXG4gKiBzdGVwTmV4dCAtIHN0ZXAgdG8gdGhlIG5leHQgbG9naWNhbCBjb2RlIHNlZ21lbnRcbiAqXG4gKiBOb3RlOiBJdCBtaWdodCB0YWtlIG11bHRpcGxlIGluc3RydWN0aW9ucyB0byBleHByZXNzIHRoZSBzYW1lIHNlY3Rpb24gb2YgY29kZS5cbiAqIFwiU3RlcHBpbmdcIiwgdGhlbiwgaXMgc3RlcHBpbmcgdG8gdGhlIG5leHQgbG9naWNhbCBpdGVtLCBub3Qgc3RlcHBpbmcgdG8gdGhlIG5leHRcbiAqIGluc3RydWN0aW9uLiBTZWUgYWR2YW5jZSgpIGlmIHlvdSdkIGxpa2UgdG8gYWR2YW5jZSBieSBvbmUgaW5zdHJ1Y3Rpb24uXG4gKi9cbmZ1bmN0aW9uKiBzdGVwTmV4dCgpIHtcbiAgY29uc3Qgc3RhcnRpbmdSYW5nZSA9IHlpZWxkIHNlbGVjdChjb250cm9sbGVyLmN1cnJlbnQubG9jYXRpb24uc291cmNlUmFuZ2UpO1xuXG4gIHZhciB1cGNvbWluZywgZmluaXNoZWQ7XG5cbiAgZG8ge1xuICAgIC8vIGFkdmFuY2UgYXQgbGVhc3Qgb25jZSBzdGVwXG4gICAgeWllbGQqIGFkdmFuY2UoKTtcblxuICAgIC8vIGFuZCBjaGVjayB0aGUgbmV4dCBzb3VyY2UgcmFuZ2VcbiAgICB0cnkge1xuICAgICAgdXBjb21pbmcgPSB5aWVsZCBzZWxlY3QoY29udHJvbGxlci5jdXJyZW50LmxvY2F0aW9uKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB1cGNvbWluZyA9IG51bGw7XG4gICAgfVxuXG4gICAgZmluaXNoZWQgPSB5aWVsZCBzZWxlY3QoY29udHJvbGxlci5jdXJyZW50LnRyYWNlLmZpbmlzaGVkKTtcblxuICAgIC8vIGlmIHRoZSBuZXh0IHN0ZXAncyBzb3VyY2UgcmFuZ2UgaXMgc3RpbGwgdGhlIHNhbWUsIGtlZXAgZ29pbmdcbiAgfSB3aGlsZSAoXG4gICAgIWZpbmlzaGVkICYmXG4gICAgKCF1cGNvbWluZyB8fFxuICAgICAgIXVwY29taW5nLm5vZGUgfHxcbiAgICAgIGlzRGVsaWJlcmF0ZWx5U2tpcHBlZE5vZGVUeXBlKHVwY29taW5nLm5vZGUpIHx8XG4gICAgICAodXBjb21pbmcuc291cmNlUmFuZ2Uuc3RhcnQgPT0gc3RhcnRpbmdSYW5nZS5zdGFydCAmJlxuICAgICAgICB1cGNvbWluZy5zb3VyY2VSYW5nZS5sZW5ndGggPT0gc3RhcnRpbmdSYW5nZS5sZW5ndGgpKVxuICApO1xufVxuXG4vKipcbiAqIHN0ZXBJbnRvIC0gc3RlcCBpbnRvIHRoZSBjdXJyZW50IGZ1bmN0aW9uXG4gKlxuICogQ29uY2VwdHVhbGx5IHRoaXMgaXMgZWFzeSwgYnV0IGZyb20gYSBwcm9ncmFtbWluZyBzdGFuZHBvaW50IGl0J3MgaGFyZC5cbiAqIENvZGUgbGlrZSBgZ2V0QmFsYW5jZShtc2cuc2VuZGVyKWAgbWlnaHQgYmUgaGlnaGxpZ2h0ZWQsIGJ1dCB0aGVyZSBjb3VsZFxuICogYmUgYSBudW1iZXIgb2YgZGlmZmVyZW50IGludGVybWVkaWF0ZSBzdGVwcyAobGlrZSBldmFsdWF0aW5nIGBtc2cuc2VuZGVyYClcbiAqIGJlZm9yZSBgZ2V0QmFsYW5jZWAgaXMgc3RlcHBlZCBpbnRvLiBUaGlzIGZ1bmN0aW9uIHdpbGwgc3RlcCBpbnRvIHRoZSBmaXJzdFxuICogZnVuY3Rpb24gYXZhaWxhYmxlICh3aGVyZSBpbnN0cnVjdGlvbi5qdW1wID09IFwiaVwiKSwgaWdub3JpbmcgYW55IGludGVybWVkaWF0ZVxuICogc3RlcHMgdGhhdCBmYWxsIHdpdGhpbiB0aGUgc2FtZSBjb2RlIHJhbmdlLiBJZiB0aGVyZSdzIGEgc3RlcCBlbmNvdW50ZXJlZFxuICogdGhhdCBleGlzdHMgb3V0c2lkZSBvZiB0aGUgcmFuZ2UsIHRoZW4gc3RlcEludG8gd2lsbCBvbmx5IGV4ZWN1dGUgdW50aWwgdGhhdFxuICogc3RlcC5cbiAqL1xuZnVuY3Rpb24qIHN0ZXBJbnRvKCkge1xuICBpZiAoeWllbGQgc2VsZWN0KGNvbnRyb2xsZXIuY3VycmVudC53aWxsSnVtcCkpIHtcbiAgICB5aWVsZCogc3RlcE5leHQoKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoeWllbGQgc2VsZWN0KGNvbnRyb2xsZXIuY3VycmVudC5sb2NhdGlvbi5pc011bHRpbGluZSkpIHtcbiAgICB5aWVsZCogc3RlcE92ZXIoKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBjb25zdCBzdGFydGluZ0RlcHRoID0geWllbGQgc2VsZWN0KGNvbnRyb2xsZXIuY3VycmVudC5mdW5jdGlvbkRlcHRoKTtcbiAgY29uc3Qgc3RhcnRpbmdSYW5nZSA9IHlpZWxkIHNlbGVjdChjb250cm9sbGVyLmN1cnJlbnQubG9jYXRpb24uc291cmNlUmFuZ2UpO1xuICB2YXIgY3VycmVudERlcHRoO1xuICB2YXIgY3VycmVudFJhbmdlO1xuXG4gIGRvIHtcbiAgICB5aWVsZCogc3RlcE5leHQoKTtcblxuICAgIGN1cnJlbnREZXB0aCA9IHlpZWxkIHNlbGVjdChjb250cm9sbGVyLmN1cnJlbnQuZnVuY3Rpb25EZXB0aCk7XG4gICAgY3VycmVudFJhbmdlID0geWllbGQgc2VsZWN0KGNvbnRyb2xsZXIuY3VycmVudC5sb2NhdGlvbi5zb3VyY2VSYW5nZSk7XG4gIH0gd2hpbGUgKFxuICAgIC8vIHRoZSBmdW5jdGlvbiBzdGFjayBoYXMgbm90IGluY3JlYXNlZCxcbiAgICBjdXJyZW50RGVwdGggPD0gc3RhcnRpbmdEZXB0aCAmJlxuICAgIC8vIHRoZSBjdXJyZW50IHNvdXJjZSByYW5nZSBiZWdpbnMgb24gb3IgYWZ0ZXIgdGhlIHN0YXJ0aW5nIHJhbmdlXG4gICAgY3VycmVudFJhbmdlLnN0YXJ0ID49IHN0YXJ0aW5nUmFuZ2Uuc3RhcnQgJiZcbiAgICAvLyBhbmQgdGhlIGN1cnJlbnQgcmFuZ2UgZW5kcyBvbiBvciBiZWZvcmUgdGhlIHN0YXJ0aW5nIHJhbmdlIGVuZHNcbiAgICBjdXJyZW50UmFuZ2Uuc3RhcnQgKyBjdXJyZW50UmFuZ2UubGVuZ3RoIDw9XG4gICAgICBzdGFydGluZ1JhbmdlLnN0YXJ0ICsgc3RhcnRpbmdSYW5nZS5sZW5ndGhcbiAgKTtcbn1cblxuLyoqXG4gKiBTdGVwIG91dCBvZiB0aGUgY3VycmVudCBmdW5jdGlvblxuICpcbiAqIFRoaXMgd2lsbCBydW4gdW50aWwgdGhlIGRlYnVnZ2VyIGVuY291bnRlcnMgYSBkZWNyZWFzZSBpbiBmdW5jdGlvbiBkZXB0aC5cbiAqL1xuZnVuY3Rpb24qIHN0ZXBPdXQoKSB7XG4gIGlmICh5aWVsZCBzZWxlY3QoY29udHJvbGxlci5jdXJyZW50LmxvY2F0aW9uLmlzTXVsdGlsaW5lKSkge1xuICAgIHlpZWxkKiBzdGVwT3ZlcigpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnN0IHN0YXJ0aW5nRGVwdGggPSB5aWVsZCBzZWxlY3QoY29udHJvbGxlci5jdXJyZW50LmZ1bmN0aW9uRGVwdGgpO1xuICB2YXIgY3VycmVudERlcHRoO1xuXG4gIGRvIHtcbiAgICB5aWVsZCogc3RlcE5leHQoKTtcblxuICAgIGN1cnJlbnREZXB0aCA9IHlpZWxkIHNlbGVjdChjb250cm9sbGVyLmN1cnJlbnQuZnVuY3Rpb25EZXB0aCk7XG4gIH0gd2hpbGUgKGN1cnJlbnREZXB0aCA+PSBzdGFydGluZ0RlcHRoKTtcbn1cblxuLyoqXG4gKiBzdGVwT3ZlciAtIHN0ZXAgb3ZlciB0aGUgY3VycmVudCBsaW5lXG4gKlxuICogU3RlcCBvdmVyIHRoZSBjdXJyZW50IGxpbmUuIFRoaXMgd2lsbCBzdGVwIHRvIHRoZSBuZXh0IGluc3RydWN0aW9uIHRoYXRcbiAqIGV4aXN0cyBvbiBhIGRpZmZlcmVudCBsaW5lIG9mIGNvZGUgd2l0aGluIHRoZSBzYW1lIGZ1bmN0aW9uIGRlcHRoLlxuICovXG5mdW5jdGlvbiogc3RlcE92ZXIoKSB7XG4gIGNvbnN0IHN0YXJ0aW5nRGVwdGggPSB5aWVsZCBzZWxlY3QoY29udHJvbGxlci5jdXJyZW50LmZ1bmN0aW9uRGVwdGgpO1xuICBjb25zdCBzdGFydGluZ1JhbmdlID0geWllbGQgc2VsZWN0KGNvbnRyb2xsZXIuY3VycmVudC5sb2NhdGlvbi5zb3VyY2VSYW5nZSk7XG4gIHZhciBjdXJyZW50RGVwdGg7XG4gIHZhciBjdXJyZW50UmFuZ2U7XG5cbiAgZG8ge1xuICAgIHlpZWxkKiBzdGVwTmV4dCgpO1xuXG4gICAgY3VycmVudERlcHRoID0geWllbGQgc2VsZWN0KGNvbnRyb2xsZXIuY3VycmVudC5mdW5jdGlvbkRlcHRoKTtcbiAgICBjdXJyZW50UmFuZ2UgPSB5aWVsZCBzZWxlY3QoY29udHJvbGxlci5jdXJyZW50LmxvY2F0aW9uLnNvdXJjZVJhbmdlKTtcbiAgfSB3aGlsZSAoXG4gICAgLy8ga2VlcCBzdGVwcGluZyBwcm92aWRlZDpcbiAgICAvL1xuICAgIC8vIHdlIGhhdmVuJ3QganVtcGVkIG91dFxuICAgICEoY3VycmVudERlcHRoIDwgc3RhcnRpbmdEZXB0aCkgJiZcbiAgICAvLyBlaXRoZXI6IGZ1bmN0aW9uIGRlcHRoIGlzIGdyZWF0ZXIgdGhhbiBzdGFydGluZyAoaWdub3JlIGZ1bmN0aW9uIGNhbGxzKVxuICAgIC8vIG9yLCBpZiB3ZSdyZSBhdCB0aGUgc2FtZSBkZXB0aCwga2VlcCBzdGVwcGluZyB1bnRpbCB3ZSdyZSBvbiBhIG5ld1xuICAgIC8vIGxpbmUuXG4gICAgKGN1cnJlbnREZXB0aCA+IHN0YXJ0aW5nRGVwdGggfHxcbiAgICAgIGN1cnJlbnRSYW5nZS5saW5lcy5zdGFydC5saW5lID09IHN0YXJ0aW5nUmFuZ2UubGluZXMuc3RhcnQubGluZSlcbiAgKTtcbn1cblxuLyoqXG4gKiBjb250aW51ZVVudGlsQnJlYWtwb2ludCAtIHN0ZXAgdGhyb3VnaCBleGVjdXRpb24gdW50aWwgYSBicmVha3BvaW50XG4gKi9cbmZ1bmN0aW9uKiBjb250aW51ZVVudGlsQnJlYWtwb2ludChhY3Rpb24pIHtcbiAgdmFyIGN1cnJlbnRMb2NhdGlvbiwgY3VycmVudE5vZGUsIGN1cnJlbnRMaW5lLCBjdXJyZW50U291cmNlSWQ7XG4gIHZhciBmaW5pc2hlZDtcbiAgdmFyIHByZXZpb3VzTGluZSwgcHJldmlvdXNTb3VyY2VJZDtcblxuICAvL2lmIGJyZWFrcG9pbnRzIHdhcyBub3Qgc3BlY2lmaWVkLCB1c2UgdGhlIHN0b3JlZCBsaXN0IGZyb20gdGhlIHN0YXRlLlxuICAvL2lmIGl0IHdhcywgb3ZlcnJpZGUgdGhhdCB3aXRoIHRoZSBzcGVjaWZpZWQgbGlzdC5cbiAgLy9ub3RlIHRoYXQgZXhwbGljaXRseSBzcGVjaWZ5aW5nIGFuIGVtcHR5IGxpc3Qgd2lsbCBhZHZhbmNlIHRvIHRoZSBlbmQuXG4gIGxldCBicmVha3BvaW50cyA9XG4gICAgYWN0aW9uICE9PSB1bmRlZmluZWQgJiYgYWN0aW9uLmJyZWFrcG9pbnRzICE9PSB1bmRlZmluZWRcbiAgICAgID8gYWN0aW9uLmJyZWFrcG9pbnRzXG4gICAgICA6IHlpZWxkIHNlbGVjdChjb250cm9sbGVyLmJyZWFrcG9pbnRzKTtcblxuICBsZXQgYnJlYWtwb2ludEhpdCA9IGZhbHNlO1xuXG4gIGN1cnJlbnRMb2NhdGlvbiA9IHlpZWxkIHNlbGVjdChjb250cm9sbGVyLmN1cnJlbnQubG9jYXRpb24pO1xuICBjdXJyZW50Tm9kZSA9IGN1cnJlbnRMb2NhdGlvbi5ub2RlLmlkO1xuICBjdXJyZW50TGluZSA9IGN1cnJlbnRMb2NhdGlvbi5zb3VyY2VSYW5nZS5saW5lcy5zdGFydC5saW5lO1xuICBjdXJyZW50U291cmNlSWQgPSBjdXJyZW50TG9jYXRpb24uc291cmNlLmlkO1xuXG4gIGRvIHtcbiAgICB5aWVsZCogc3RlcE5leHQoKTtcblxuICAgIHByZXZpb3VzTGluZSA9IGN1cnJlbnRMaW5lO1xuICAgIHByZXZpb3VzU291cmNlSWQgPSBjdXJyZW50U291cmNlSWQ7XG5cbiAgICBjdXJyZW50TG9jYXRpb24gPSB5aWVsZCBzZWxlY3QoY29udHJvbGxlci5jdXJyZW50LmxvY2F0aW9uKTtcbiAgICBmaW5pc2hlZCA9IHlpZWxkIHNlbGVjdChjb250cm9sbGVyLmN1cnJlbnQudHJhY2UuZmluaXNoZWQpO1xuICAgIGRlYnVnKFwiZmluaXNoZWQgJW9cIiwgZmluaXNoZWQpO1xuXG4gICAgY3VycmVudE5vZGUgPSBjdXJyZW50TG9jYXRpb24ubm9kZS5pZDtcbiAgICBjdXJyZW50TGluZSA9IGN1cnJlbnRMb2NhdGlvbi5zb3VyY2VSYW5nZS5saW5lcy5zdGFydC5saW5lO1xuICAgIGN1cnJlbnRTb3VyY2VJZCA9IGN1cnJlbnRMb2NhdGlvbi5zb3VyY2UuaWQ7XG5cbiAgICBicmVha3BvaW50SGl0ID1cbiAgICAgIGJyZWFrcG9pbnRzLmZpbHRlcigoeyBzb3VyY2VJZCwgbGluZSwgbm9kZSB9KSA9PiB7XG4gICAgICAgIGlmIChub2RlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBkZWJ1ZyhcIm5vZGUgJWQgY3VycmVudE5vZGUgJWRcIiwgbm9kZSwgY3VycmVudE5vZGUpO1xuICAgICAgICAgIHJldHVybiBzb3VyY2VJZCA9PT0gY3VycmVudFNvdXJjZUlkICYmIG5vZGUgPT09IGN1cnJlbnROb2RlO1xuICAgICAgICB9XG4gICAgICAgIC8vb3RoZXJ3aXNlLCB3ZSBoYXZlIGEgbGluZS1zdHlsZSBicmVha3BvaW50OyB3ZSB3YW50IHRvIHN0b3AgYXQgdGhlXG4gICAgICAgIC8vKmZpcnN0KiBwb2ludCBvbiB0aGUgbGluZVxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIHNvdXJjZUlkID09PSBjdXJyZW50U291cmNlSWQgJiZcbiAgICAgICAgICBsaW5lID09PSBjdXJyZW50TGluZSAmJlxuICAgICAgICAgIChjdXJyZW50U291cmNlSWQgIT09IHByZXZpb3VzU291cmNlSWQgfHwgY3VycmVudExpbmUgIT09IHByZXZpb3VzTGluZSlcbiAgICAgICAgKTtcbiAgICAgIH0pLmxlbmd0aCA+IDA7XG4gIH0gd2hpbGUgKCFicmVha3BvaW50SGl0ICYmICFmaW5pc2hlZCk7XG59XG5cbi8qKlxuICogcmVzZXQgLS0gcmVzZXQgdGhlIHN0YXRlIG9mIHRoZSBkZWJ1Z2dlclxuICovXG5leHBvcnQgZnVuY3Rpb24qIHJlc2V0KCkge1xuICB5aWVsZCogZGF0YS5yZXNldCgpO1xuICB5aWVsZCogZXZtLnJlc2V0KCk7XG4gIHlpZWxkKiBzb2xpZGl0eS5yZXNldCgpO1xuICB5aWVsZCogdHJhY2UucmVzZXQoKTtcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBsaWIvY29udHJvbGxlci9zYWdhcy9pbmRleC5qcyIsImltcG9ydCBkZWJ1Z01vZHVsZSBmcm9tIFwiZGVidWdcIjtcbmNvbnN0IGRlYnVnID0gZGVidWdNb2R1bGUoXCJkZWJ1Z2dlcjpzb2xpZGl0eTpzYWdhc1wiKTtcblxuaW1wb3J0IHsgcHV0LCB0YWtlRXZlcnksIHNlbGVjdCB9IGZyb20gXCJyZWR1eC1zYWdhL2VmZmVjdHNcIjtcbmltcG9ydCB7IHByZWZpeE5hbWUgfSBmcm9tIFwibGliL2hlbHBlcnNcIjtcblxuaW1wb3J0ICogYXMgYWN0aW9ucyBmcm9tIFwiLi4vYWN0aW9uc1wiO1xuaW1wb3J0IHsgVElDSyB9IGZyb20gXCJsaWIvdHJhY2UvYWN0aW9uc1wiO1xuaW1wb3J0ICogYXMgdHJhY2UgZnJvbSBcImxpYi90cmFjZS9zYWdhc1wiO1xuXG5pbXBvcnQgc29saWRpdHkgZnJvbSBcIi4uL3NlbGVjdG9yc1wiO1xuXG5leHBvcnQgZnVuY3Rpb24qIGFkZFNvdXJjZShzb3VyY2UsIHNvdXJjZVBhdGgsIGFzdCwgY29tcGlsZXIpIHtcbiAgeWllbGQgcHV0KGFjdGlvbnMuYWRkU291cmNlKHNvdXJjZSwgc291cmNlUGF0aCwgYXN0LCBjb21waWxlcikpO1xufVxuXG5mdW5jdGlvbiogdGlja1NhZ2EoKSB7XG4gIGRlYnVnKFwiZ290IFRJQ0tcIik7XG5cbiAgeWllbGQqIGZ1bmN0aW9uRGVwdGhTYWdhKCk7XG4gIHlpZWxkKiB0cmFjZS5zaWduYWxUaWNrU2FnYUNvbXBsZXRpb24oKTtcbn1cblxuZnVuY3Rpb24qIGZ1bmN0aW9uRGVwdGhTYWdhKCkge1xuICBpZiAoeWllbGQgc2VsZWN0KHNvbGlkaXR5LmN1cnJlbnQud2lsbEZhaWwpKSB7XG4gICAgLy93ZSBkbyB0aGlzIGNhc2UgZmlyc3Qgc28gd2UgY2FuIGJlIHN1cmUgd2UncmUgbm90IGZhaWxpbmcgaW4gYW55IG9mIHRoZVxuICAgIC8vb3RoZXIgY2FzZXMgYmVsb3chXG4gICAgeWllbGQgcHV0KGFjdGlvbnMuZXh0ZXJuYWxSZXR1cm4oKSk7XG4gIH0gZWxzZSBpZiAoeWllbGQgc2VsZWN0KHNvbGlkaXR5LmN1cnJlbnQud2lsbEp1bXApKSB7XG4gICAgbGV0IGp1bXBEaXJlY3Rpb24gPSB5aWVsZCBzZWxlY3Qoc29saWRpdHkuY3VycmVudC5qdW1wRGlyZWN0aW9uKTtcbiAgICB5aWVsZCBwdXQoYWN0aW9ucy5qdW1wKGp1bXBEaXJlY3Rpb24pKTtcbiAgfSBlbHNlIGlmICh5aWVsZCBzZWxlY3Qoc29saWRpdHkuY3VycmVudC53aWxsQ2FsbCkpIHtcbiAgICBkZWJ1ZyhcImFib3V0IHRvIGNhbGxcIik7XG4gICAgaWYgKHlpZWxkIHNlbGVjdChzb2xpZGl0eS5jdXJyZW50LmNhbGxzUHJlY29tcGlsZU9yRXh0ZXJuYWwpKSB7XG4gICAgICAvL2NhbGwgdG8gcHJlY29tcGlsZSBvciBleHRlcm5hbGx5LW93bmVkIGFjY291bnQ7IGRvIG5vdGhpbmdcbiAgICB9IGVsc2Uge1xuICAgICAgeWllbGQgcHV0KGFjdGlvbnMuZXh0ZXJuYWxDYWxsKCkpO1xuICAgIH1cbiAgfSBlbHNlIGlmICh5aWVsZCBzZWxlY3Qoc29saWRpdHkuY3VycmVudC53aWxsQ3JlYXRlKSkge1xuICAgIHlpZWxkIHB1dChhY3Rpb25zLmV4dGVybmFsQ2FsbCgpKTtcbiAgfSBlbHNlIGlmICh5aWVsZCBzZWxlY3Qoc29saWRpdHkuY3VycmVudC53aWxsUmV0dXJuKSkge1xuICAgIHlpZWxkIHB1dChhY3Rpb25zLmV4dGVybmFsUmV0dXJuKCkpO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiogcmVzZXQoKSB7XG4gIHlpZWxkIHB1dChhY3Rpb25zLnJlc2V0KCkpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24qIHNhZ2EoKSB7XG4gIHlpZWxkIHRha2VFdmVyeShUSUNLLCB0aWNrU2FnYSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHByZWZpeE5hbWUoXCJzb2xpZGl0eVwiLCBzYWdhKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBsaWIvc29saWRpdHkvc2FnYXMvaW5kZXguanMiLCJleHBvcnQgY29uc3QgQUREX1NPVVJDRSA9IFwiU09MSURJVFlfQUREX1NPVVJDRVwiO1xuZXhwb3J0IGZ1bmN0aW9uIGFkZFNvdXJjZShzb3VyY2UsIHNvdXJjZVBhdGgsIGFzdCwgY29tcGlsZXIpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBBRERfU09VUkNFLFxuICAgIHNvdXJjZSxcbiAgICBzb3VyY2VQYXRoLFxuICAgIGFzdCxcbiAgICBjb21waWxlclxuICB9O1xufVxuXG5leHBvcnQgY29uc3QgSlVNUCA9IFwiSlVNUFwiO1xuZXhwb3J0IGZ1bmN0aW9uIGp1bXAoanVtcERpcmVjdGlvbikge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IEpVTVAsXG4gICAganVtcERpcmVjdGlvblxuICB9O1xufVxuXG5leHBvcnQgY29uc3QgRVhURVJOQUxfQ0FMTCA9IFwiRVhURVJOQUxfQ0FMTFwiO1xuZXhwb3J0IGZ1bmN0aW9uIGV4dGVybmFsQ2FsbCgpIHtcbiAgcmV0dXJuIHsgdHlwZTogRVhURVJOQUxfQ0FMTCB9O1xufVxuXG5leHBvcnQgY29uc3QgRVhURVJOQUxfUkVUVVJOID0gXCJFWFRFUk5BTF9SRVRVUk5cIjtcbmV4cG9ydCBmdW5jdGlvbiBleHRlcm5hbFJldHVybigpIHtcbiAgcmV0dXJuIHsgdHlwZTogRVhURVJOQUxfUkVUVVJOIH07XG59XG5cbmV4cG9ydCBjb25zdCBSRVNFVCA9IFwiU09MSURJVFlfUkVTRVRcIjtcbmV4cG9ydCBmdW5jdGlvbiByZXNldCgpIHtcbiAgcmV0dXJuIHsgdHlwZTogUkVTRVQgfTtcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBsaWIvc29saWRpdHkvYWN0aW9ucy9pbmRleC5qcyIsImltcG9ydCBkZWJ1Z01vZHVsZSBmcm9tIFwiZGVidWdcIjtcbmNvbnN0IGRlYnVnID0gZGVidWdNb2R1bGUoXCJkZWJ1Z2dlcjphc3Q6c2VsZWN0b3JzXCIpO1xuXG5pbXBvcnQgeyBjcmVhdGVTZWxlY3RvclRyZWUsIGNyZWF0ZUxlYWYgfSBmcm9tIFwicmVzZWxlY3QtdHJlZVwiO1xuXG5pbXBvcnQgc29saWRpdHkgZnJvbSBcImxpYi9zb2xpZGl0eS9zZWxlY3RvcnNcIjtcblxuLyoqXG4gKiBhc3RcbiAqL1xuY29uc3QgYXN0ID0gY3JlYXRlU2VsZWN0b3JUcmVlKHtcbiAgLyoqXG4gICAqIGFzdC52aWV3c1xuICAgKi9cbiAgdmlld3M6IHtcbiAgICAvKipcbiAgICAgKiBhc3Qudmlld3Muc291cmNlc1xuICAgICAqL1xuICAgIHNvdXJjZXM6IGNyZWF0ZUxlYWYoW3NvbGlkaXR5LmluZm8uc291cmNlc10sIHNvdXJjZXMgPT4gc291cmNlcylcbiAgfVxufSk7XG5cbmV4cG9ydCBkZWZhdWx0IGFzdDtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBsaWIvYXN0L3NlbGVjdG9ycy9pbmRleC5qcyIsInZhciBEZWJ1Z2dlciA9IHJlcXVpcmUoXCIuL2xpYi9kZWJ1Z2dlclwiKS5kZWZhdWx0O1xuXG5tb2R1bGUuZXhwb3J0cyA9IERlYnVnZ2VyO1xuXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2RlYnVnZ2VyLmpzXG4vLyBtb2R1bGUgaWQgPSAzN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgZGVidWdNb2R1bGUgZnJvbSBcImRlYnVnXCI7XG5jb25zdCBkZWJ1ZyA9IGRlYnVnTW9kdWxlKFwiZGVidWdnZXJcIik7XG5pbXBvcnQgZXhwZWN0IGZyb20gXCJ0cnVmZmxlLWV4cGVjdFwiO1xuXG5pbXBvcnQgU2Vzc2lvbiBmcm9tIFwiLi9zZXNzaW9uXCI7XG5cbmltcG9ydCB7IGNyZWF0ZU5lc3RlZFNlbGVjdG9yIH0gZnJvbSBcInJlc2VsZWN0LXRyZWVcIjtcblxuaW1wb3J0IGRhdGFTZWxlY3RvciBmcm9tIFwiLi9kYXRhL3NlbGVjdG9yc1wiO1xuaW1wb3J0IGFzdFNlbGVjdG9yIGZyb20gXCIuL2FzdC9zZWxlY3RvcnNcIjtcbmltcG9ydCB0cmFjZVNlbGVjdG9yIGZyb20gXCIuL3RyYWNlL3NlbGVjdG9yc1wiO1xuaW1wb3J0IGV2bVNlbGVjdG9yIGZyb20gXCIuL2V2bS9zZWxlY3RvcnNcIjtcbmltcG9ydCBzb2xpZGl0eVNlbGVjdG9yIGZyb20gXCIuL3NvbGlkaXR5L3NlbGVjdG9yc1wiO1xuaW1wb3J0IHNlc3Npb25TZWxlY3RvciBmcm9tIFwiLi9zZXNzaW9uL3NlbGVjdG9yc1wiO1xuaW1wb3J0IGNvbnRyb2xsZXJTZWxlY3RvciBmcm9tIFwiLi9jb250cm9sbGVyL3NlbGVjdG9yc1wiO1xuXG4vKipcbiAqIEBleGFtcGxlXG4gKiBsZXQgc2Vzc2lvbiA9IERlYnVnZ2VyXG4gKiAgIC5mb3JUeCg8dHhIYXNoPiwge1xuICogICAgIGNvbnRyYWN0czogWzxjb250cmFjdCBvYmo+LCAuLi5dLFxuICogICAgIHByb3ZpZGVyOiA8cHJvdmlkZXIgaW5zdGFuY2U+XG4gKiAgIH0pXG4gKiAgIC5jb25uZWN0KCk7XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIERlYnVnZ2VyIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7U2Vzc2lvbn0gc2Vzc2lvbiAtIGRlYnVnZ2VyIHNlc3Npb25cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGNvbnN0cnVjdG9yKHNlc3Npb24pIHtcbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX3Nlc3Npb24gPSBzZXNzaW9uO1xuICB9XG5cbiAgLyoqXG4gICAqIEluc3RhbnRpYXRlcyBhIERlYnVnZ2VyIGZvciBhIGdpdmVuIHRyYW5zYWN0aW9uIGhhc2guXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0eEhhc2ggLSB0cmFuc2FjdGlvbiBoYXNoIHdpdGggbGVhZGluZyBcIjB4XCJcbiAgICogQHBhcmFtIHt7Y29udHJhY3RzOiBBcnJheTxDb250cmFjdD4sIGZpbGVzOiBBcnJheTxTdHJpbmc+LCBwcm92aWRlcjogV2ViM1Byb3ZpZGVyfX0gb3B0aW9ucyAtXG4gICAqIEByZXR1cm4ge0RlYnVnZ2VyfSBpbnN0YW5jZVxuICAgKi9cbiAgc3RhdGljIGFzeW5jIGZvclR4KHR4SGFzaCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgZXhwZWN0Lm9wdGlvbnMob3B0aW9ucywgW1wiY29udHJhY3RzXCIsIFwicHJvdmlkZXJcIl0pO1xuXG4gICAgbGV0IHNlc3Npb24gPSBuZXcgU2Vzc2lvbihcbiAgICAgIG9wdGlvbnMuY29udHJhY3RzLFxuICAgICAgb3B0aW9ucy5maWxlcyxcbiAgICAgIG9wdGlvbnMucHJvdmlkZXIsXG4gICAgICB0eEhhc2hcbiAgICApO1xuXG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IHNlc3Npb24ucmVhZHkoKTtcbiAgICAgIGRlYnVnKFwic2Vzc2lvbiByZWFkeVwiKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBkZWJ1ZyhcImVycm9yIG9jY3VycmVkLCB1bmxvYWRlZFwiKTtcbiAgICAgIHNlc3Npb24udW5sb2FkKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyB0aGlzKHNlc3Npb24pO1xuICB9XG5cbiAgLypcbiAgICogSW5zdGFudGlhdGVzIGEgRGVidWdnZXIgZm9yIGEgZ2l2ZW4gcHJvamVjdCAod2l0aCBubyB0cmFuc2FjdGlvbiBsb2FkZWQpXG4gICAqXG4gICAqIEBwYXJhbSB7e2NvbnRyYWN0czogQXJyYXk8Q29udHJhY3Q+LCBmaWxlczogQXJyYXk8U3RyaW5nPiwgcHJvdmlkZXI6IFdlYjNQcm92aWRlcn19IG9wdGlvbnMgLVxuICAgKiBAcmV0dXJuIHtEZWJ1Z2dlcn0gaW5zdGFuY2VcbiAgICovXG4gIHN0YXRpYyBhc3luYyBmb3JQcm9qZWN0KG9wdGlvbnMgPSB7fSkge1xuICAgIGV4cGVjdC5vcHRpb25zKG9wdGlvbnMsIFtcImNvbnRyYWN0c1wiLCBcInByb3ZpZGVyXCJdKTtcblxuICAgIGxldCBzZXNzaW9uID0gbmV3IFNlc3Npb24oXG4gICAgICBvcHRpb25zLmNvbnRyYWN0cyxcbiAgICAgIG9wdGlvbnMuZmlsZXMsXG4gICAgICBvcHRpb25zLnByb3ZpZGVyXG4gICAgKTtcblxuICAgIGF3YWl0IHNlc3Npb24ucmVhZHkoKTtcblxuICAgIHJldHVybiBuZXcgdGhpcyhzZXNzaW9uKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb25uZWN0cyB0byB0aGUgaW5zdGFudGlhdGVkIERlYnVnZ2VyLlxuICAgKlxuICAgKiBAcmV0dXJuIHtTZXNzaW9ufSBzZXNzaW9uIGluc3RhbmNlXG4gICAqL1xuICBjb25uZWN0KCkge1xuICAgIHJldHVybiB0aGlzLl9zZXNzaW9uO1xuICB9XG5cbiAgLyoqXG4gICAqIEV4cG9ydGVkIHNlbGVjdG9yc1xuICAgKlxuICAgKiBTZWUgaW5kaXZpZHVhbCBzZWxlY3RvciBkb2NzIGZvciBmdWxsIGxpc3RpbmdcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogRGVidWdnZXIuc2VsZWN0b3JzLmFzdC5jdXJyZW50LnRyZWVcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogRGVidWdnZXIuc2VsZWN0b3JzLnNvbGlkaXR5LmN1cnJlbnQuaW5zdHJ1Y3Rpb25cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogRGVidWdnZXIuc2VsZWN0b3JzLnRyYWNlLnN0ZXBzXG4gICAqL1xuICBzdGF0aWMgZ2V0IHNlbGVjdG9ycygpIHtcbiAgICByZXR1cm4gY3JlYXRlTmVzdGVkU2VsZWN0b3Ioe1xuICAgICAgYXN0OiBhc3RTZWxlY3RvcixcbiAgICAgIGRhdGE6IGRhdGFTZWxlY3RvcixcbiAgICAgIHRyYWNlOiB0cmFjZVNlbGVjdG9yLFxuICAgICAgZXZtOiBldm1TZWxlY3RvcixcbiAgICAgIHNvbGlkaXR5OiBzb2xpZGl0eVNlbGVjdG9yLFxuICAgICAgc2Vzc2lvbjogc2Vzc2lvblNlbGVjdG9yLFxuICAgICAgY29udHJvbGxlcjogY29udHJvbGxlclNlbGVjdG9yXG4gICAgfSk7XG4gIH1cbn1cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBDb250cmFjdFxuICogQHByb3BlcnR5IHtzdHJpbmd9IGNvbnRyYWN0TmFtZSBjb250cmFjdCBuYW1lXG4gKiBAcHJvcGVydHkge3N0cmluZ30gc291cmNlIHNvbGlkaXR5IHNvdXJjZSBjb2RlXG4gKiBAcHJvcGVydHkge3N0cmluZ30gc291cmNlUGF0aCBwYXRoIHRvIHNvdXJjZSBmaWxlXG4gKiBAcHJvcGVydHkge3N0cmluZ30gYmluYXJ5IDB4LXByZWZpeGVkIGhleCBzdHJpbmcgd2l0aCBjcmVhdGUgYnl0ZWNvZGVcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBzb3VyY2VNYXAgc29saWRpdHkgc291cmNlIG1hcCBmb3IgY3JlYXRlIGJ5dGVjb2RlXG4gKiBAcHJvcGVydHkge09iamVjdH0gYXN0IEFic3RyYWN0IFN5bnRheCBUcmVlIGZyb20gU29saWRpdHlcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBkZXBsb3llZEJpbmFyeSAweC1wcmVmaXhlZCBjb21waWxlZCBiaW5hcnkgKG9uIGNoYWluKVxuICogQHByb3BlcnR5IHtzdHJpbmd9IGRlcGxveWVkU291cmNlTWFwIHNvbGlkaXR5IHNvdXJjZSBtYXAgZm9yIG9uLWNoYWluIGJ5dGVjb2RlXG4gKi9cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBsaWIvZGVidWdnZXIuanMiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJ0cnVmZmxlLWV4cGVjdFwiKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBleHRlcm5hbCBcInRydWZmbGUtZXhwZWN0XCJcbi8vIG1vZHVsZSBpZCA9IDM5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCBkZWJ1Z01vZHVsZSBmcm9tIFwiZGVidWdcIjtcbmNvbnN0IGRlYnVnID0gZGVidWdNb2R1bGUoXCJkZWJ1Z2dlcjpzZXNzaW9uXCIpO1xuXG5pbXBvcnQgY29uZmlndXJlU3RvcmUgZnJvbSBcImxpYi9zdG9yZVwiO1xuXG5pbXBvcnQgKiBhcyBjb250cm9sbGVyIGZyb20gXCJsaWIvY29udHJvbGxlci9hY3Rpb25zXCI7XG5pbXBvcnQgKiBhcyBhY3Rpb25zIGZyb20gXCIuL2FjdGlvbnNcIjtcbmltcG9ydCBkYXRhIGZyb20gXCJsaWIvZGF0YS9zZWxlY3RvcnNcIjtcbmltcG9ydCBzZXNzaW9uIGZyb20gXCJsaWIvc2Vzc2lvbi9zZWxlY3RvcnNcIjtcbmltcG9ydCAqIGFzIGRhdGFTYWdhcyBmcm9tIFwibGliL2RhdGEvc2FnYXNcIjtcbmltcG9ydCAqIGFzIGNvbnRyb2xsZXJTYWdhcyBmcm9tIFwibGliL2NvbnRyb2xsZXIvc2FnYXNcIjtcbmltcG9ydCAqIGFzIHNhZ2FzIGZyb20gXCIuL3NhZ2FzXCI7XG5pbXBvcnQgY29udHJvbGxlclNlbGVjdG9yIGZyb20gXCJsaWIvY29udHJvbGxlci9zZWxlY3RvcnNcIjtcblxuaW1wb3J0IHJvb3RTYWdhIGZyb20gXCIuL3NhZ2FzXCI7XG5pbXBvcnQgcmVkdWNlciBmcm9tIFwiLi9yZWR1Y2Vyc1wiO1xuXG4vKipcbiAqIERlYnVnZ2VyIFNlc3Npb25cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2Vzc2lvbiB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge0FycmF5PENvbnRyYWN0Pn0gY29udHJhY3RzIC0gY29udHJhY3QgZGVmaW5pdGlvbnNcbiAgICogQHBhcmFtIHtBcnJheTxTdHJpbmc+fSBmaWxlcyAtIGFycmF5IG9mIGZpbGVuYW1lcyBmb3Igc291cmNlTWFwIGluZGV4ZXNcbiAgICogQHBhcmFtIHtXZWIzUHJvdmlkZXJ9IHByb3ZpZGVyIC0gd2ViMyBwcm92aWRlclxuICAgKiB0eEhhc2ggcGFyYW1ldGVyIGlzIG5vdyBvcHRpb25hbCFcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGNvbnN0cnVjdG9yKGNvbnRyYWN0cywgZmlsZXMsIHByb3ZpZGVyLCB0eEhhc2gpIHtcbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGxldCB7IHN0b3JlLCBzYWdhTWlkZGxld2FyZSB9ID0gY29uZmlndXJlU3RvcmUocmVkdWNlciwgcm9vdFNhZ2EpO1xuICAgIHRoaXMuX3N0b3JlID0gc3RvcmU7XG4gICAgdGhpcy5fc2FnYU1pZGRsZXdhcmUgPSBzYWdhTWlkZGxld2FyZTtcblxuICAgIGxldCB7IGNvbnRleHRzLCBzb3VyY2VzIH0gPSBTZXNzaW9uLm5vcm1hbGl6ZShjb250cmFjdHMsIGZpbGVzKTtcblxuICAgIC8vIHJlY29yZCBjb250cmFjdHNcbiAgICB0aGlzLl9zdG9yZS5kaXNwYXRjaChhY3Rpb25zLnJlY29yZENvbnRyYWN0cyhjb250ZXh0cywgc291cmNlcykpO1xuXG4gICAgLy9zZXQgdXAgdGhlIHJlYWR5IGxpc3RlbmVyXG4gICAgdGhpcy5fcmVhZHkgPSBuZXcgUHJvbWlzZSgoYWNjZXB0LCByZWplY3QpID0+IHtcbiAgICAgIGNvbnN0IHVuc3Vic2NyaWJlID0gdGhpcy5fc3RvcmUuc3Vic2NyaWJlKCgpID0+IHtcbiAgICAgICAgaWYgKHRoaXMudmlldyhzZXNzaW9uLnN0YXR1cy5yZWFkeSkpIHtcbiAgICAgICAgICBkZWJ1ZyhcInJlYWR5IVwiKTtcbiAgICAgICAgICB1bnN1YnNjcmliZSgpO1xuICAgICAgICAgIGFjY2VwdCgpO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMudmlldyhzZXNzaW9uLnN0YXR1cy5lcnJvcmVkKSkge1xuICAgICAgICAgIGRlYnVnKFwiZXJyb3IhXCIpO1xuICAgICAgICAgIHVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgcmVqZWN0KHRoaXMudmlldyhzZXNzaW9uLnN0YXR1cy5lcnJvcikpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIC8vbm90ZSB0aGF0IHR4SGFzaCBpcyBub3cgb3B0aW9uYWxcbiAgICB0aGlzLl9zdG9yZS5kaXNwYXRjaChhY3Rpb25zLnN0YXJ0KHByb3ZpZGVyLCB0eEhhc2gpKTtcbiAgfVxuXG4gIGFzeW5jIHJlYWR5KCkge1xuICAgIGF3YWl0IHRoaXMuX3JlYWR5O1xuICB9XG5cbiAgYXN5bmMgcmVhZHlBZ2FpbkFmdGVyTG9hZGluZyhzZXNzaW9uQWN0aW9uKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChhY2NlcHQsIHJlamVjdCkgPT4ge1xuICAgICAgbGV0IGhhc1N0YXJ0ZWRXYWl0aW5nID0gZmFsc2U7XG4gICAgICBkZWJ1ZyhcInJlcmVhZHkgbGlzdGVuZXIgc2V0IHVwXCIpO1xuICAgICAgY29uc3QgdW5zdWJzY3JpYmUgPSB0aGlzLl9zdG9yZS5zdWJzY3JpYmUoKCkgPT4ge1xuICAgICAgICBkZWJ1ZyhcInJlcmVhZHk/XCIpO1xuICAgICAgICBpZiAoaGFzU3RhcnRlZFdhaXRpbmcpIHtcbiAgICAgICAgICBpZiAodGhpcy52aWV3KHNlc3Npb24uc3RhdHVzLnJlYWR5KSkge1xuICAgICAgICAgICAgZGVidWcoXCJyZXJlYWR5IVwiKTtcbiAgICAgICAgICAgIHVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICBhY2NlcHQodHJ1ZSk7XG4gICAgICAgICAgfSBlbHNlIGlmICh0aGlzLnZpZXcoc2Vzc2lvbi5zdGF0dXMuZXJyb3JlZCkpIHtcbiAgICAgICAgICAgIHVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICBkZWJ1ZyhcImVycm9yIVwiKTtcbiAgICAgICAgICAgIHJlamVjdCh0aGlzLnZpZXcoc2Vzc2lvbi5zdGF0dXMuZXJyb3IpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHRoaXMudmlldyhzZXNzaW9uLnN0YXR1cy53YWl0aW5nKSkge1xuICAgICAgICAgICAgZGVidWcoXCJzdGFydGVkIHdhaXRpbmdcIik7XG4gICAgICAgICAgICBoYXNTdGFydGVkV2FpdGluZyA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB0aGlzLmRpc3BhdGNoKHNlc3Npb25BY3Rpb24pO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFNwbGl0IHVwIGFydGlmYWN0cyBpbnRvIFwiY29udGV4dHNcIiBhbmQgXCJzb3VyY2VzXCIsIGRpdmlkaW5nIGFydGlmYWN0XG4gICAqIGRhdGEgaW50byBhcHByb3ByaWF0ZSBidWNrZXRzLlxuICAgKlxuICAgKiBNdWx0aXBsZSBjb250cmFjdHMgY2FuIGJlIGRlZmluZWQgaW4gdGhlIHNhbWUgc291cmNlIGZpbGUsIGJ1dCBoYXZlXG4gICAqIGRpZmZlcmVudCBieXRlY29kZXMuXG4gICAqXG4gICAqIFRoaXMgaXRlcmF0ZXMgb3ZlciB0aGUgY29udHJhY3RzIGFuZCBjb2xsZWN0cyBiaW5hcmllcyBzZXBhcmF0ZWx5XG4gICAqIGZyb20gc291cmNlcywgdXNpbmcgdGhlIG9wdGlvbmFsIGBmaWxlc2AgYXJndW1lbnQgdG8gZm9yY2VcbiAgICogc291cmNlIG9yZGVyaW5nLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgc3RhdGljIG5vcm1hbGl6ZShjb250cmFjdHMsIGZpbGVzID0gbnVsbCkge1xuICAgIGxldCBzb3VyY2VzQnlQYXRoID0ge307XG4gICAgbGV0IGNvbnRleHRzID0gW107XG4gICAgbGV0IHNvdXJjZXM7XG5cbiAgICBmb3IgKGxldCBjb250cmFjdCBvZiBjb250cmFjdHMpIHtcbiAgICAgIGxldCB7XG4gICAgICAgIGNvbnRyYWN0TmFtZSxcbiAgICAgICAgYmluYXJ5LFxuICAgICAgICBzb3VyY2VNYXAsXG4gICAgICAgIGRlcGxveWVkQmluYXJ5LFxuICAgICAgICBkZXBsb3llZFNvdXJjZU1hcCxcbiAgICAgICAgc291cmNlUGF0aCxcbiAgICAgICAgc291cmNlLFxuICAgICAgICBhc3QsXG4gICAgICAgIGFiaSxcbiAgICAgICAgY29tcGlsZXJcbiAgICAgIH0gPSBjb250cmFjdDtcblxuICAgICAgbGV0IGNvbnRyYWN0Tm9kZSA9IGFzdC5ub2Rlcy5maW5kKFxuICAgICAgICBub2RlID0+XG4gICAgICAgICAgbm9kZS5ub2RlVHlwZSA9PT0gXCJDb250cmFjdERlZmluaXRpb25cIiAmJiBub2RlLm5hbWUgPT09IGNvbnRyYWN0TmFtZVxuICAgICAgKTsgLy9pZGVhbGx5IHdlJ2QgaG9sZCB0aGlzIG9mZiB0aWxsIGxhdGVyLCBidXQgdGhhdCB3b3VsZCBicmVhayB0aGVcbiAgICAgIC8vZGlyZWN0aW9uIG9mIHRoZSBldm0vc29saWRpdHkgZGVwZW5kZW5jZSwgc28gd2UgZG8gaXQgbm93XG5cbiAgICAgIGxldCBjb250cmFjdElkID0gY29udHJhY3ROb2RlLmlkO1xuICAgICAgbGV0IGNvbnRyYWN0S2luZCA9IGNvbnRyYWN0Tm9kZS5jb250cmFjdEtpbmQ7XG5cbiAgICAgIGRlYnVnKFwiY29udHJhY3ROYW1lICVzXCIsIGNvbnRyYWN0TmFtZSk7XG4gICAgICBkZWJ1ZyhcInNvdXJjZU1hcCAlb1wiLCBzb3VyY2VNYXApO1xuICAgICAgZGVidWcoXCJjb21waWxlciAlb1wiLCBjb21waWxlcik7XG4gICAgICBkZWJ1ZyhcImFiaSAlT1wiLCBhYmkpO1xuXG4gICAgICBzb3VyY2VzQnlQYXRoW3NvdXJjZVBhdGhdID0geyBzb3VyY2VQYXRoLCBzb3VyY2UsIGFzdCwgY29tcGlsZXIgfTtcblxuICAgICAgaWYgKGJpbmFyeSAmJiBiaW5hcnkgIT0gXCIweFwiKSB7XG4gICAgICAgIGNvbnRleHRzLnB1c2goe1xuICAgICAgICAgIGNvbnRyYWN0TmFtZSxcbiAgICAgICAgICBiaW5hcnksXG4gICAgICAgICAgc291cmNlTWFwLFxuICAgICAgICAgIGFiaSxcbiAgICAgICAgICBjb21waWxlcixcbiAgICAgICAgICBjb250cmFjdElkLFxuICAgICAgICAgIGNvbnRyYWN0S2luZCxcbiAgICAgICAgICBpc0NvbnN0cnVjdG9yOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBpZiAoZGVwbG95ZWRCaW5hcnkgJiYgZGVwbG95ZWRCaW5hcnkgIT0gXCIweFwiKSB7XG4gICAgICAgIGNvbnRleHRzLnB1c2goe1xuICAgICAgICAgIGNvbnRyYWN0TmFtZSxcbiAgICAgICAgICBiaW5hcnk6IGRlcGxveWVkQmluYXJ5LFxuICAgICAgICAgIHNvdXJjZU1hcDogZGVwbG95ZWRTb3VyY2VNYXAsXG4gICAgICAgICAgYWJpLFxuICAgICAgICAgIGNvbXBpbGVyLFxuICAgICAgICAgIGNvbnRyYWN0SWQsXG4gICAgICAgICAgY29udHJhY3RLaW5kLFxuICAgICAgICAgIGlzQ29uc3RydWN0b3I6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghZmlsZXMpIHtcbiAgICAgIHNvdXJjZXMgPSBPYmplY3QudmFsdWVzKHNvdXJjZXNCeVBhdGgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzb3VyY2VzID0gZmlsZXMubWFwKGZpbGUgPT4gc291cmNlc0J5UGF0aFtmaWxlXSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHsgY29udGV4dHMsIHNvdXJjZXMgfTtcbiAgfVxuXG4gIGdldCBzdGF0ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fc3RvcmUuZ2V0U3RhdGUoKTtcbiAgfVxuXG4gIHZpZXcoc2VsZWN0b3IpIHtcbiAgICByZXR1cm4gc2VsZWN0b3IodGhpcy5zdGF0ZSk7XG4gIH1cblxuICBhc3luYyBkaXNwYXRjaChhY3Rpb24pIHtcbiAgICB0aGlzLl9zdG9yZS5kaXNwYXRjaChhY3Rpb24pO1xuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQWxsb3dzIHJ1bm5pbmcgYW55IHNhZ2EgLS0gZm9yIGludGVybmFsIHVzZSBvbmx5IVxuICAgKiBVc2luZyB0aGlzIGNvdWxkIHNlcmlvdXNseSBzY3JldyB1cCB0aGUgZGVidWdnZXIgc3RhdGUgaWYgeW91XG4gICAqIGRvbid0IGtub3cgd2hhdCB5b3UncmUgZG9pbmchXG4gICAqL1xuICBhc3luYyBfcnVuU2FnYShzYWdhLCAuLi5hcmdzKSB7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuX3NhZ2FNaWRkbGV3YXJlLnJ1bihzYWdhLCAuLi5hcmdzKS50b1Byb21pc2UoKTtcbiAgfVxuXG4gIGFzeW5jIGludGVycnVwdCgpIHtcbiAgICBhd2FpdCB0aGlzLmRpc3BhdGNoKGFjdGlvbnMuaW50ZXJydXB0KCkpO1xuICAgIGF3YWl0IHRoaXMuZGlzcGF0Y2goY29udHJvbGxlci5pbnRlcnJ1cHQoKSk7XG4gIH1cblxuICBhc3luYyBkb25lU3RlcHBpbmcoc3RlcHBlckFjdGlvbikge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgIGxldCBoYXNTdGFydGVkID0gZmFsc2U7XG4gICAgICBjb25zdCB1bnN1YnNjcmliZSA9IHRoaXMuX3N0b3JlLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICAgIGNvbnN0IGlzU3RlcHBpbmcgPSB0aGlzLnZpZXcoY29udHJvbGxlclNlbGVjdG9yLmlzU3RlcHBpbmcpO1xuXG4gICAgICAgIGlmIChpc1N0ZXBwaW5nICYmICFoYXNTdGFydGVkKSB7XG4gICAgICAgICAgaGFzU3RhcnRlZCA9IHRydWU7XG4gICAgICAgICAgZGVidWcoXCJoZWFyZCBzdGVwIHN0YXJ0XCIpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaXNTdGVwcGluZyAmJiBoYXNTdGFydGVkKSB7XG4gICAgICAgICAgZGVidWcoXCJoZWFyZCBzdGVwIHN0b3BcIik7XG4gICAgICAgICAgdW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICByZXNvbHZlKHRydWUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHRoaXMuZGlzcGF0Y2goc3RlcHBlckFjdGlvbik7XG4gICAgfSk7XG4gIH1cblxuICAvL3JldHVybnMgdHJ1ZSBvbiBzdWNjZXNzLCBmYWxzZSBvbiBhbHJlYWR5IGxvYWRlZCwgZXJyb3Igb2JqZWN0IG9uIGZhaWx1cmVcbiAgYXN5bmMgbG9hZCh0eEhhc2gpIHtcbiAgICBpZiAodGhpcy52aWV3KHNlc3Npb24uc3RhdHVzLmxvYWRlZCkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBhd2FpdCB0aGlzLnJlYWR5QWdhaW5BZnRlckxvYWRpbmcoYWN0aW9ucy5sb2FkVHJhbnNhY3Rpb24odHhIYXNoKSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgdGhpcy5fcnVuU2FnYShzYWdhcy51bmxvYWQpO1xuICAgICAgcmV0dXJuIGU7XG4gICAgfVxuICB9XG5cbiAgLy9yZXR1cm5zIHRydWUgb24gc3VjY2VzcywgZmFsc2Ugb24gYWxyZWFkeSB1bmxvYWRlZFxuICBhc3luYyB1bmxvYWQoKSB7XG4gICAgaWYgKCF0aGlzLnZpZXcoc2Vzc2lvbi5zdGF0dXMubG9hZGVkKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBkZWJ1ZyhcInVubG9hZGluZ1wiKTtcbiAgICBhd2FpdCB0aGlzLl9ydW5TYWdhKHNhZ2FzLnVubG9hZCk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvL05vdGU6IGNvdW50IGlzIGFuIG9wdGlvbmFsIGFyZ3VtZW50OyBkZWZhdWx0IGJlaGF2aW9yIGlzIHRvIGFkdmFuY2UgMVxuICBhc3luYyBhZHZhbmNlKGNvdW50KSB7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuZG9uZVN0ZXBwaW5nKGNvbnRyb2xsZXIuYWR2YW5jZShjb3VudCkpO1xuICB9XG5cbiAgYXN5bmMgc3RlcE5leHQoKSB7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuZG9uZVN0ZXBwaW5nKGNvbnRyb2xsZXIuc3RlcE5leHQoKSk7XG4gIH1cblxuICBhc3luYyBzdGVwT3ZlcigpIHtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5kb25lU3RlcHBpbmcoY29udHJvbGxlci5zdGVwT3ZlcigpKTtcbiAgfVxuXG4gIGFzeW5jIHN0ZXBJbnRvKCkge1xuICAgIHJldHVybiBhd2FpdCB0aGlzLmRvbmVTdGVwcGluZyhjb250cm9sbGVyLnN0ZXBJbnRvKCkpO1xuICB9XG5cbiAgYXN5bmMgc3RlcE91dCgpIHtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5kb25lU3RlcHBpbmcoY29udHJvbGxlci5zdGVwT3V0KCkpO1xuICB9XG5cbiAgYXN5bmMgcmVzZXQoKSB7XG4gICAgbGV0IGxvYWRlZCA9IHRoaXMudmlldyhzZXNzaW9uLnN0YXR1cy5sb2FkZWQpO1xuICAgIGlmICghbG9hZGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHJldHVybiBhd2FpdCB0aGlzLl9ydW5TYWdhKGNvbnRyb2xsZXJTYWdhcy5yZXNldCk7XG4gIH1cblxuICAvL05PVEU6IGJyZWFrcG9pbnRzIGlzIGFuIE9QVElPTkFMIGFyZ3VtZW50IGZvciBpZiB5b3Ugd2FudCB0byBzdXBwbHkgeW91clxuICAvL293biBsaXN0IG9mIGJyZWFrcG9pbnRzOyBsZWF2ZSBpdCBvdXQgdG8gdXNlIHRoZSBpbnRlcm5hbCBvbmUgKGFzXG4gIC8vY29udHJvbGxlZCBieSB0aGUgZnVuY3Rpb25zIGJlbG93KVxuICBhc3luYyBjb250aW51ZVVudGlsQnJlYWtwb2ludChicmVha3BvaW50cykge1xuICAgIHJldHVybiBhd2FpdCB0aGlzLmRvbmVTdGVwcGluZyhcbiAgICAgIGNvbnRyb2xsZXIuY29udGludWVVbnRpbEJyZWFrcG9pbnQoYnJlYWtwb2ludHMpXG4gICAgKTtcbiAgfVxuXG4gIGFzeW5jIGFkZEJyZWFrcG9pbnQoYnJlYWtwb2ludCkge1xuICAgIHJldHVybiBhd2FpdCB0aGlzLmRpc3BhdGNoKGNvbnRyb2xsZXIuYWRkQnJlYWtwb2ludChicmVha3BvaW50KSk7XG4gIH1cblxuICBhc3luYyByZW1vdmVCcmVha3BvaW50KGJyZWFrcG9pbnQpIHtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5kaXNwYXRjaChjb250cm9sbGVyLnJlbW92ZUJyZWFrcG9pbnQoYnJlYWtwb2ludCkpO1xuICB9XG5cbiAgYXN5bmMgcmVtb3ZlQWxsQnJlYWtwb2ludHMoKSB7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuZGlzcGF0Y2goY29udHJvbGxlci5yZW1vdmVBbGxCcmVha3BvaW50cygpKTtcbiAgfVxuXG4gIC8vZGVwcmVjYXRlZCAtLSBkZWNvZGUgaXMgbm93ICphbHdheXMqIHJlYWR5IVxuICBhc3luYyBkZWNvZGVSZWFkeSgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGFzeW5jIHZhcmlhYmxlKG5hbWUpIHtcbiAgICBjb25zdCBkZWZpbml0aW9ucyA9IHRoaXMudmlldyhkYXRhLmN1cnJlbnQuaWRlbnRpZmllcnMuZGVmaW5pdGlvbnMpO1xuICAgIGNvbnN0IHJlZnMgPSB0aGlzLnZpZXcoZGF0YS5jdXJyZW50LmlkZW50aWZpZXJzLnJlZnMpO1xuXG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuX3J1blNhZ2EoZGF0YVNhZ2FzLmRlY29kZSwgZGVmaW5pdGlvbnNbbmFtZV0sIHJlZnNbbmFtZV0pO1xuICB9XG5cbiAgYXN5bmMgdmFyaWFibGVzKCkge1xuICAgIGlmICghdGhpcy52aWV3KHNlc3Npb24uc3RhdHVzLmxvYWRlZCkpIHtcbiAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gICAgbGV0IGRlZmluaXRpb25zID0gdGhpcy52aWV3KGRhdGEuY3VycmVudC5pZGVudGlmaWVycy5kZWZpbml0aW9ucyk7XG4gICAgbGV0IHJlZnMgPSB0aGlzLnZpZXcoZGF0YS5jdXJyZW50LmlkZW50aWZpZXJzLnJlZnMpO1xuICAgIGxldCBkZWNvZGVkID0ge307XG4gICAgZm9yIChsZXQgW2lkZW50aWZpZXIsIHJlZl0gb2YgT2JqZWN0LmVudHJpZXMocmVmcykpIHtcbiAgICAgIGlmIChpZGVudGlmaWVyIGluIGRlZmluaXRpb25zKSB7XG4gICAgICAgIGRlY29kZWRbaWRlbnRpZmllcl0gPSBhd2FpdCB0aGlzLl9ydW5TYWdhKFxuICAgICAgICAgIGRhdGFTYWdhcy5kZWNvZGUsXG4gICAgICAgICAgZGVmaW5pdGlvbnNbaWRlbnRpZmllcl0sXG4gICAgICAgICAgcmVmXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBkZWNvZGVkO1xuICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gbGliL3Nlc3Npb24vaW5kZXguanMiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJiYWJlbC1ydW50aW1lL2NvcmUtanMvcHJvbWlzZVwiKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBleHRlcm5hbCBcImJhYmVsLXJ1bnRpbWUvY29yZS1qcy9wcm9taXNlXCJcbi8vIG1vZHVsZSBpZCA9IDQxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi9wcm9kdWN0aW9uXCIpO1xufSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJ0ZXN0XCIpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi90ZXN0XCIpO1xufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi9kZXZlbG9wbWVudFwiKTtcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBsaWIvc3RvcmUvaW5kZXguanMiLCJpbXBvcnQgY29uZmlndXJlU3RvcmUgZnJvbSBcIi4vY29tbW9uXCI7XG5leHBvcnQgZGVmYXVsdCBjb25maWd1cmVTdG9yZTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBsaWIvc3RvcmUvcHJvZHVjdGlvbi5qcyIsImltcG9ydCBkZWJ1Z01vZHVsZSBmcm9tIFwiZGVidWdcIjtcbmNvbnN0IGRlYnVnID0gZGVidWdNb2R1bGUoXCJkZWJ1Z2dlcjpzdG9yZTpjb21tb25cIik7XG5jb25zdCByZWR1eERlYnVnID0gZGVidWdNb2R1bGUoXCJkZWJ1Z2dlcjpyZWR1eFwiKTtcblxuaW1wb3J0IHsgY29tcG9zZSwgY3JlYXRlU3RvcmUsIGFwcGx5TWlkZGxld2FyZSB9IGZyb20gXCJyZWR1eFwiO1xuaW1wb3J0IGNyZWF0ZVNhZ2FNaWRkbGV3YXJlIGZyb20gXCJyZWR1eC1zYWdhXCI7XG5pbXBvcnQgY3JlYXRlTG9nZ2VyIGZyb20gXCJyZWR1eC1jbGktbG9nZ2VyXCI7XG5cbmV4cG9ydCBmdW5jdGlvbiBhYmJyZXZpYXRlVmFsdWVzKHZhbHVlLCBvcHRpb25zID0ge30sIGRlcHRoID0gMCkge1xuICBvcHRpb25zLnN0cmluZ0xpbWl0ID0gb3B0aW9ucy5zdHJpbmdMaW1pdCB8fCA2NjtcbiAgb3B0aW9ucy5hcnJheUxpbWl0ID0gb3B0aW9ucy5hcnJheUxpbWl0IHx8IDg7XG4gIG9wdGlvbnMucmVjdXJzZUxpbWl0ID0gb3B0aW9ucy5yZWN1cnNlTGltaXQgfHwgNDtcblxuICBpZiAoZGVwdGggPiBvcHRpb25zLnJlY3Vyc2VMaW1pdCkge1xuICAgIHJldHVybiBcIi4uLlwiO1xuICB9XG5cbiAgY29uc3QgcmVjdXJzZSA9IGNoaWxkID0+IGFiYnJldmlhdGVWYWx1ZXMoY2hpbGQsIG9wdGlvbnMsIGRlcHRoICsgMSk7XG5cbiAgaWYgKHZhbHVlIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICBpZiAodmFsdWUubGVuZ3RoID4gb3B0aW9ucy5hcnJheUxpbWl0KSB7XG4gICAgICB2YWx1ZSA9IFtcbiAgICAgICAgLi4udmFsdWUuc2xpY2UoMCwgb3B0aW9ucy5hcnJheUxpbWl0IC8gMiksXG4gICAgICAgIFwiLi4uXCIsXG4gICAgICAgIC4uLnZhbHVlLnNsaWNlKHZhbHVlLmxlbmd0aCAtIG9wdGlvbnMuYXJyYXlMaW1pdCAvIDIgKyAxKVxuICAgICAgXTtcbiAgICB9XG5cbiAgICByZXR1cm4gdmFsdWUubWFwKHJlY3Vyc2UpO1xuICB9IGVsc2UgaWYgKHZhbHVlIGluc3RhbmNlb2YgT2JqZWN0KSB7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oXG4gICAgICB7fSxcbiAgICAgIC4uLk9iamVjdC5lbnRyaWVzKHZhbHVlKS5tYXAoKFtrLCB2XSkgPT4gKHsgW3JlY3Vyc2UoayldOiByZWN1cnNlKHYpIH0pKVxuICAgICk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiICYmIHZhbHVlLmxlbmd0aCA+IG9wdGlvbnMuc3RyaW5nTGltaXQpIHtcbiAgICBsZXQgaW5uZXIgPSBcIi4uLlwiO1xuICAgIGxldCBleHRyYWN0QW1vdW50ID0gKG9wdGlvbnMuc3RyaW5nTGltaXQgLSBpbm5lci5sZW5ndGgpIC8gMjtcbiAgICBsZXQgbGVhZGluZyA9IHZhbHVlLnNsaWNlKDAsIE1hdGguY2VpbChleHRyYWN0QW1vdW50KSk7XG4gICAgbGV0IHRyYWlsaW5nID0gdmFsdWUuc2xpY2UodmFsdWUubGVuZ3RoIC0gTWF0aC5mbG9vcihleHRyYWN0QW1vdW50KSk7XG4gICAgcmV0dXJuIGAke2xlYWRpbmd9JHtpbm5lcn0ke3RyYWlsaW5nfWA7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGNvbmZpZ3VyZVN0b3JlKFxuICByZWR1Y2VyLFxuICBzYWdhLFxuICBpbml0aWFsU3RhdGUsXG4gIGNvbXBvc2VFbmhhbmNlcnNcbikge1xuICBjb25zdCBzYWdhTWlkZGxld2FyZSA9IGNyZWF0ZVNhZ2FNaWRkbGV3YXJlKCk7XG5cbiAgaWYgKCFjb21wb3NlRW5oYW5jZXJzKSB7XG4gICAgY29tcG9zZUVuaGFuY2VycyA9IGNvbXBvc2U7XG4gIH1cblxuICBjb25zdCBsb2dnZXJNaWRkbGV3YXJlID0gY3JlYXRlTG9nZ2VyKHtcbiAgICBsb2c6IHJlZHV4RGVidWcsXG4gICAgc3RhdGVUcmFuc2Zvcm1lcjogc3RhdGUgPT5cbiAgICAgIGFiYnJldmlhdGVWYWx1ZXMoc3RhdGUsIHtcbiAgICAgICAgYXJyYXlMaW1pdDogNCxcbiAgICAgICAgcmVjdXJzZUxpbWl0OiAzXG4gICAgICB9KSxcbiAgICBhY3Rpb25UcmFuc2Zvcm1lcjogYWJicmV2aWF0ZVZhbHVlc1xuICB9KTtcblxuICBsZXQgc3RvcmUgPSBjcmVhdGVTdG9yZShcbiAgICByZWR1Y2VyLFxuICAgIGluaXRpYWxTdGF0ZSxcblxuICAgIGNvbXBvc2VFbmhhbmNlcnMoYXBwbHlNaWRkbGV3YXJlKHNhZ2FNaWRkbGV3YXJlLCBsb2dnZXJNaWRkbGV3YXJlKSlcbiAgKTtcblxuICBzYWdhTWlkZGxld2FyZS5ydW4oc2FnYSk7XG5cbiAgcmV0dXJuIHsgc3RvcmUsIHNhZ2FNaWRkbGV3YXJlIH07XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gbGliL3N0b3JlL2NvbW1vbi5qcyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcInJlZHV4LXNhZ2FcIik7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZXh0ZXJuYWwgXCJyZWR1eC1zYWdhXCJcbi8vIG1vZHVsZSBpZCA9IDQ1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcInJlZHV4LWNsaS1sb2dnZXJcIik7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZXh0ZXJuYWwgXCJyZWR1eC1jbGktbG9nZ2VyXCJcbi8vIG1vZHVsZSBpZCA9IDQ2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBqc29uID0gdHlwZW9mIEpTT04gIT09ICd1bmRlZmluZWQnID8gSlNPTiA6IHJlcXVpcmUoJ2pzb25pZnknKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob2JqLCBvcHRzKSB7XG4gICAgaWYgKCFvcHRzKSBvcHRzID0ge307XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSAnZnVuY3Rpb24nKSBvcHRzID0geyBjbXA6IG9wdHMgfTtcbiAgICB2YXIgc3BhY2UgPSBvcHRzLnNwYWNlIHx8ICcnO1xuICAgIGlmICh0eXBlb2Ygc3BhY2UgPT09ICdudW1iZXInKSBzcGFjZSA9IEFycmF5KHNwYWNlKzEpLmpvaW4oJyAnKTtcbiAgICB2YXIgY3ljbGVzID0gKHR5cGVvZiBvcHRzLmN5Y2xlcyA9PT0gJ2Jvb2xlYW4nKSA/IG9wdHMuY3ljbGVzIDogZmFsc2U7XG4gICAgdmFyIHJlcGxhY2VyID0gb3B0cy5yZXBsYWNlciB8fCBmdW5jdGlvbihrZXksIHZhbHVlKSB7IHJldHVybiB2YWx1ZTsgfTtcblxuICAgIHZhciBjbXAgPSBvcHRzLmNtcCAmJiAoZnVuY3Rpb24gKGYpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICAgICAgICB2YXIgYW9iaiA9IHsga2V5OiBhLCB2YWx1ZTogbm9kZVthXSB9O1xuICAgICAgICAgICAgICAgIHZhciBib2JqID0geyBrZXk6IGIsIHZhbHVlOiBub2RlW2JdIH07XG4gICAgICAgICAgICAgICAgcmV0dXJuIGYoYW9iaiwgYm9iaik7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgIH0pKG9wdHMuY21wKTtcblxuICAgIHZhciBzZWVuID0gW107XG4gICAgcmV0dXJuIChmdW5jdGlvbiBzdHJpbmdpZnkgKHBhcmVudCwga2V5LCBub2RlLCBsZXZlbCkge1xuICAgICAgICB2YXIgaW5kZW50ID0gc3BhY2UgPyAoJ1xcbicgKyBuZXcgQXJyYXkobGV2ZWwgKyAxKS5qb2luKHNwYWNlKSkgOiAnJztcbiAgICAgICAgdmFyIGNvbG9uU2VwYXJhdG9yID0gc3BhY2UgPyAnOiAnIDogJzonO1xuXG4gICAgICAgIGlmIChub2RlICYmIG5vZGUudG9KU09OICYmIHR5cGVvZiBub2RlLnRvSlNPTiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgbm9kZSA9IG5vZGUudG9KU09OKCk7XG4gICAgICAgIH1cblxuICAgICAgICBub2RlID0gcmVwbGFjZXIuY2FsbChwYXJlbnQsIGtleSwgbm9kZSk7XG5cbiAgICAgICAgaWYgKG5vZGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Ygbm9kZSAhPT0gJ29iamVjdCcgfHwgbm9kZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGpzb24uc3RyaW5naWZ5KG5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0FycmF5KG5vZGUpKSB7XG4gICAgICAgICAgICB2YXIgb3V0ID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgaXRlbSA9IHN0cmluZ2lmeShub2RlLCBpLCBub2RlW2ldLCBsZXZlbCsxKSB8fCBqc29uLnN0cmluZ2lmeShudWxsKTtcbiAgICAgICAgICAgICAgICBvdXQucHVzaChpbmRlbnQgKyBzcGFjZSArIGl0ZW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuICdbJyArIG91dC5qb2luKCcsJykgKyBpbmRlbnQgKyAnXSc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoc2Vlbi5pbmRleE9mKG5vZGUpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIGlmIChjeWNsZXMpIHJldHVybiBqc29uLnN0cmluZ2lmeSgnX19jeWNsZV9fJyk7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQ29udmVydGluZyBjaXJjdWxhciBzdHJ1Y3R1cmUgdG8gSlNPTicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBzZWVuLnB1c2gobm9kZSk7XG5cbiAgICAgICAgICAgIHZhciBrZXlzID0gb2JqZWN0S2V5cyhub2RlKS5zb3J0KGNtcCAmJiBjbXAobm9kZSkpO1xuICAgICAgICAgICAgdmFyIG91dCA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gc3RyaW5naWZ5KG5vZGUsIGtleSwgbm9kZVtrZXldLCBsZXZlbCsxKTtcblxuICAgICAgICAgICAgICAgIGlmKCF2YWx1ZSkgY29udGludWU7XG5cbiAgICAgICAgICAgICAgICB2YXIga2V5VmFsdWUgPSBqc29uLnN0cmluZ2lmeShrZXkpXG4gICAgICAgICAgICAgICAgICAgICsgY29sb25TZXBhcmF0b3JcbiAgICAgICAgICAgICAgICAgICAgKyB2YWx1ZTtcbiAgICAgICAgICAgICAgICA7XG4gICAgICAgICAgICAgICAgb3V0LnB1c2goaW5kZW50ICsgc3BhY2UgKyBrZXlWYWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZWVuLnNwbGljZShzZWVuLmluZGV4T2Yobm9kZSksIDEpO1xuICAgICAgICAgICAgcmV0dXJuICd7JyArIG91dC5qb2luKCcsJykgKyBpbmRlbnQgKyAnfSc7XG4gICAgICAgIH1cbiAgICB9KSh7ICcnOiBvYmogfSwgJycsIG9iaiwgMCk7XG59O1xuXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKHgpIHtcbiAgICByZXR1cm4ge30udG9TdHJpbmcuY2FsbCh4KSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG5cbnZhciBvYmplY3RLZXlzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24gKG9iaikge1xuICAgIHZhciBoYXMgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5IHx8IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRydWUgfTtcbiAgICB2YXIga2V5cyA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICAgICAgaWYgKGhhcy5jYWxsKG9iaiwga2V5KSkga2V5cy5wdXNoKGtleSk7XG4gICAgfVxuICAgIHJldHVybiBrZXlzO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9Vc2Vycy9nbmlkYW4vc3JjL3dvcmsvdHJ1ZmZsZS9ub2RlX21vZHVsZXMvanNvbi1zdGFibGUtc3RyaW5naWZ5L2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSA0N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJleHBvcnRzLnBhcnNlID0gcmVxdWlyZSgnLi9saWIvcGFyc2UnKTtcbmV4cG9ydHMuc3RyaW5naWZ5ID0gcmVxdWlyZSgnLi9saWIvc3RyaW5naWZ5Jyk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvVXNlcnMvZ25pZGFuL3NyYy93b3JrL3RydWZmbGUvbm9kZV9tb2R1bGVzL2pzb25pZnkvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDQ4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBhdCwgLy8gVGhlIGluZGV4IG9mIHRoZSBjdXJyZW50IGNoYXJhY3RlclxuICAgIGNoLCAvLyBUaGUgY3VycmVudCBjaGFyYWN0ZXJcbiAgICBlc2NhcGVlID0ge1xuICAgICAgICAnXCInOiAgJ1wiJyxcbiAgICAgICAgJ1xcXFwnOiAnXFxcXCcsXG4gICAgICAgICcvJzogICcvJyxcbiAgICAgICAgYjogICAgJ1xcYicsXG4gICAgICAgIGY6ICAgICdcXGYnLFxuICAgICAgICBuOiAgICAnXFxuJyxcbiAgICAgICAgcjogICAgJ1xccicsXG4gICAgICAgIHQ6ICAgICdcXHQnXG4gICAgfSxcbiAgICB0ZXh0LFxuXG4gICAgZXJyb3IgPSBmdW5jdGlvbiAobSkge1xuICAgICAgICAvLyBDYWxsIGVycm9yIHdoZW4gc29tZXRoaW5nIGlzIHdyb25nLlxuICAgICAgICB0aHJvdyB7XG4gICAgICAgICAgICBuYW1lOiAgICAnU3ludGF4RXJyb3InLFxuICAgICAgICAgICAgbWVzc2FnZTogbSxcbiAgICAgICAgICAgIGF0OiAgICAgIGF0LFxuICAgICAgICAgICAgdGV4dDogICAgdGV4dFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgXG4gICAgbmV4dCA9IGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIC8vIElmIGEgYyBwYXJhbWV0ZXIgaXMgcHJvdmlkZWQsIHZlcmlmeSB0aGF0IGl0IG1hdGNoZXMgdGhlIGN1cnJlbnQgY2hhcmFjdGVyLlxuICAgICAgICBpZiAoYyAmJiBjICE9PSBjaCkge1xuICAgICAgICAgICAgZXJyb3IoXCJFeHBlY3RlZCAnXCIgKyBjICsgXCInIGluc3RlYWQgb2YgJ1wiICsgY2ggKyBcIidcIik7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIEdldCB0aGUgbmV4dCBjaGFyYWN0ZXIuIFdoZW4gdGhlcmUgYXJlIG5vIG1vcmUgY2hhcmFjdGVycyxcbiAgICAgICAgLy8gcmV0dXJuIHRoZSBlbXB0eSBzdHJpbmcuXG4gICAgICAgIFxuICAgICAgICBjaCA9IHRleHQuY2hhckF0KGF0KTtcbiAgICAgICAgYXQgKz0gMTtcbiAgICAgICAgcmV0dXJuIGNoO1xuICAgIH0sXG4gICAgXG4gICAgbnVtYmVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBQYXJzZSBhIG51bWJlciB2YWx1ZS5cbiAgICAgICAgdmFyIG51bWJlcixcbiAgICAgICAgICAgIHN0cmluZyA9ICcnO1xuICAgICAgICBcbiAgICAgICAgaWYgKGNoID09PSAnLScpIHtcbiAgICAgICAgICAgIHN0cmluZyA9ICctJztcbiAgICAgICAgICAgIG5leHQoJy0nKTtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAoY2ggPj0gJzAnICYmIGNoIDw9ICc5Jykge1xuICAgICAgICAgICAgc3RyaW5nICs9IGNoO1xuICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaCA9PT0gJy4nKSB7XG4gICAgICAgICAgICBzdHJpbmcgKz0gJy4nO1xuICAgICAgICAgICAgd2hpbGUgKG5leHQoKSAmJiBjaCA+PSAnMCcgJiYgY2ggPD0gJzknKSB7XG4gICAgICAgICAgICAgICAgc3RyaW5nICs9IGNoO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChjaCA9PT0gJ2UnIHx8IGNoID09PSAnRScpIHtcbiAgICAgICAgICAgIHN0cmluZyArPSBjaDtcbiAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgIGlmIChjaCA9PT0gJy0nIHx8IGNoID09PSAnKycpIHtcbiAgICAgICAgICAgICAgICBzdHJpbmcgKz0gY2g7XG4gICAgICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd2hpbGUgKGNoID49ICcwJyAmJiBjaCA8PSAnOScpIHtcbiAgICAgICAgICAgICAgICBzdHJpbmcgKz0gY2g7XG4gICAgICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG51bWJlciA9ICtzdHJpbmc7XG4gICAgICAgIGlmICghaXNGaW5pdGUobnVtYmVyKSkge1xuICAgICAgICAgICAgZXJyb3IoXCJCYWQgbnVtYmVyXCIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG51bWJlcjtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgXG4gICAgc3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBQYXJzZSBhIHN0cmluZyB2YWx1ZS5cbiAgICAgICAgdmFyIGhleCxcbiAgICAgICAgICAgIGksXG4gICAgICAgICAgICBzdHJpbmcgPSAnJyxcbiAgICAgICAgICAgIHVmZmZmO1xuICAgICAgICBcbiAgICAgICAgLy8gV2hlbiBwYXJzaW5nIGZvciBzdHJpbmcgdmFsdWVzLCB3ZSBtdXN0IGxvb2sgZm9yIFwiIGFuZCBcXCBjaGFyYWN0ZXJzLlxuICAgICAgICBpZiAoY2ggPT09ICdcIicpIHtcbiAgICAgICAgICAgIHdoaWxlIChuZXh0KCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoY2ggPT09ICdcIicpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3RyaW5nO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY2ggPT09ICdcXFxcJykge1xuICAgICAgICAgICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gJ3UnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB1ZmZmZiA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgNDsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGV4ID0gcGFyc2VJbnQobmV4dCgpLCAxNik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFpc0Zpbml0ZShoZXgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1ZmZmZiA9IHVmZmZmICogMTYgKyBoZXg7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJpbmcgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSh1ZmZmZik7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGVzY2FwZWVbY2hdID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RyaW5nICs9IGVzY2FwZWVbY2hdO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzdHJpbmcgKz0gY2g7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVycm9yKFwiQmFkIHN0cmluZ1wiKTtcbiAgICB9LFxuXG4gICAgd2hpdGUgPSBmdW5jdGlvbiAoKSB7XG5cbi8vIFNraXAgd2hpdGVzcGFjZS5cblxuICAgICAgICB3aGlsZSAoY2ggJiYgY2ggPD0gJyAnKSB7XG4gICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgd29yZCA9IGZ1bmN0aW9uICgpIHtcblxuLy8gdHJ1ZSwgZmFsc2UsIG9yIG51bGwuXG5cbiAgICAgICAgc3dpdGNoIChjaCkge1xuICAgICAgICBjYXNlICd0JzpcbiAgICAgICAgICAgIG5leHQoJ3QnKTtcbiAgICAgICAgICAgIG5leHQoJ3InKTtcbiAgICAgICAgICAgIG5leHQoJ3UnKTtcbiAgICAgICAgICAgIG5leHQoJ2UnKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBjYXNlICdmJzpcbiAgICAgICAgICAgIG5leHQoJ2YnKTtcbiAgICAgICAgICAgIG5leHQoJ2EnKTtcbiAgICAgICAgICAgIG5leHQoJ2wnKTtcbiAgICAgICAgICAgIG5leHQoJ3MnKTtcbiAgICAgICAgICAgIG5leHQoJ2UnKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgY2FzZSAnbic6XG4gICAgICAgICAgICBuZXh0KCduJyk7XG4gICAgICAgICAgICBuZXh0KCd1Jyk7XG4gICAgICAgICAgICBuZXh0KCdsJyk7XG4gICAgICAgICAgICBuZXh0KCdsJyk7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlcnJvcihcIlVuZXhwZWN0ZWQgJ1wiICsgY2ggKyBcIidcIik7XG4gICAgfSxcblxuICAgIHZhbHVlLCAgLy8gUGxhY2UgaG9sZGVyIGZvciB0aGUgdmFsdWUgZnVuY3Rpb24uXG5cbiAgICBhcnJheSA9IGZ1bmN0aW9uICgpIHtcblxuLy8gUGFyc2UgYW4gYXJyYXkgdmFsdWUuXG5cbiAgICAgICAgdmFyIGFycmF5ID0gW107XG5cbiAgICAgICAgaWYgKGNoID09PSAnWycpIHtcbiAgICAgICAgICAgIG5leHQoJ1snKTtcbiAgICAgICAgICAgIHdoaXRlKCk7XG4gICAgICAgICAgICBpZiAoY2ggPT09ICddJykge1xuICAgICAgICAgICAgICAgIG5leHQoJ10nKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXJyYXk7ICAgLy8gZW1wdHkgYXJyYXlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdoaWxlIChjaCkge1xuICAgICAgICAgICAgICAgIGFycmF5LnB1c2godmFsdWUoKSk7XG4gICAgICAgICAgICAgICAgd2hpdGUoKTtcbiAgICAgICAgICAgICAgICBpZiAoY2ggPT09ICddJykge1xuICAgICAgICAgICAgICAgICAgICBuZXh0KCddJyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhcnJheTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbmV4dCgnLCcpO1xuICAgICAgICAgICAgICAgIHdoaXRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZXJyb3IoXCJCYWQgYXJyYXlcIik7XG4gICAgfSxcblxuICAgIG9iamVjdCA9IGZ1bmN0aW9uICgpIHtcblxuLy8gUGFyc2UgYW4gb2JqZWN0IHZhbHVlLlxuXG4gICAgICAgIHZhciBrZXksXG4gICAgICAgICAgICBvYmplY3QgPSB7fTtcblxuICAgICAgICBpZiAoY2ggPT09ICd7Jykge1xuICAgICAgICAgICAgbmV4dCgneycpO1xuICAgICAgICAgICAgd2hpdGUoKTtcbiAgICAgICAgICAgIGlmIChjaCA9PT0gJ30nKSB7XG4gICAgICAgICAgICAgICAgbmV4dCgnfScpO1xuICAgICAgICAgICAgICAgIHJldHVybiBvYmplY3Q7ICAgLy8gZW1wdHkgb2JqZWN0XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3aGlsZSAoY2gpIHtcbiAgICAgICAgICAgICAgICBrZXkgPSBzdHJpbmcoKTtcbiAgICAgICAgICAgICAgICB3aGl0ZSgpO1xuICAgICAgICAgICAgICAgIG5leHQoJzonKTtcbiAgICAgICAgICAgICAgICBpZiAoT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yKCdEdXBsaWNhdGUga2V5IFwiJyArIGtleSArICdcIicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvYmplY3Rba2V5XSA9IHZhbHVlKCk7XG4gICAgICAgICAgICAgICAgd2hpdGUoKTtcbiAgICAgICAgICAgICAgICBpZiAoY2ggPT09ICd9Jykge1xuICAgICAgICAgICAgICAgICAgICBuZXh0KCd9Jyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG5leHQoJywnKTtcbiAgICAgICAgICAgICAgICB3aGl0ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVycm9yKFwiQmFkIG9iamVjdFwiKTtcbiAgICB9O1xuXG52YWx1ZSA9IGZ1bmN0aW9uICgpIHtcblxuLy8gUGFyc2UgYSBKU09OIHZhbHVlLiBJdCBjb3VsZCBiZSBhbiBvYmplY3QsIGFuIGFycmF5LCBhIHN0cmluZywgYSBudW1iZXIsXG4vLyBvciBhIHdvcmQuXG5cbiAgICB3aGl0ZSgpO1xuICAgIHN3aXRjaCAoY2gpIHtcbiAgICBjYXNlICd7JzpcbiAgICAgICAgcmV0dXJuIG9iamVjdCgpO1xuICAgIGNhc2UgJ1snOlxuICAgICAgICByZXR1cm4gYXJyYXkoKTtcbiAgICBjYXNlICdcIic6XG4gICAgICAgIHJldHVybiBzdHJpbmcoKTtcbiAgICBjYXNlICctJzpcbiAgICAgICAgcmV0dXJuIG51bWJlcigpO1xuICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBjaCA+PSAnMCcgJiYgY2ggPD0gJzknID8gbnVtYmVyKCkgOiB3b3JkKCk7XG4gICAgfVxufTtcblxuLy8gUmV0dXJuIHRoZSBqc29uX3BhcnNlIGZ1bmN0aW9uLiBJdCB3aWxsIGhhdmUgYWNjZXNzIHRvIGFsbCBvZiB0aGUgYWJvdmVcbi8vIGZ1bmN0aW9ucyBhbmQgdmFyaWFibGVzLlxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChzb3VyY2UsIHJldml2ZXIpIHtcbiAgICB2YXIgcmVzdWx0O1xuICAgIFxuICAgIHRleHQgPSBzb3VyY2U7XG4gICAgYXQgPSAwO1xuICAgIGNoID0gJyAnO1xuICAgIHJlc3VsdCA9IHZhbHVlKCk7XG4gICAgd2hpdGUoKTtcbiAgICBpZiAoY2gpIHtcbiAgICAgICAgZXJyb3IoXCJTeW50YXggZXJyb3JcIik7XG4gICAgfVxuXG4gICAgLy8gSWYgdGhlcmUgaXMgYSByZXZpdmVyIGZ1bmN0aW9uLCB3ZSByZWN1cnNpdmVseSB3YWxrIHRoZSBuZXcgc3RydWN0dXJlLFxuICAgIC8vIHBhc3NpbmcgZWFjaCBuYW1lL3ZhbHVlIHBhaXIgdG8gdGhlIHJldml2ZXIgZnVuY3Rpb24gZm9yIHBvc3NpYmxlXG4gICAgLy8gdHJhbnNmb3JtYXRpb24sIHN0YXJ0aW5nIHdpdGggYSB0ZW1wb3Jhcnkgcm9vdCBvYmplY3QgdGhhdCBob2xkcyB0aGUgcmVzdWx0XG4gICAgLy8gaW4gYW4gZW1wdHkga2V5LiBJZiB0aGVyZSBpcyBub3QgYSByZXZpdmVyIGZ1bmN0aW9uLCB3ZSBzaW1wbHkgcmV0dXJuIHRoZVxuICAgIC8vIHJlc3VsdC5cblxuICAgIHJldHVybiB0eXBlb2YgcmV2aXZlciA9PT0gJ2Z1bmN0aW9uJyA/IChmdW5jdGlvbiB3YWxrKGhvbGRlciwga2V5KSB7XG4gICAgICAgIHZhciBrLCB2LCB2YWx1ZSA9IGhvbGRlcltrZXldO1xuICAgICAgICBpZiAodmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgZm9yIChrIGluIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgaykpIHtcbiAgICAgICAgICAgICAgICAgICAgdiA9IHdhbGsodmFsdWUsIGspO1xuICAgICAgICAgICAgICAgICAgICBpZiAodiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZVtrXSA9IHY7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgdmFsdWVba107XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJldml2ZXIuY2FsbChob2xkZXIsIGtleSwgdmFsdWUpO1xuICAgIH0oeycnOiByZXN1bHR9LCAnJykpIDogcmVzdWx0O1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9Vc2Vycy9nbmlkYW4vc3JjL3dvcmsvdHJ1ZmZsZS9ub2RlX21vZHVsZXMvanNvbmlmeS9saWIvcGFyc2UuanNcbi8vIG1vZHVsZSBpZCA9IDQ5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBjeCA9IC9bXFx1MDAwMFxcdTAwYWRcXHUwNjAwLVxcdTA2MDRcXHUwNzBmXFx1MTdiNFxcdTE3YjVcXHUyMDBjLVxcdTIwMGZcXHUyMDI4LVxcdTIwMmZcXHUyMDYwLVxcdTIwNmZcXHVmZWZmXFx1ZmZmMC1cXHVmZmZmXS9nLFxuICAgIGVzY2FwYWJsZSA9IC9bXFxcXFxcXCJcXHgwMC1cXHgxZlxceDdmLVxceDlmXFx1MDBhZFxcdTA2MDAtXFx1MDYwNFxcdTA3MGZcXHUxN2I0XFx1MTdiNVxcdTIwMGMtXFx1MjAwZlxcdTIwMjgtXFx1MjAyZlxcdTIwNjAtXFx1MjA2ZlxcdWZlZmZcXHVmZmYwLVxcdWZmZmZdL2csXG4gICAgZ2FwLFxuICAgIGluZGVudCxcbiAgICBtZXRhID0geyAgICAvLyB0YWJsZSBvZiBjaGFyYWN0ZXIgc3Vic3RpdHV0aW9uc1xuICAgICAgICAnXFxiJzogJ1xcXFxiJyxcbiAgICAgICAgJ1xcdCc6ICdcXFxcdCcsXG4gICAgICAgICdcXG4nOiAnXFxcXG4nLFxuICAgICAgICAnXFxmJzogJ1xcXFxmJyxcbiAgICAgICAgJ1xccic6ICdcXFxccicsXG4gICAgICAgICdcIicgOiAnXFxcXFwiJyxcbiAgICAgICAgJ1xcXFwnOiAnXFxcXFxcXFwnXG4gICAgfSxcbiAgICByZXA7XG5cbmZ1bmN0aW9uIHF1b3RlKHN0cmluZykge1xuICAgIC8vIElmIHRoZSBzdHJpbmcgY29udGFpbnMgbm8gY29udHJvbCBjaGFyYWN0ZXJzLCBubyBxdW90ZSBjaGFyYWN0ZXJzLCBhbmQgbm9cbiAgICAvLyBiYWNrc2xhc2ggY2hhcmFjdGVycywgdGhlbiB3ZSBjYW4gc2FmZWx5IHNsYXAgc29tZSBxdW90ZXMgYXJvdW5kIGl0LlxuICAgIC8vIE90aGVyd2lzZSB3ZSBtdXN0IGFsc28gcmVwbGFjZSB0aGUgb2ZmZW5kaW5nIGNoYXJhY3RlcnMgd2l0aCBzYWZlIGVzY2FwZVxuICAgIC8vIHNlcXVlbmNlcy5cbiAgICBcbiAgICBlc2NhcGFibGUubGFzdEluZGV4ID0gMDtcbiAgICByZXR1cm4gZXNjYXBhYmxlLnRlc3Qoc3RyaW5nKSA/ICdcIicgKyBzdHJpbmcucmVwbGFjZShlc2NhcGFibGUsIGZ1bmN0aW9uIChhKSB7XG4gICAgICAgIHZhciBjID0gbWV0YVthXTtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBjID09PSAnc3RyaW5nJyA/IGMgOlxuICAgICAgICAgICAgJ1xcXFx1JyArICgnMDAwMCcgKyBhLmNoYXJDb2RlQXQoMCkudG9TdHJpbmcoMTYpKS5zbGljZSgtNCk7XG4gICAgfSkgKyAnXCInIDogJ1wiJyArIHN0cmluZyArICdcIic7XG59XG5cbmZ1bmN0aW9uIHN0cihrZXksIGhvbGRlcikge1xuICAgIC8vIFByb2R1Y2UgYSBzdHJpbmcgZnJvbSBob2xkZXJba2V5XS5cbiAgICB2YXIgaSwgICAgICAgICAgLy8gVGhlIGxvb3AgY291bnRlci5cbiAgICAgICAgaywgICAgICAgICAgLy8gVGhlIG1lbWJlciBrZXkuXG4gICAgICAgIHYsICAgICAgICAgIC8vIFRoZSBtZW1iZXIgdmFsdWUuXG4gICAgICAgIGxlbmd0aCxcbiAgICAgICAgbWluZCA9IGdhcCxcbiAgICAgICAgcGFydGlhbCxcbiAgICAgICAgdmFsdWUgPSBob2xkZXJba2V5XTtcbiAgICBcbiAgICAvLyBJZiB0aGUgdmFsdWUgaGFzIGEgdG9KU09OIG1ldGhvZCwgY2FsbCBpdCB0byBvYnRhaW4gYSByZXBsYWNlbWVudCB2YWx1ZS5cbiAgICBpZiAodmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgICAgdHlwZW9mIHZhbHVlLnRvSlNPTiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB2YWx1ZSA9IHZhbHVlLnRvSlNPTihrZXkpO1xuICAgIH1cbiAgICBcbiAgICAvLyBJZiB3ZSB3ZXJlIGNhbGxlZCB3aXRoIGEgcmVwbGFjZXIgZnVuY3Rpb24sIHRoZW4gY2FsbCB0aGUgcmVwbGFjZXIgdG9cbiAgICAvLyBvYnRhaW4gYSByZXBsYWNlbWVudCB2YWx1ZS5cbiAgICBpZiAodHlwZW9mIHJlcCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB2YWx1ZSA9IHJlcC5jYWxsKGhvbGRlciwga2V5LCB2YWx1ZSk7XG4gICAgfVxuICAgIFxuICAgIC8vIFdoYXQgaGFwcGVucyBuZXh0IGRlcGVuZHMgb24gdGhlIHZhbHVlJ3MgdHlwZS5cbiAgICBzd2l0Y2ggKHR5cGVvZiB2YWx1ZSkge1xuICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgcmV0dXJuIHF1b3RlKHZhbHVlKTtcbiAgICAgICAgXG4gICAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgICAgICAvLyBKU09OIG51bWJlcnMgbXVzdCBiZSBmaW5pdGUuIEVuY29kZSBub24tZmluaXRlIG51bWJlcnMgYXMgbnVsbC5cbiAgICAgICAgICAgIHJldHVybiBpc0Zpbml0ZSh2YWx1ZSkgPyBTdHJpbmcodmFsdWUpIDogJ251bGwnO1xuICAgICAgICBcbiAgICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgIGNhc2UgJ251bGwnOlxuICAgICAgICAgICAgLy8gSWYgdGhlIHZhbHVlIGlzIGEgYm9vbGVhbiBvciBudWxsLCBjb252ZXJ0IGl0IHRvIGEgc3RyaW5nLiBOb3RlOlxuICAgICAgICAgICAgLy8gdHlwZW9mIG51bGwgZG9lcyBub3QgcHJvZHVjZSAnbnVsbCcuIFRoZSBjYXNlIGlzIGluY2x1ZGVkIGhlcmUgaW5cbiAgICAgICAgICAgIC8vIHRoZSByZW1vdGUgY2hhbmNlIHRoYXQgdGhpcyBnZXRzIGZpeGVkIHNvbWVkYXkuXG4gICAgICAgICAgICByZXR1cm4gU3RyaW5nKHZhbHVlKTtcbiAgICAgICAgICAgIFxuICAgICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICAgICAgaWYgKCF2YWx1ZSkgcmV0dXJuICdudWxsJztcbiAgICAgICAgICAgIGdhcCArPSBpbmRlbnQ7XG4gICAgICAgICAgICBwYXJ0aWFsID0gW107XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIEFycmF5LmlzQXJyYXlcbiAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmFwcGx5KHZhbHVlKSA9PT0gJ1tvYmplY3QgQXJyYXldJykge1xuICAgICAgICAgICAgICAgIGxlbmd0aCA9IHZhbHVlLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFydGlhbFtpXSA9IHN0cihpLCB2YWx1ZSkgfHwgJ251bGwnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAvLyBKb2luIGFsbCBvZiB0aGUgZWxlbWVudHMgdG9nZXRoZXIsIHNlcGFyYXRlZCB3aXRoIGNvbW1hcywgYW5kXG4gICAgICAgICAgICAgICAgLy8gd3JhcCB0aGVtIGluIGJyYWNrZXRzLlxuICAgICAgICAgICAgICAgIHYgPSBwYXJ0aWFsLmxlbmd0aCA9PT0gMCA/ICdbXScgOiBnYXAgP1xuICAgICAgICAgICAgICAgICAgICAnW1xcbicgKyBnYXAgKyBwYXJ0aWFsLmpvaW4oJyxcXG4nICsgZ2FwKSArICdcXG4nICsgbWluZCArICddJyA6XG4gICAgICAgICAgICAgICAgICAgICdbJyArIHBhcnRpYWwuam9pbignLCcpICsgJ10nO1xuICAgICAgICAgICAgICAgIGdhcCA9IG1pbmQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIElmIHRoZSByZXBsYWNlciBpcyBhbiBhcnJheSwgdXNlIGl0IHRvIHNlbGVjdCB0aGUgbWVtYmVycyB0byBiZVxuICAgICAgICAgICAgLy8gc3RyaW5naWZpZWQuXG4gICAgICAgICAgICBpZiAocmVwICYmIHR5cGVvZiByZXAgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgbGVuZ3RoID0gcmVwLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgayA9IHJlcFtpXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBrID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdiA9IHN0cihrLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnRpYWwucHVzaChxdW90ZShrKSArIChnYXAgPyAnOiAnIDogJzonKSArIHYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gT3RoZXJ3aXNlLCBpdGVyYXRlIHRocm91Z2ggYWxsIG9mIHRoZSBrZXlzIGluIHRoZSBvYmplY3QuXG4gICAgICAgICAgICAgICAgZm9yIChrIGluIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIGspKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2ID0gc3RyKGssIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFydGlhbC5wdXNoKHF1b3RlKGspICsgKGdhcCA/ICc6ICcgOiAnOicpICsgdik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgLy8gSm9pbiBhbGwgb2YgdGhlIG1lbWJlciB0ZXh0cyB0b2dldGhlciwgc2VwYXJhdGVkIHdpdGggY29tbWFzLFxuICAgICAgICAvLyBhbmQgd3JhcCB0aGVtIGluIGJyYWNlcy5cblxuICAgICAgICB2ID0gcGFydGlhbC5sZW5ndGggPT09IDAgPyAne30nIDogZ2FwID9cbiAgICAgICAgICAgICd7XFxuJyArIGdhcCArIHBhcnRpYWwuam9pbignLFxcbicgKyBnYXApICsgJ1xcbicgKyBtaW5kICsgJ30nIDpcbiAgICAgICAgICAgICd7JyArIHBhcnRpYWwuam9pbignLCcpICsgJ30nO1xuICAgICAgICBnYXAgPSBtaW5kO1xuICAgICAgICByZXR1cm4gdjtcbiAgICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHZhbHVlLCByZXBsYWNlciwgc3BhY2UpIHtcbiAgICB2YXIgaTtcbiAgICBnYXAgPSAnJztcbiAgICBpbmRlbnQgPSAnJztcbiAgICBcbiAgICAvLyBJZiB0aGUgc3BhY2UgcGFyYW1ldGVyIGlzIGEgbnVtYmVyLCBtYWtlIGFuIGluZGVudCBzdHJpbmcgY29udGFpbmluZyB0aGF0XG4gICAgLy8gbWFueSBzcGFjZXMuXG4gICAgaWYgKHR5cGVvZiBzcGFjZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHNwYWNlOyBpICs9IDEpIHtcbiAgICAgICAgICAgIGluZGVudCArPSAnICc7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gSWYgdGhlIHNwYWNlIHBhcmFtZXRlciBpcyBhIHN0cmluZywgaXQgd2lsbCBiZSB1c2VkIGFzIHRoZSBpbmRlbnQgc3RyaW5nLlxuICAgIGVsc2UgaWYgKHR5cGVvZiBzcGFjZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgaW5kZW50ID0gc3BhY2U7XG4gICAgfVxuXG4gICAgLy8gSWYgdGhlcmUgaXMgYSByZXBsYWNlciwgaXQgbXVzdCBiZSBhIGZ1bmN0aW9uIG9yIGFuIGFycmF5LlxuICAgIC8vIE90aGVyd2lzZSwgdGhyb3cgYW4gZXJyb3IuXG4gICAgcmVwID0gcmVwbGFjZXI7XG4gICAgaWYgKHJlcGxhY2VyICYmIHR5cGVvZiByZXBsYWNlciAhPT0gJ2Z1bmN0aW9uJ1xuICAgICYmICh0eXBlb2YgcmVwbGFjZXIgIT09ICdvYmplY3QnIHx8IHR5cGVvZiByZXBsYWNlci5sZW5ndGggIT09ICdudW1iZXInKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0pTT04uc3RyaW5naWZ5Jyk7XG4gICAgfVxuICAgIFxuICAgIC8vIE1ha2UgYSBmYWtlIHJvb3Qgb2JqZWN0IGNvbnRhaW5pbmcgb3VyIHZhbHVlIHVuZGVyIHRoZSBrZXkgb2YgJycuXG4gICAgLy8gUmV0dXJuIHRoZSByZXN1bHQgb2Ygc3RyaW5naWZ5aW5nIHRoZSB2YWx1ZS5cbiAgICByZXR1cm4gc3RyKCcnLCB7Jyc6IHZhbHVlfSk7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL1VzZXJzL2duaWRhbi9zcmMvd29yay90cnVmZmxlL25vZGVfbW9kdWxlcy9qc29uaWZ5L2xpYi9zdHJpbmdpZnkuanNcbi8vIG1vZHVsZSBpZCA9IDUwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcInRydWZmbGUtc29saWRpdHktdXRpbHNcIik7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZXh0ZXJuYWwgXCJ0cnVmZmxlLXNvbGlkaXR5LXV0aWxzXCJcbi8vIG1vZHVsZSBpZCA9IDUxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcInRydWZmbGUtY29kZS11dGlsc1wiKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBleHRlcm5hbCBcInRydWZmbGUtY29kZS11dGlsc1wiXG4vLyBtb2R1bGUgaWQgPSA1MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcclxuLy8gQW4gYXVnbWVudGVkIEFWTCBUcmVlIHdoZXJlIGVhY2ggbm9kZSBtYWludGFpbnMgYSBsaXN0IG9mIHJlY29yZHMgYW5kIHRoZWlyIHNlYXJjaCBpbnRlcnZhbHMuXHJcbi8vIFJlY29yZCBpcyBjb21wb3NlZCBvZiBhbiBpbnRlcnZhbCBhbmQgaXRzIHVuZGVybHlpbmcgZGF0YSwgc2VudCBieSBhIGNsaWVudC4gVGhpcyBhbGxvd3MgdGhlXHJcbi8vIGludGVydmFsIHRyZWUgdG8gaGF2ZSB0aGUgc2FtZSBpbnRlcnZhbCBpbnNlcnRlZCBtdWx0aXBsZSB0aW1lcywgYXMgbG9uZyBpdHMgZGF0YSBpcyBkaWZmZXJlbnQuXHJcbi8vIEJvdGggaW5zZXJ0aW9uIGFuZCBkZWxldGlvbiByZXF1aXJlIE8obG9nIG4pIHRpbWUuIFNlYXJjaGluZyByZXF1aXJlcyBPKGsqbG9nbikgdGltZSwgd2hlcmUgYGtgXHJcbi8vIGlzIHRoZSBudW1iZXIgb2YgaW50ZXJ2YWxzIGluIHRoZSBvdXRwdXQgbGlzdC5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgaXNTYW1lID0gcmVxdWlyZShcInNoYWxsb3dlcXVhbFwiKTtcclxuZnVuY3Rpb24gaGVpZ2h0KG5vZGUpIHtcclxuICAgIGlmIChub2RlID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICByZXR1cm4gLTE7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXR1cm4gbm9kZS5oZWlnaHQ7XHJcbiAgICB9XHJcbn1cclxudmFyIE5vZGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBOb2RlKGludGVydmFsVHJlZSwgcmVjb3JkKSB7XHJcbiAgICAgICAgdGhpcy5pbnRlcnZhbFRyZWUgPSBpbnRlcnZhbFRyZWU7XHJcbiAgICAgICAgdGhpcy5yZWNvcmRzID0gW107XHJcbiAgICAgICAgdGhpcy5oZWlnaHQgPSAwO1xyXG4gICAgICAgIHRoaXMua2V5ID0gcmVjb3JkLmxvdztcclxuICAgICAgICB0aGlzLm1heCA9IHJlY29yZC5oaWdoO1xyXG4gICAgICAgIC8vIFNhdmUgdGhlIGFycmF5IG9mIGFsbCByZWNvcmRzIHdpdGggdGhlIHNhbWUga2V5IGZvciB0aGlzIG5vZGVcclxuICAgICAgICB0aGlzLnJlY29yZHMucHVzaChyZWNvcmQpO1xyXG4gICAgfVxyXG4gICAgLy8gR2V0cyB0aGUgaGlnaGVzdCByZWNvcmQuaGlnaCB2YWx1ZSBmb3IgdGhpcyBub2RlXHJcbiAgICBOb2RlLnByb3RvdHlwZS5nZXROb2RlSGlnaCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgaGlnaCA9IHRoaXMucmVjb3Jkc1swXS5oaWdoO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgdGhpcy5yZWNvcmRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnJlY29yZHNbaV0uaGlnaCA+IGhpZ2gpIHtcclxuICAgICAgICAgICAgICAgIGhpZ2ggPSB0aGlzLnJlY29yZHNbaV0uaGlnaDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gaGlnaDtcclxuICAgIH07XHJcbiAgICAvLyBVcGRhdGVzIGhlaWdodCB2YWx1ZSBvZiB0aGUgbm9kZS4gQ2FsbGVkIGR1cmluZyBpbnNlcnRpb24sIHJlYmFsYW5jZSwgcmVtb3ZhbFxyXG4gICAgTm9kZS5wcm90b3R5cGUudXBkYXRlSGVpZ2h0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gTWF0aC5tYXgoaGVpZ2h0KHRoaXMubGVmdCksIGhlaWdodCh0aGlzLnJpZ2h0KSkgKyAxO1xyXG4gICAgfTtcclxuICAgIC8vIFVwZGF0ZXMgdGhlIG1heCB2YWx1ZSBvZiBhbGwgdGhlIHBhcmVudHMgYWZ0ZXIgaW5zZXJ0aW5nIGludG8gYWxyZWFkeSBleGlzdGluZyBub2RlLCBhcyB3ZWxsIGFzXHJcbiAgICAvLyByZW1vdmluZyB0aGUgbm9kZSBjb21wbGV0ZWx5IG9yIHJlbW92aW5nIHRoZSByZWNvcmQgb2YgYW4gYWxyZWFkeSBleGlzdGluZyBub2RlLiBTdGFydHMgd2l0aFxyXG4gICAgLy8gdGhlIHBhcmVudCBvZiBhbiBhZmZlY3RlZCBub2RlIGFuZCBidWJibGVzIHVwIHRvIHJvb3RcclxuICAgIE5vZGUucHJvdG90eXBlLnVwZGF0ZU1heE9mUGFyZW50cyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcyA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHRoaXNIaWdoID0gdGhpcy5nZXROb2RlSGlnaCgpO1xyXG4gICAgICAgIGlmICh0aGlzLmxlZnQgIT09IHVuZGVmaW5lZCAmJiB0aGlzLnJpZ2h0ICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5tYXggPSBNYXRoLm1heChNYXRoLm1heCh0aGlzLmxlZnQubWF4LCB0aGlzLnJpZ2h0Lm1heCksIHRoaXNIaWdoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodGhpcy5sZWZ0ICE9PSB1bmRlZmluZWQgJiYgdGhpcy5yaWdodCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMubWF4ID0gTWF0aC5tYXgodGhpcy5sZWZ0Lm1heCwgdGhpc0hpZ2gpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0aGlzLmxlZnQgPT09IHVuZGVmaW5lZCAmJiB0aGlzLnJpZ2h0ICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5tYXggPSBNYXRoLm1heCh0aGlzLnJpZ2h0Lm1heCwgdGhpc0hpZ2gpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5tYXggPSB0aGlzSGlnaDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMucGFyZW50KSB7XHJcbiAgICAgICAgICAgIHRoaXMucGFyZW50LnVwZGF0ZU1heE9mUGFyZW50cygpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvKlxyXG4gICAgTGVmdC1MZWZ0IGNhc2U6XHJcbiAgXHJcbiAgICAgICAgICAgeiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeVxyXG4gICAgICAgICAgLyBcXCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyAgIFxcXHJcbiAgICAgICAgIHkgICBUNCAgICAgIFJpZ2h0IFJvdGF0ZSAoeikgICAgICAgICAgeCAgICAgelxyXG4gICAgICAgIC8gXFwgICAgICAgICAgLSAtIC0gLSAtIC0gLSAtIC0+ICAgICAgIC8gXFwgICAvIFxcXHJcbiAgICAgICB4ICAgVDMgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFQxIFQyIFQzIFQ0XHJcbiAgICAgIC8gXFxcclxuICAgIFQxICAgVDJcclxuICBcclxuICAgIExlZnQtUmlnaHQgY2FzZTpcclxuICBcclxuICAgICAgICAgeiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB6ICAgICAgICAgICAgICAgICAgICAgICAgICAgeFxyXG4gICAgICAgIC8gXFwgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8gXFwgICAgICAgICAgICAgICAgICAgICAgICAvICAgXFxcclxuICAgICAgIHkgICBUNCAgTGVmdCBSb3RhdGUgKHkpICAgICAgICAgeCAgVDQgIFJpZ2h0IFJvdGF0ZSh6KSAgICAgeSAgICAgelxyXG4gICAgICAvIFxcICAgICAgLSAtIC0gLSAtIC0gLSAtIC0+ICAgICAvIFxcICAgICAgLSAtIC0gLSAtIC0gLSAtPiAgLyBcXCAgIC8gXFxcclxuICAgIFQxICAgeCAgICAgICAgICAgICAgICAgICAgICAgICAgIHkgIFQzICAgICAgICAgICAgICAgICAgICAgIFQxIFQyIFQzIFQ0XHJcbiAgICAgICAgLyBcXCAgICAgICAgICAgICAgICAgICAgICAgICAvIFxcXHJcbiAgICAgIFQyICAgVDMgICAgICAgICAgICAgICAgICAgICAgVDEgVDJcclxuICAgICovXHJcbiAgICAvLyBIYW5kbGVzIExlZnQtTGVmdCBjYXNlIGFuZCBMZWZ0LVJpZ2h0IGNhc2UgYWZ0ZXIgcmViYWxhbmNpbmcgQVZMIHRyZWVcclxuICAgIE5vZGUucHJvdG90eXBlLl91cGRhdGVNYXhBZnRlclJpZ2h0Um90YXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBwYXJlbnQgPSB0aGlzLnBhcmVudDtcclxuICAgICAgICB2YXIgbGVmdCA9IHBhcmVudC5sZWZ0O1xyXG4gICAgICAgIC8vIFVwZGF0ZSBtYXggb2YgbGVmdCBzaWJsaW5nICh4IGluIGZpcnN0IGNhc2UsIHkgaW4gc2Vjb25kKVxyXG4gICAgICAgIHZhciB0aGlzUGFyZW50TGVmdEhpZ2ggPSBsZWZ0LmdldE5vZGVIaWdoKCk7XHJcbiAgICAgICAgaWYgKGxlZnQubGVmdCA9PT0gdW5kZWZpbmVkICYmIGxlZnQucmlnaHQgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBsZWZ0Lm1heCA9IE1hdGgubWF4KHRoaXNQYXJlbnRMZWZ0SGlnaCwgbGVmdC5yaWdodC5tYXgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChsZWZ0LmxlZnQgIT09IHVuZGVmaW5lZCAmJiBsZWZ0LnJpZ2h0ID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgbGVmdC5tYXggPSBNYXRoLm1heCh0aGlzUGFyZW50TGVmdEhpZ2gsIGxlZnQubGVmdC5tYXgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChsZWZ0LmxlZnQgPT09IHVuZGVmaW5lZCAmJiBsZWZ0LnJpZ2h0ID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgbGVmdC5tYXggPSB0aGlzUGFyZW50TGVmdEhpZ2g7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBsZWZ0Lm1heCA9IE1hdGgubWF4KE1hdGgubWF4KGxlZnQubGVmdC5tYXgsIGxlZnQucmlnaHQubWF4KSwgdGhpc1BhcmVudExlZnRIaWdoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gVXBkYXRlIG1heCBvZiBpdHNlbGYgKHopXHJcbiAgICAgICAgdmFyIHRoaXNIaWdoID0gdGhpcy5nZXROb2RlSGlnaCgpO1xyXG4gICAgICAgIGlmICh0aGlzLmxlZnQgPT09IHVuZGVmaW5lZCAmJiB0aGlzLnJpZ2h0ICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5tYXggPSBNYXRoLm1heCh0aGlzSGlnaCwgdGhpcy5yaWdodC5tYXgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0aGlzLmxlZnQgIT09IHVuZGVmaW5lZCAmJiB0aGlzLnJpZ2h0ID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5tYXggPSBNYXRoLm1heCh0aGlzSGlnaCwgdGhpcy5sZWZ0Lm1heCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHRoaXMubGVmdCA9PT0gdW5kZWZpbmVkICYmIHRoaXMucmlnaHQgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICB0aGlzLm1heCA9IHRoaXNIaWdoO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5tYXggPSBNYXRoLm1heChNYXRoLm1heCh0aGlzLmxlZnQubWF4LCB0aGlzLnJpZ2h0Lm1heCksIHRoaXNIaWdoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gVXBkYXRlIG1heCBvZiBwYXJlbnQgKHkgaW4gZmlyc3QgY2FzZSwgeCBpbiBzZWNvbmQpXHJcbiAgICAgICAgcGFyZW50Lm1heCA9IE1hdGgubWF4KE1hdGgubWF4KHBhcmVudC5sZWZ0Lm1heCwgcGFyZW50LnJpZ2h0Lm1heCksIHBhcmVudC5nZXROb2RlSGlnaCgpKTtcclxuICAgIH07XHJcbiAgICAvKlxyXG4gICAgUmlnaHQtUmlnaHQgY2FzZTpcclxuICBcclxuICAgICAgeiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB5XHJcbiAgICAgLyBcXCAgICAgICAgICAgICAgICAgICAgICAgICAgICAvICAgXFxcclxuICAgIFQxICB5ICAgICBMZWZ0IFJvdGF0ZSh6KSAgICAgICB6ICAgICB4XHJcbiAgICAgICAvIFxcICAgLSAtIC0gLSAtIC0gLSAtPiAgICAgLyBcXCAgIC8gXFxcclxuICAgICAgVDIgIHggICAgICAgICAgICAgICAgICAgICAgVDEgVDIgVDMgVDRcclxuICAgICAgICAgLyBcXFxyXG4gICAgICAgIFQzIFQ0XHJcbiAgXHJcbiAgICBSaWdodC1MZWZ0IGNhc2U6XHJcbiAgXHJcbiAgICAgICB6ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHogICAgICAgICAgICAgICAgICAgICAgICAgICAgeFxyXG4gICAgICAvIFxcICAgICAgICAgICAgICAgICAgICAgICAgICAvIFxcICAgICAgICAgICAgICAgICAgICAgICAgIC8gICBcXFxyXG4gICAgIFQxICB5ICAgUmlnaHQgUm90YXRlICh5KSAgICAgVDEgIHggICAgICBMZWZ0IFJvdGF0ZSh6KSAgIHogICAgIHlcclxuICAgICAgICAvIFxcICAtIC0gLSAtIC0gLSAtIC0gLT4gICAgICAvIFxcICAgLSAtIC0gLSAtIC0gLSAtPiAgLyBcXCAgIC8gXFxcclxuICAgICAgIHggIFQ0ICAgICAgICAgICAgICAgICAgICAgICAgVDIgIHkgICAgICAgICAgICAgICAgICAgVDEgVDIgVDMgVDRcclxuICAgICAgLyBcXCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8gXFxcclxuICAgIFQyICAgVDMgICAgICAgICAgICAgICAgICAgICAgICAgICBUMyBUNFxyXG4gICAgKi9cclxuICAgIC8vIEhhbmRsZXMgUmlnaHQtUmlnaHQgY2FzZSBhbmQgUmlnaHQtTGVmdCBjYXNlIGluIHJlYmFsYW5jaW5nIEFWTCB0cmVlXHJcbiAgICBOb2RlLnByb3RvdHlwZS5fdXBkYXRlTWF4QWZ0ZXJMZWZ0Um90YXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBwYXJlbnQgPSB0aGlzLnBhcmVudDtcclxuICAgICAgICB2YXIgcmlnaHQgPSBwYXJlbnQucmlnaHQ7XHJcbiAgICAgICAgLy8gVXBkYXRlIG1heCBvZiByaWdodCBzaWJsaW5nICh4IGluIGZpcnN0IGNhc2UsIHkgaW4gc2Vjb25kKVxyXG4gICAgICAgIHZhciB0aGlzUGFyZW50UmlnaHRIaWdoID0gcmlnaHQuZ2V0Tm9kZUhpZ2goKTtcclxuICAgICAgICBpZiAocmlnaHQubGVmdCA9PT0gdW5kZWZpbmVkICYmIHJpZ2h0LnJpZ2h0ICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgcmlnaHQubWF4ID0gTWF0aC5tYXgodGhpc1BhcmVudFJpZ2h0SGlnaCwgcmlnaHQucmlnaHQubWF4KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAocmlnaHQubGVmdCAhPT0gdW5kZWZpbmVkICYmIHJpZ2h0LnJpZ2h0ID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgcmlnaHQubWF4ID0gTWF0aC5tYXgodGhpc1BhcmVudFJpZ2h0SGlnaCwgcmlnaHQubGVmdC5tYXgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChyaWdodC5sZWZ0ID09PSB1bmRlZmluZWQgJiYgcmlnaHQucmlnaHQgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICByaWdodC5tYXggPSB0aGlzUGFyZW50UmlnaHRIaWdoO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmlnaHQubWF4ID0gTWF0aC5tYXgoTWF0aC5tYXgocmlnaHQubGVmdC5tYXgsIHJpZ2h0LnJpZ2h0Lm1heCksIHRoaXNQYXJlbnRSaWdodEhpZ2gpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBVcGRhdGUgbWF4IG9mIGl0c2VsZiAoeilcclxuICAgICAgICB2YXIgdGhpc0hpZ2ggPSB0aGlzLmdldE5vZGVIaWdoKCk7XHJcbiAgICAgICAgaWYgKHRoaXMubGVmdCA9PT0gdW5kZWZpbmVkICYmIHRoaXMucmlnaHQgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICB0aGlzLm1heCA9IE1hdGgubWF4KHRoaXNIaWdoLCB0aGlzLnJpZ2h0Lm1heCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHRoaXMubGVmdCAhPT0gdW5kZWZpbmVkICYmIHRoaXMucmlnaHQgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICB0aGlzLm1heCA9IE1hdGgubWF4KHRoaXNIaWdoLCB0aGlzLmxlZnQubWF4KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodGhpcy5sZWZ0ID09PSB1bmRlZmluZWQgJiYgdGhpcy5yaWdodCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMubWF4ID0gdGhpc0hpZ2g7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLm1heCA9IE1hdGgubWF4KE1hdGgubWF4KHRoaXMubGVmdC5tYXgsIHRoaXMucmlnaHQubWF4KSwgdGhpc0hpZ2gpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBVcGRhdGUgbWF4IG9mIHBhcmVudCAoeSBpbiBmaXJzdCBjYXNlLCB4IGluIHNlY29uZClcclxuICAgICAgICBwYXJlbnQubWF4ID0gTWF0aC5tYXgoTWF0aC5tYXgocGFyZW50LmxlZnQubWF4LCByaWdodC5tYXgpLCBwYXJlbnQuZ2V0Tm9kZUhpZ2goKSk7XHJcbiAgICB9O1xyXG4gICAgTm9kZS5wcm90b3R5cGUuX2xlZnRSb3RhdGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHJpZ2h0Q2hpbGQgPSB0aGlzLnJpZ2h0O1xyXG4gICAgICAgIHJpZ2h0Q2hpbGQucGFyZW50ID0gdGhpcy5wYXJlbnQ7XHJcbiAgICAgICAgaWYgKHJpZ2h0Q2hpbGQucGFyZW50ID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5pbnRlcnZhbFRyZWUucm9vdCA9IHJpZ2h0Q2hpbGQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAocmlnaHRDaGlsZC5wYXJlbnQubGVmdCA9PT0gdGhpcykge1xyXG4gICAgICAgICAgICAgICAgcmlnaHRDaGlsZC5wYXJlbnQubGVmdCA9IHJpZ2h0Q2hpbGQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAocmlnaHRDaGlsZC5wYXJlbnQucmlnaHQgPT09IHRoaXMpIHtcclxuICAgICAgICAgICAgICAgIHJpZ2h0Q2hpbGQucGFyZW50LnJpZ2h0ID0gcmlnaHRDaGlsZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnJpZ2h0ID0gcmlnaHRDaGlsZC5sZWZ0O1xyXG4gICAgICAgIGlmICh0aGlzLnJpZ2h0ICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5yaWdodC5wYXJlbnQgPSB0aGlzO1xyXG4gICAgICAgIH1cclxuICAgICAgICByaWdodENoaWxkLmxlZnQgPSB0aGlzO1xyXG4gICAgICAgIHRoaXMucGFyZW50ID0gcmlnaHRDaGlsZDtcclxuICAgICAgICB0aGlzLnVwZGF0ZUhlaWdodCgpO1xyXG4gICAgICAgIHJpZ2h0Q2hpbGQudXBkYXRlSGVpZ2h0KCk7XHJcbiAgICB9O1xyXG4gICAgTm9kZS5wcm90b3R5cGUuX3JpZ2h0Um90YXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBsZWZ0Q2hpbGQgPSB0aGlzLmxlZnQ7XHJcbiAgICAgICAgbGVmdENoaWxkLnBhcmVudCA9IHRoaXMucGFyZW50O1xyXG4gICAgICAgIGlmIChsZWZ0Q2hpbGQucGFyZW50ID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5pbnRlcnZhbFRyZWUucm9vdCA9IGxlZnRDaGlsZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGlmIChsZWZ0Q2hpbGQucGFyZW50LmxlZnQgPT09IHRoaXMpIHtcclxuICAgICAgICAgICAgICAgIGxlZnRDaGlsZC5wYXJlbnQubGVmdCA9IGxlZnRDaGlsZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChsZWZ0Q2hpbGQucGFyZW50LnJpZ2h0ID09PSB0aGlzKSB7XHJcbiAgICAgICAgICAgICAgICBsZWZ0Q2hpbGQucGFyZW50LnJpZ2h0ID0gbGVmdENoaWxkO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMubGVmdCA9IGxlZnRDaGlsZC5yaWdodDtcclxuICAgICAgICBpZiAodGhpcy5sZWZ0ICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5sZWZ0LnBhcmVudCA9IHRoaXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxlZnRDaGlsZC5yaWdodCA9IHRoaXM7XHJcbiAgICAgICAgdGhpcy5wYXJlbnQgPSBsZWZ0Q2hpbGQ7XHJcbiAgICAgICAgdGhpcy51cGRhdGVIZWlnaHQoKTtcclxuICAgICAgICBsZWZ0Q2hpbGQudXBkYXRlSGVpZ2h0KCk7XHJcbiAgICB9O1xyXG4gICAgLy8gUmViYWxhbmNlcyB0aGUgdHJlZSBpZiB0aGUgaGVpZ2h0IHZhbHVlIGJldHdlZW4gdHdvIG5vZGVzIG9mIHRoZSBzYW1lIHBhcmVudCBpcyBncmVhdGVyIHRoYW5cclxuICAgIC8vIHR3by4gVGhlcmUgYXJlIDQgY2FzZXMgdGhhdCBjYW4gaGFwcGVuIHdoaWNoIGFyZSBvdXRsaW5lZCBpbiB0aGUgZ3JhcGhpY3MgYWJvdmVcclxuICAgIE5vZGUucHJvdG90eXBlLl9yZWJhbGFuY2UgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKGhlaWdodCh0aGlzLmxlZnQpID49IDIgKyBoZWlnaHQodGhpcy5yaWdodCkpIHtcclxuICAgICAgICAgICAgdmFyIGxlZnQgPSB0aGlzLmxlZnQ7XHJcbiAgICAgICAgICAgIGlmIChoZWlnaHQobGVmdC5sZWZ0KSA+PSBoZWlnaHQobGVmdC5yaWdodCkpIHtcclxuICAgICAgICAgICAgICAgIC8vIExlZnQtTGVmdCBjYXNlXHJcbiAgICAgICAgICAgICAgICB0aGlzLl9yaWdodFJvdGF0ZSgpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fdXBkYXRlTWF4QWZ0ZXJSaWdodFJvdGF0ZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gTGVmdC1SaWdodCBjYXNlXHJcbiAgICAgICAgICAgICAgICBsZWZ0Ll9sZWZ0Um90YXRlKCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9yaWdodFJvdGF0ZSgpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fdXBkYXRlTWF4QWZ0ZXJSaWdodFJvdGF0ZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGhlaWdodCh0aGlzLnJpZ2h0KSA+PSAyICsgaGVpZ2h0KHRoaXMubGVmdCkpIHtcclxuICAgICAgICAgICAgdmFyIHJpZ2h0ID0gdGhpcy5yaWdodDtcclxuICAgICAgICAgICAgaWYgKGhlaWdodChyaWdodC5yaWdodCkgPj0gaGVpZ2h0KHJpZ2h0LmxlZnQpKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBSaWdodC1SaWdodCBjYXNlXHJcbiAgICAgICAgICAgICAgICB0aGlzLl9sZWZ0Um90YXRlKCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl91cGRhdGVNYXhBZnRlckxlZnRSb3RhdGUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIFJpZ2h0LUxlZnQgY2FzZVxyXG4gICAgICAgICAgICAgICAgcmlnaHQuX3JpZ2h0Um90YXRlKCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9sZWZ0Um90YXRlKCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl91cGRhdGVNYXhBZnRlckxlZnRSb3RhdGUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBOb2RlLnByb3RvdHlwZS5pbnNlcnQgPSBmdW5jdGlvbiAocmVjb3JkKSB7XHJcbiAgICAgICAgaWYgKHJlY29yZC5sb3cgPCB0aGlzLmtleSkge1xyXG4gICAgICAgICAgICAvLyBJbnNlcnQgaW50byBsZWZ0IHN1YnRyZWVcclxuICAgICAgICAgICAgaWYgKHRoaXMubGVmdCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmxlZnQgPSBuZXcgTm9kZSh0aGlzLmludGVydmFsVHJlZSwgcmVjb3JkKTtcclxuICAgICAgICAgICAgICAgIHRoaXMubGVmdC5wYXJlbnQgPSB0aGlzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5sZWZ0Lmluc2VydChyZWNvcmQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBJbnNlcnQgaW50byByaWdodCBzdWJ0cmVlXHJcbiAgICAgICAgICAgIGlmICh0aGlzLnJpZ2h0ID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucmlnaHQgPSBuZXcgTm9kZSh0aGlzLmludGVydmFsVHJlZSwgcmVjb3JkKTtcclxuICAgICAgICAgICAgICAgIHRoaXMucmlnaHQucGFyZW50ID0gdGhpcztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucmlnaHQuaW5zZXJ0KHJlY29yZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gVXBkYXRlIHRoZSBtYXggdmFsdWUgb2YgdGhpcyBhbmNlc3RvciBpZiBuZWVkZWRcclxuICAgICAgICBpZiAodGhpcy5tYXggPCByZWNvcmQuaGlnaCkge1xyXG4gICAgICAgICAgICB0aGlzLm1heCA9IHJlY29yZC5oaWdoO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBVcGRhdGUgaGVpZ2h0IG9mIGVhY2ggbm9kZVxyXG4gICAgICAgIHRoaXMudXBkYXRlSGVpZ2h0KCk7XHJcbiAgICAgICAgLy8gUmViYWxhbmNlIHRoZSB0cmVlIHRvIGVuc3VyZSBhbGwgb3BlcmF0aW9ucyBhcmUgZXhlY3V0ZWQgaW4gTyhsb2duKSB0aW1lLiBUaGlzIGlzIGVzcGVjaWFsbHlcclxuICAgICAgICAvLyBpbXBvcnRhbnQgaW4gc2VhcmNoaW5nLCBhcyB0aGUgdHJlZSBoYXMgYSBoaWdoIGNoYW5jZSBvZiBkZWdlbmVyYXRpbmcgd2l0aG91dCB0aGUgcmViYWxhbmNpbmdcclxuICAgICAgICB0aGlzLl9yZWJhbGFuY2UoKTtcclxuICAgIH07XHJcbiAgICBOb2RlLnByb3RvdHlwZS5fZ2V0T3ZlcmxhcHBpbmdSZWNvcmRzID0gZnVuY3Rpb24gKGN1cnJlbnROb2RlLCBsb3csIGhpZ2gpIHtcclxuICAgICAgICBpZiAoY3VycmVudE5vZGUua2V5IDw9IGhpZ2ggJiYgbG93IDw9IGN1cnJlbnROb2RlLmdldE5vZGVIaWdoKCkpIHtcclxuICAgICAgICAgICAgLy8gTm9kZXMgYXJlIG92ZXJsYXBwaW5nLCBjaGVjayBpZiBpbmRpdmlkdWFsIHJlY29yZHMgaW4gdGhlIG5vZGUgYXJlIG92ZXJsYXBwaW5nXHJcbiAgICAgICAgICAgIHZhciB0ZW1wUmVzdWx0cyA9IFtdO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGN1cnJlbnROb2RlLnJlY29yZHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50Tm9kZS5yZWNvcmRzW2ldLmhpZ2ggPj0gbG93KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGVtcFJlc3VsdHMucHVzaChjdXJyZW50Tm9kZS5yZWNvcmRzW2ldKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdGVtcFJlc3VsdHM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBbXTtcclxuICAgIH07XHJcbiAgICBOb2RlLnByb3RvdHlwZS5zZWFyY2ggPSBmdW5jdGlvbiAobG93LCBoaWdoKSB7XHJcbiAgICAgICAgLy8gRG9uJ3Qgc2VhcmNoIG5vZGVzIHRoYXQgZG9uJ3QgZXhpc3RcclxuICAgICAgICBpZiAodGhpcyA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBbXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGxlZnRTZWFyY2ggPSBbXTtcclxuICAgICAgICB2YXIgb3duU2VhcmNoID0gW107XHJcbiAgICAgICAgdmFyIHJpZ2h0U2VhcmNoID0gW107XHJcbiAgICAgICAgLy8gSWYgaW50ZXJ2YWwgaXMgdG8gdGhlIHJpZ2h0IG9mIHRoZSByaWdodG1vc3QgcG9pbnQgb2YgYW55IGludGVydmFsIGluIHRoaXMgbm9kZSBhbmQgYWxsIGl0c1xyXG4gICAgICAgIC8vIGNoaWxkcmVuLCB0aGVyZSB3b24ndCBiZSBhbnkgbWF0Y2hlc1xyXG4gICAgICAgIGlmIChsb3cgPiB0aGlzLm1heCkge1xyXG4gICAgICAgICAgICByZXR1cm4gW107XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFNlYXJjaCBsZWZ0IGNoaWxkcmVuXHJcbiAgICAgICAgaWYgKHRoaXMubGVmdCAhPT0gdW5kZWZpbmVkICYmIHRoaXMubGVmdC5tYXggPj0gbG93KSB7XHJcbiAgICAgICAgICAgIGxlZnRTZWFyY2ggPSB0aGlzLmxlZnQuc2VhcmNoKGxvdywgaGlnaCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIENoZWNrIHRoaXMgbm9kZVxyXG4gICAgICAgIG93blNlYXJjaCA9IHRoaXMuX2dldE92ZXJsYXBwaW5nUmVjb3Jkcyh0aGlzLCBsb3csIGhpZ2gpO1xyXG4gICAgICAgIC8vIElmIGludGVydmFsIGlzIHRvIHRoZSBsZWZ0IG9mIHRoZSBzdGFydCBvZiB0aGlzIGludGVydmFsLCB0aGVuIGl0IGNhbid0IGJlIGluIGFueSBjaGlsZCB0b1xyXG4gICAgICAgIC8vIHRoZSByaWdodFxyXG4gICAgICAgIGlmIChoaWdoIDwgdGhpcy5rZXkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGxlZnRTZWFyY2guY29uY2F0KG93blNlYXJjaCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIE90aGVyd2lzZSwgc2VhcmNoIHJpZ2h0IGNoaWxkcmVuXHJcbiAgICAgICAgaWYgKHRoaXMucmlnaHQgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICByaWdodFNlYXJjaCA9IHRoaXMucmlnaHQuc2VhcmNoKGxvdywgaGlnaCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFJldHVybiBhY2N1bXVsYXRlZCByZXN1bHRzLCBpZiBhbnlcclxuICAgICAgICByZXR1cm4gbGVmdFNlYXJjaC5jb25jYXQob3duU2VhcmNoLCByaWdodFNlYXJjaCk7XHJcbiAgICB9O1xyXG4gICAgLy8gU2VhcmNoZXMgZm9yIGEgbm9kZSBieSBhIGBrZXlgIHZhbHVlXHJcbiAgICBOb2RlLnByb3RvdHlwZS5zZWFyY2hFeGlzdGluZyA9IGZ1bmN0aW9uIChsb3cpIHtcclxuICAgICAgICBpZiAodGhpcyA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLmtleSA9PT0gbG93KSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChsb3cgPCB0aGlzLmtleSkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5sZWZ0ICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmxlZnQuc2VhcmNoRXhpc3RpbmcobG93KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMucmlnaHQgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucmlnaHQuc2VhcmNoRXhpc3RpbmcobG93KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgfTtcclxuICAgIC8vIFJldHVybnMgdGhlIHNtYWxsZXN0IG5vZGUgb2YgdGhlIHN1YnRyZWVcclxuICAgIE5vZGUucHJvdG90eXBlLl9taW5WYWx1ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy5sZWZ0ID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sZWZ0Ll9taW5WYWx1ZSgpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBOb2RlLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAobm9kZSkge1xyXG4gICAgICAgIHZhciBwYXJlbnQgPSB0aGlzLnBhcmVudDtcclxuICAgICAgICBpZiAobm9kZS5rZXkgPCB0aGlzLmtleSkge1xyXG4gICAgICAgICAgICAvLyBOb2RlIHRvIGJlIHJlbW92ZWQgaXMgb24gdGhlIGxlZnQgc2lkZVxyXG4gICAgICAgICAgICBpZiAodGhpcy5sZWZ0ICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmxlZnQucmVtb3ZlKG5vZGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChub2RlLmtleSA+IHRoaXMua2V5KSB7XHJcbiAgICAgICAgICAgIC8vIE5vZGUgdG8gYmUgcmVtb3ZlZCBpcyBvbiB0aGUgcmlnaHQgc2lkZVxyXG4gICAgICAgICAgICBpZiAodGhpcy5yaWdodCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5yaWdodC5yZW1vdmUobm9kZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5sZWZ0ICE9PSB1bmRlZmluZWQgJiYgdGhpcy5yaWdodCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBOb2RlIGhhcyB0d28gY2hpbGRyZW5cclxuICAgICAgICAgICAgICAgIHZhciBtaW5WYWx1ZSA9IHRoaXMucmlnaHQuX21pblZhbHVlKCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmtleSA9IG1pblZhbHVlLmtleTtcclxuICAgICAgICAgICAgICAgIHRoaXMucmVjb3JkcyA9IG1pblZhbHVlLnJlY29yZHM7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5yaWdodC5yZW1vdmUodGhpcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAocGFyZW50LmxlZnQgPT09IHRoaXMpIHtcclxuICAgICAgICAgICAgICAgIC8vIE9uZSBjaGlsZCBvciBubyBjaGlsZCBjYXNlIG9uIGxlZnQgc2lkZVxyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucmlnaHQgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudC5sZWZ0ID0gdGhpcy5yaWdodDtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJpZ2h0LnBhcmVudCA9IHBhcmVudDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudC5sZWZ0ID0gdGhpcy5sZWZ0O1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmxlZnQgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxlZnQucGFyZW50ID0gcGFyZW50O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHBhcmVudC51cGRhdGVNYXhPZlBhcmVudHMoKTtcclxuICAgICAgICAgICAgICAgIHBhcmVudC51cGRhdGVIZWlnaHQoKTtcclxuICAgICAgICAgICAgICAgIHBhcmVudC5fcmViYWxhbmNlKCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChwYXJlbnQucmlnaHQgPT09IHRoaXMpIHtcclxuICAgICAgICAgICAgICAgIC8vIE9uZSBjaGlsZCBvciBubyBjaGlsZCBjYXNlIG9uIHJpZ2h0IHNpZGVcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnJpZ2h0ICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICBwYXJlbnQucmlnaHQgPSB0aGlzLnJpZ2h0O1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmlnaHQucGFyZW50ID0gcGFyZW50O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50LnJpZ2h0ID0gdGhpcy5sZWZ0O1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmxlZnQgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxlZnQucGFyZW50ID0gcGFyZW50O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHBhcmVudC51cGRhdGVNYXhPZlBhcmVudHMoKTtcclxuICAgICAgICAgICAgICAgIHBhcmVudC51cGRhdGVIZWlnaHQoKTtcclxuICAgICAgICAgICAgICAgIHBhcmVudC5fcmViYWxhbmNlKCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICByZXR1cm4gTm9kZTtcclxufSgpKTtcclxuZXhwb3J0cy5Ob2RlID0gTm9kZTtcclxudmFyIEludGVydmFsVHJlZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIEludGVydmFsVHJlZSgpIHtcclxuICAgICAgICB0aGlzLmNvdW50ID0gMDtcclxuICAgIH1cclxuICAgIEludGVydmFsVHJlZS5wcm90b3R5cGUuaW5zZXJ0ID0gZnVuY3Rpb24gKHJlY29yZCkge1xyXG4gICAgICAgIGlmIChyZWNvcmQubG93ID4gcmVjb3JkLmhpZ2gpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdgbG93YCB2YWx1ZSBtdXN0IGJlIGxvd2VyIG9yIGVxdWFsIHRvIGBoaWdoYCB2YWx1ZScpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5yb290ID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgLy8gQmFzZSBjYXNlOiBUcmVlIGlzIGVtcHR5LCBuZXcgbm9kZSBiZWNvbWVzIHJvb3RcclxuICAgICAgICAgICAgdGhpcy5yb290ID0gbmV3IE5vZGUodGhpcywgcmVjb3JkKTtcclxuICAgICAgICAgICAgdGhpcy5jb3VudCsrO1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIE90aGVyd2lzZSwgY2hlY2sgaWYgbm9kZSBhbHJlYWR5IGV4aXN0cyB3aXRoIHRoZSBzYW1lIGtleVxyXG4gICAgICAgICAgICB2YXIgbm9kZSA9IHRoaXMucm9vdC5zZWFyY2hFeGlzdGluZyhyZWNvcmQubG93KTtcclxuICAgICAgICAgICAgaWYgKG5vZGUgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgdGhlIHJlY29yZHMgaW4gdGhpcyBub2RlIGlmIHRoZXJlIGFscmVhZHkgaXMgdGhlIG9uZSB3aXRoIHNhbWUgbG93LCBoaWdoLCBkYXRhXHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGUucmVjb3Jkcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1NhbWUobm9kZS5yZWNvcmRzW2ldLCByZWNvcmQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgcmVjb3JkIGlzIHNhbWUgYXMgdGhlIG9uZSB3ZSdyZSB0cnlpbmcgdG8gaW5zZXJ0OyByZXR1cm4gZmFsc2UgdG8gaW5kaWNhdGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbm90aGluZyBoYXMgYmVlbiBpbnNlcnRlZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gQWRkIHRoZSByZWNvcmQgdG8gdGhlIG5vZGVcclxuICAgICAgICAgICAgICAgIG5vZGUucmVjb3Jkcy5wdXNoKHJlY29yZCk7XHJcbiAgICAgICAgICAgICAgICAvLyBVcGRhdGUgbWF4IG9mIHRoZSBub2RlIGFuZCBpdHMgcGFyZW50cyBpZiBuZWNlc3NhcnlcclxuICAgICAgICAgICAgICAgIGlmIChyZWNvcmQuaGlnaCA+IG5vZGUubWF4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5tYXggPSByZWNvcmQuaGlnaDtcclxuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS5wYXJlbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5wYXJlbnQudXBkYXRlTWF4T2ZQYXJlbnRzKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5jb3VudCsrO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBOb2RlIHdpdGggdGhpcyBrZXkgZG9lc24ndCBhbHJlYWR5IGV4aXN0LiBDYWxsIGluc2VydCBmdW5jdGlvbiBvbiByb290J3Mgbm9kZVxyXG4gICAgICAgICAgICAgICAgdGhpcy5yb290Lmluc2VydChyZWNvcmQpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jb3VudCsrO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgSW50ZXJ2YWxUcmVlLnByb3RvdHlwZS5zZWFyY2ggPSBmdW5jdGlvbiAobG93LCBoaWdoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMucm9vdCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIC8vIFRyZWUgaXMgZW1wdHk7IHJldHVybiBlbXB0eSBhcnJheVxyXG4gICAgICAgICAgICByZXR1cm4gW107XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yb290LnNlYXJjaChsb3csIGhpZ2gpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBJbnRlcnZhbFRyZWUucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIChyZWNvcmQpIHtcclxuICAgICAgICBpZiAodGhpcy5yb290ID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgLy8gVHJlZSBpcyBlbXB0eTsgbm90aGluZyB0byByZW1vdmVcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdmFyIG5vZGUgPSB0aGlzLnJvb3Quc2VhcmNoRXhpc3RpbmcocmVjb3JkLmxvdyk7XHJcbiAgICAgICAgICAgIGlmIChub2RlID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChub2RlLnJlY29yZHMubGVuZ3RoID4gMSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHJlbW92ZWRSZWNvcmQgPSB2b2lkIDA7XHJcbiAgICAgICAgICAgICAgICAvLyBOb2RlIHdpdGggdGhpcyBrZXkgaGFzIDIgb3IgbW9yZSByZWNvcmRzLiBGaW5kIHRoZSBvbmUgd2UgbmVlZCBhbmQgcmVtb3ZlIGl0XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGUucmVjb3Jkcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1NhbWUobm9kZS5yZWNvcmRzW2ldLCByZWNvcmQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZWRSZWNvcmQgPSBub2RlLnJlY29yZHNbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUucmVjb3Jkcy5zcGxpY2UoaSwgMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChyZW1vdmVkUmVjb3JkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlZFJlY29yZCA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgICAgICAgICAvLyBVcGRhdGUgbWF4IG9mIHRoYXQgbm9kZSBhbmQgaXRzIHBhcmVudHMgaWYgbmVjZXNzYXJ5XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlY29yZC5oaWdoID09PSBub2RlLm1heCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbm9kZUhpZ2ggPSBub2RlLmdldE5vZGVIaWdoKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChub2RlLmxlZnQgIT09IHVuZGVmaW5lZCAmJiBub2RlLnJpZ2h0ICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUubWF4ID0gTWF0aC5tYXgoTWF0aC5tYXgobm9kZS5sZWZ0Lm1heCwgbm9kZS5yaWdodC5tYXgpLCBub2RlSGlnaCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAobm9kZS5sZWZ0ICE9PSB1bmRlZmluZWQgJiYgbm9kZS5yaWdodCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlLm1heCA9IE1hdGgubWF4KG5vZGUubGVmdC5tYXgsIG5vZGVIaWdoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChub2RlLmxlZnQgPT09IHVuZGVmaW5lZCAmJiBub2RlLnJpZ2h0ICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUubWF4ID0gTWF0aC5tYXgobm9kZS5yaWdodC5tYXgsIG5vZGVIaWdoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUubWF4ID0gbm9kZUhpZ2g7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUucGFyZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlLnBhcmVudC51cGRhdGVNYXhPZlBhcmVudHMoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvdW50LS07XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAobm9kZS5yZWNvcmRzLmxlbmd0aCA9PT0gMSkge1xyXG4gICAgICAgICAgICAgICAgLy8gTm9kZSB3aXRoIHRoaXMga2V5IGhhcyBvbmx5IDEgcmVjb3JkLiBDaGVjayBpZiB0aGUgcmVtYWluaW5nIHJlY29yZCBpbiB0aGlzIG5vZGUgaXNcclxuICAgICAgICAgICAgICAgIC8vIGFjdHVhbGx5IHRoZSBvbmUgd2Ugd2FudCB0byByZW1vdmVcclxuICAgICAgICAgICAgICAgIGlmIChpc1NhbWUobm9kZS5yZWNvcmRzWzBdLCByZWNvcmQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlIHJlbWFpbmluZyByZWNvcmQgaXMgdGhlIG9uZSB3ZSB3YW50IHRvIHJlbW92ZS4gUmVtb3ZlIHRoZSB3aG9sZSBub2RlIGZyb20gdGhlIHRyZWVcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5yb290LmtleSA9PT0gbm9kZS5rZXkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2UncmUgcmVtb3ZpbmcgdGhlIHJvb3QgZWxlbWVudC4gQ3JlYXRlIGEgZHVtbXkgbm9kZSB0aGF0IHdpbGwgdGVtcG9yYXJpbHkgdGFrZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyByb290J3MgcGFyZW50IHJvbGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJvb3RQYXJlbnQgPSBuZXcgTm9kZSh0aGlzLCB7IGxvdzogcmVjb3JkLmxvdywgaGlnaDogcmVjb3JkLmxvdyB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcm9vdFBhcmVudC5sZWZ0ID0gdGhpcy5yb290O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJvb3QucGFyZW50ID0gcm9vdFBhcmVudDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlbW92ZWROb2RlID0gdGhpcy5yb290LnJlbW92ZShub2RlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yb290ID0gcm9vdFBhcmVudC5sZWZ0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5yb290ICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucm9vdC5wYXJlbnQgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlbW92ZWROb2RlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW1vdmVkTm9kZSA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY291bnQtLTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVtb3ZlZE5vZGUgPSB0aGlzLnJvb3QucmVtb3ZlKG5vZGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVtb3ZlZE5vZGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZWROb2RlID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb3VudC0tO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBUaGUgcmVtYWluaW5nIHJlY29yZCBpcyBub3QgdGhlIG9uZSB3ZSB3YW50IHRvIHJlbW92ZVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIE5vIHJlY29yZHMgYXQgYWxsIGluIHRoaXMgbm9kZT8hIFNob3VsZG4ndCBoYXBwZW5cclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBJbnRlcnZhbFRyZWUucHJvdG90eXBlLmluT3JkZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBJbk9yZGVyKHRoaXMucm9vdCk7XHJcbiAgICB9O1xyXG4gICAgSW50ZXJ2YWxUcmVlLnByb3RvdHlwZS5wcmVPcmRlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFByZU9yZGVyKHRoaXMucm9vdCk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIEludGVydmFsVHJlZTtcclxufSgpKTtcclxuZXhwb3J0cy5JbnRlcnZhbFRyZWUgPSBJbnRlcnZhbFRyZWU7XHJcbnZhciBEYXRhSW50ZXJ2YWxUcmVlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gRGF0YUludGVydmFsVHJlZSgpIHtcclxuICAgICAgICB0aGlzLnRyZWUgPSBuZXcgSW50ZXJ2YWxUcmVlKCk7XHJcbiAgICB9XHJcbiAgICBEYXRhSW50ZXJ2YWxUcmVlLnByb3RvdHlwZS5pbnNlcnQgPSBmdW5jdGlvbiAobG93LCBoaWdoLCBkYXRhKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudHJlZS5pbnNlcnQoeyBsb3c6IGxvdywgaGlnaDogaGlnaCwgZGF0YTogZGF0YSB9KTtcclxuICAgIH07XHJcbiAgICBEYXRhSW50ZXJ2YWxUcmVlLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAobG93LCBoaWdoLCBkYXRhKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudHJlZS5yZW1vdmUoeyBsb3c6IGxvdywgaGlnaDogaGlnaCwgZGF0YTogZGF0YSB9KTtcclxuICAgIH07XHJcbiAgICBEYXRhSW50ZXJ2YWxUcmVlLnByb3RvdHlwZS5zZWFyY2ggPSBmdW5jdGlvbiAobG93LCBoaWdoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudHJlZS5zZWFyY2gobG93LCBoaWdoKS5tYXAoZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHYuZGF0YTsgfSk7XHJcbiAgICB9O1xyXG4gICAgRGF0YUludGVydmFsVHJlZS5wcm90b3R5cGUuaW5PcmRlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy50cmVlLmluT3JkZXIoKTtcclxuICAgIH07XHJcbiAgICBEYXRhSW50ZXJ2YWxUcmVlLnByb3RvdHlwZS5wcmVPcmRlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy50cmVlLnByZU9yZGVyKCk7XHJcbiAgICB9O1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KERhdGFJbnRlcnZhbFRyZWUucHJvdG90eXBlLCBcImNvdW50XCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudHJlZS5jb3VudDtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIHJldHVybiBEYXRhSW50ZXJ2YWxUcmVlO1xyXG59KCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBEYXRhSW50ZXJ2YWxUcmVlO1xyXG52YXIgSW5PcmRlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIEluT3JkZXIoc3RhcnROb2RlKSB7XHJcbiAgICAgICAgdGhpcy5zdGFjayA9IFtdO1xyXG4gICAgICAgIGlmIChzdGFydE5vZGUgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICB0aGlzLnB1c2goc3RhcnROb2RlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBJbk9yZGVyLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIC8vIFdpbGwgb25seSBoYXBwZW4gaWYgc3RhY2sgaXMgZW1wdHkgYW5kIHBvcCBpcyBjYWxsZWRcclxuICAgICAgICBpZiAodGhpcy5jdXJyZW50Tm9kZSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICBkb25lOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgdmFsdWU6IHVuZGVmaW5lZCxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gUHJvY2VzcyB0aGlzIG5vZGVcclxuICAgICAgICBpZiAodGhpcy5pIDwgdGhpcy5jdXJyZW50Tm9kZS5yZWNvcmRzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgZG9uZTogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICB2YWx1ZTogdGhpcy5jdXJyZW50Tm9kZS5yZWNvcmRzW3RoaXMuaSsrXSxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudE5vZGUucmlnaHQgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICB0aGlzLnB1c2godGhpcy5jdXJyZW50Tm9kZS5yaWdodCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBNaWdodCBwb3AgdGhlIGxhc3QgYW5kIHNldCB0aGlzLmN1cnJlbnROb2RlID0gdW5kZWZpbmVkXHJcbiAgICAgICAgICAgIHRoaXMucG9wKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLm5leHQoKTtcclxuICAgIH07XHJcbiAgICBJbk9yZGVyLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKG5vZGUpIHtcclxuICAgICAgICB0aGlzLmN1cnJlbnROb2RlID0gbm9kZTtcclxuICAgICAgICB0aGlzLmkgPSAwO1xyXG4gICAgICAgIHdoaWxlICh0aGlzLmN1cnJlbnROb2RlLmxlZnQgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICB0aGlzLnN0YWNrLnB1c2godGhpcy5jdXJyZW50Tm9kZSk7XHJcbiAgICAgICAgICAgIHRoaXMuY3VycmVudE5vZGUgPSB0aGlzLmN1cnJlbnROb2RlLmxlZnQ7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIEluT3JkZXIucHJvdG90eXBlLnBvcCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLmN1cnJlbnROb2RlID0gdGhpcy5zdGFjay5wb3AoKTtcclxuICAgICAgICB0aGlzLmkgPSAwO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBJbk9yZGVyO1xyXG59KCkpO1xyXG5leHBvcnRzLkluT3JkZXIgPSBJbk9yZGVyO1xyXG5pZiAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgSW5PcmRlci5wcm90b3R5cGVbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH07XHJcbn1cclxudmFyIFByZU9yZGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gUHJlT3JkZXIoc3RhcnROb2RlKSB7XHJcbiAgICAgICAgdGhpcy5zdGFjayA9IFtdO1xyXG4gICAgICAgIHRoaXMuaSA9IDA7XHJcbiAgICAgICAgdGhpcy5jdXJyZW50Tm9kZSA9IHN0YXJ0Tm9kZTtcclxuICAgIH1cclxuICAgIFByZU9yZGVyLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIC8vIFdpbGwgb25seSBoYXBwZW4gaWYgc3RhY2sgaXMgZW1wdHkgYW5kIHBvcCBpcyBjYWxsZWQsXHJcbiAgICAgICAgLy8gd2hpY2ggb25seSBoYXBwZW5zIGlmIHRoZXJlIGlzIG5vIHJpZ2h0IG5vZGUgKGkuZSB3ZSBhcmUgZG9uZSlcclxuICAgICAgICBpZiAodGhpcy5jdXJyZW50Tm9kZSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICBkb25lOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgdmFsdWU6IHVuZGVmaW5lZCxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gUHJvY2VzcyB0aGlzIG5vZGVcclxuICAgICAgICBpZiAodGhpcy5pIDwgdGhpcy5jdXJyZW50Tm9kZS5yZWNvcmRzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgZG9uZTogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICB2YWx1ZTogdGhpcy5jdXJyZW50Tm9kZS5yZWNvcmRzW3RoaXMuaSsrXSxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudE5vZGUucmlnaHQgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICB0aGlzLnB1c2godGhpcy5jdXJyZW50Tm9kZS5yaWdodCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnROb2RlLmxlZnQgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICB0aGlzLnB1c2godGhpcy5jdXJyZW50Tm9kZS5sZWZ0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5wb3AoKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5uZXh0KCk7XHJcbiAgICB9O1xyXG4gICAgUHJlT3JkZXIucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAobm9kZSkge1xyXG4gICAgICAgIHRoaXMuc3RhY2sucHVzaChub2RlKTtcclxuICAgIH07XHJcbiAgICBQcmVPcmRlci5wcm90b3R5cGUucG9wID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuY3VycmVudE5vZGUgPSB0aGlzLnN0YWNrLnBvcCgpO1xyXG4gICAgICAgIHRoaXMuaSA9IDA7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIFByZU9yZGVyO1xyXG59KCkpO1xyXG5leHBvcnRzLlByZU9yZGVyID0gUHJlT3JkZXI7XHJcbmlmICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICBQcmVPcmRlci5wcm90b3R5cGVbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH07XHJcbn1cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL1VzZXJzL2duaWRhbi9zcmMvd29yay90cnVmZmxlL25vZGVfbW9kdWxlcy9ub2RlLWludGVydmFsLXRyZWUvbGliL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSA1M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHNoYWxsb3dFcXVhbChvYmpBLCBvYmpCLCBjb21wYXJlLCBjb21wYXJlQ29udGV4dCkge1xuICB2YXIgcmV0ID0gY29tcGFyZSA/IGNvbXBhcmUuY2FsbChjb21wYXJlQ29udGV4dCwgb2JqQSwgb2JqQikgOiB2b2lkIDA7XG5cbiAgaWYgKHJldCAhPT0gdm9pZCAwKSB7XG4gICAgcmV0dXJuICEhcmV0O1xuICB9XG5cbiAgaWYgKG9iakEgPT09IG9iakIpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmICh0eXBlb2Ygb2JqQSAhPT0gXCJvYmplY3RcIiB8fCAhb2JqQSB8fCB0eXBlb2Ygb2JqQiAhPT0gXCJvYmplY3RcIiB8fCAhb2JqQikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBrZXlzQSA9IE9iamVjdC5rZXlzKG9iakEpO1xuICB2YXIga2V5c0IgPSBPYmplY3Qua2V5cyhvYmpCKTtcblxuICBpZiAoa2V5c0EubGVuZ3RoICE9PSBrZXlzQi5sZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgYkhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5iaW5kKG9iakIpO1xuXG4gIC8vIFRlc3QgZm9yIEEncyBrZXlzIGRpZmZlcmVudCBmcm9tIEIuXG4gIGZvciAodmFyIGlkeCA9IDA7IGlkeCA8IGtleXNBLmxlbmd0aDsgaWR4KyspIHtcbiAgICB2YXIga2V5ID0ga2V5c0FbaWR4XTtcblxuICAgIGlmICghYkhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgdmFsdWVBID0gb2JqQVtrZXldO1xuICAgIHZhciB2YWx1ZUIgPSBvYmpCW2tleV07XG5cbiAgICByZXQgPSBjb21wYXJlID8gY29tcGFyZS5jYWxsKGNvbXBhcmVDb250ZXh0LCB2YWx1ZUEsIHZhbHVlQiwga2V5KSA6IHZvaWQgMDtcblxuICAgIGlmIChyZXQgPT09IGZhbHNlIHx8IChyZXQgPT09IHZvaWQgMCAmJiB2YWx1ZUEgIT09IHZhbHVlQikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvVXNlcnMvZ25pZGFuL3NyYy93b3JrL3RydWZmbGUvbm9kZV9tb2R1bGVzL3NoYWxsb3dlcXVhbC9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gNTRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiZXhwb3J0IGNvbnN0IElOSVRfV0VCMyA9IFwiSU5JVF9XRUIzXCI7XG5leHBvcnQgZnVuY3Rpb24gaW5pdChwcm92aWRlcikge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IElOSVRfV0VCMyxcbiAgICBwcm92aWRlclxuICB9O1xufVxuXG5leHBvcnQgY29uc3QgSU5TUEVDVCA9IFwiSU5TUEVDVF9UUkFOU0FDVElPTlwiO1xuZXhwb3J0IGZ1bmN0aW9uIGluc3BlY3QodHhIYXNoKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogSU5TUEVDVCxcbiAgICB0eEhhc2hcbiAgfTtcbn1cblxuZXhwb3J0IGNvbnN0IEZFVENIX0JJTkFSWSA9IFwiRkVUQ0hfQklOQVJZXCI7XG5leHBvcnQgZnVuY3Rpb24gZmV0Y2hCaW5hcnkoYWRkcmVzcywgYmxvY2spIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBGRVRDSF9CSU5BUlksXG4gICAgYWRkcmVzcyxcbiAgICBibG9jayAvL29wdGlvbmFsXG4gIH07XG59XG5cbmV4cG9ydCBjb25zdCBSRUNFSVZFX0JJTkFSWSA9IFwiUkVDRUlWRV9CSU5BUllcIjtcbmV4cG9ydCBmdW5jdGlvbiByZWNlaXZlQmluYXJ5KGFkZHJlc3MsIGJpbmFyeSkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFJFQ0VJVkVfQklOQVJZLFxuICAgIGFkZHJlc3MsXG4gICAgYmluYXJ5XG4gIH07XG59XG5cbmV4cG9ydCBjb25zdCBSRUNFSVZFX1RSQUNFID0gXCJSRUNFSVZFX1RSQUNFXCI7XG5leHBvcnQgZnVuY3Rpb24gcmVjZWl2ZVRyYWNlKHRyYWNlKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogUkVDRUlWRV9UUkFDRSxcbiAgICB0cmFjZVxuICB9O1xufVxuXG5leHBvcnQgY29uc3QgUkVDRUlWRV9DQUxMID0gXCJSRUNFSVZFX0NBTExcIjtcbmV4cG9ydCBmdW5jdGlvbiByZWNlaXZlQ2FsbCh7XG4gIGFkZHJlc3MsXG4gIGJpbmFyeSxcbiAgZGF0YSxcbiAgc3RvcmFnZUFkZHJlc3MsXG4gIHN0YXR1cyxcbiAgc2VuZGVyLFxuICB2YWx1ZSxcbiAgZ2FzcHJpY2UsXG4gIGJsb2NrXG59KSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogUkVDRUlWRV9DQUxMLFxuICAgIGFkZHJlc3MsXG4gICAgYmluYXJ5LFxuICAgIGRhdGEsXG4gICAgc3RvcmFnZUFkZHJlc3MsXG4gICAgc3RhdHVzLCAvL29ubHkgdXNlZCBmb3IgY3JlYXRpb24gY2FsbHMgYXQgcHJlc2VudCFcbiAgICBzZW5kZXIsXG4gICAgdmFsdWUsXG4gICAgZ2FzcHJpY2UsXG4gICAgYmxvY2tcbiAgfTtcbn1cblxuZXhwb3J0IGNvbnN0IEVSUk9SX1dFQjMgPSBcIkVSUk9SX1dFQjNcIjtcbmV4cG9ydCBmdW5jdGlvbiBlcnJvcihlcnJvcikge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IEVSUk9SX1dFQjMsXG4gICAgZXJyb3JcbiAgfTtcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBsaWIvd2ViMy9hY3Rpb25zL2luZGV4LmpzIiwiaW1wb3J0IGRlYnVnTW9kdWxlIGZyb20gXCJkZWJ1Z1wiO1xuY29uc3QgZGVidWcgPSBkZWJ1Z01vZHVsZShcImRlYnVnZ2VyOndlYjM6YWRhcHRlclwiKTtcblxuaW1wb3J0IFdlYjMgZnJvbSBcIndlYjNcIjtcbmltcG9ydCB7IHByb21pc2lmeSB9IGZyb20gXCJ1dGlsXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFdlYjNBZGFwdGVyIHtcbiAgY29uc3RydWN0b3IocHJvdmlkZXIpIHtcbiAgICB0aGlzLndlYjMgPSBuZXcgV2ViMyhwcm92aWRlcik7XG4gIH1cblxuICBhc3luYyBnZXRUcmFjZSh0eEhhc2gpIHtcbiAgICBsZXQgcmVzdWx0ID0gYXdhaXQgcHJvbWlzaWZ5KHRoaXMud2ViMy5jdXJyZW50UHJvdmlkZXIuc2VuZCkoXG4gICAgICAvL3NlbmQgKm9ubHkqIHVzZXMgY2FsbGJhY2tzLCBzbyB3ZSB1c2UgcHJvbXNpZml5IHRvIG1ha2UgdGhpbmdzIG1vcmVcbiAgICAgIC8vcmVhZGFibGVcbiAgICAgIHtcbiAgICAgICAganNvbnJwYzogXCIyLjBcIixcbiAgICAgICAgbWV0aG9kOiBcImRlYnVnX3RyYWNlVHJhbnNhY3Rpb25cIixcbiAgICAgICAgcGFyYW1zOiBbdHhIYXNoLCB7fV0sXG4gICAgICAgIGlkOiBuZXcgRGF0ZSgpLmdldFRpbWUoKVxuICAgICAgfVxuICAgICk7XG4gICAgaWYgKHJlc3VsdC5lcnJvcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKHJlc3VsdC5lcnJvci5tZXNzYWdlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHJlc3VsdC5yZXN1bHQuc3RydWN0TG9ncztcbiAgICB9XG4gIH1cblxuICBhc3luYyBnZXRUcmFuc2FjdGlvbih0eEhhc2gpIHtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy53ZWIzLmV0aC5nZXRUcmFuc2FjdGlvbih0eEhhc2gpO1xuICB9XG5cbiAgYXN5bmMgZ2V0UmVjZWlwdCh0eEhhc2gpIHtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy53ZWIzLmV0aC5nZXRUcmFuc2FjdGlvblJlY2VpcHQodHhIYXNoKTtcbiAgfVxuXG4gIGFzeW5jIGdldEJsb2NrKGJsb2NrTnVtYmVyT3JIYXNoKSB7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMud2ViMy5ldGguZ2V0QmxvY2soYmxvY2tOdW1iZXJPckhhc2gpO1xuICB9XG5cbiAgLyoqXG4gICAqIGdldERlcGxveWVkQ29kZSAtIGdldCB0aGUgZGVwbG95ZWQgY29kZSBmb3IgYW4gYWRkcmVzcyBmcm9tIHRoZSBjbGllbnRcbiAgICogTk9URTogdGhlIGJsb2NrIGFyZ3VtZW50IGlzIG9wdGlvbmFsXG4gICAqIEBwYXJhbSAge1N0cmluZ30gYWRkcmVzc1xuICAgKiBAcmV0dXJuIHtTdHJpbmd9ICAgICAgICAgZGVwbG95ZWRCaW5hcnlcbiAgICovXG4gIGFzeW5jIGdldERlcGxveWVkQ29kZShhZGRyZXNzLCBibG9jaykge1xuICAgIGRlYnVnKFwiZ2V0dGluZyBkZXBsb3llZCBjb2RlIGZvciAlc1wiLCBhZGRyZXNzKTtcbiAgICBsZXQgY29kZSA9IGF3YWl0IHRoaXMud2ViMy5ldGguZ2V0Q29kZShhZGRyZXNzLCBibG9jayk7XG4gICAgcmV0dXJuIGNvZGUgPT09IFwiMHgwXCIgPyBcIjB4XCIgOiBjb2RlO1xuICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gbGliL3dlYjMvYWRhcHRlci5qcyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcInV0aWxcIik7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZXh0ZXJuYWwgXCJ1dGlsXCJcbi8vIG1vZHVsZSBpZCA9IDU3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcImxvZGFzaC5zdW1cIik7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZXh0ZXJuYWwgXCJsb2Rhc2guc3VtXCJcbi8vIG1vZHVsZSBpZCA9IDU4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCBkZWJ1Z01vZHVsZSBmcm9tIFwiZGVidWdcIjtcbmNvbnN0IGRlYnVnID0gZGVidWdNb2R1bGUoXCJkZWJ1Z2dlcjpzZXNzaW9uOnNhZ2FzXCIpO1xuXG5pbXBvcnQgeyBjYWxsLCBhbGwsIGZvcmssIHRha2UsIHB1dCwgcmFjZSB9IGZyb20gXCJyZWR1eC1zYWdhL2VmZmVjdHNcIjtcblxuaW1wb3J0IHsgcHJlZml4TmFtZSB9IGZyb20gXCJsaWIvaGVscGVyc1wiO1xuXG5pbXBvcnQgKiBhcyBhc3QgZnJvbSBcImxpYi9hc3Qvc2FnYXNcIjtcbmltcG9ydCAqIGFzIGNvbnRyb2xsZXIgZnJvbSBcImxpYi9jb250cm9sbGVyL3NhZ2FzXCI7XG5pbXBvcnQgKiBhcyBzb2xpZGl0eSBmcm9tIFwibGliL3NvbGlkaXR5L3NhZ2FzXCI7XG5pbXBvcnQgKiBhcyBldm0gZnJvbSBcImxpYi9ldm0vc2FnYXNcIjtcbmltcG9ydCAqIGFzIHRyYWNlIGZyb20gXCJsaWIvdHJhY2Uvc2FnYXNcIjtcbmltcG9ydCAqIGFzIGRhdGEgZnJvbSBcImxpYi9kYXRhL3NhZ2FzXCI7XG5pbXBvcnQgKiBhcyB3ZWIzIGZyb20gXCJsaWIvd2ViMy9zYWdhc1wiO1xuXG5pbXBvcnQgKiBhcyBhY3Rpb25zIGZyb20gXCIuLi9hY3Rpb25zXCI7XG5cbmNvbnN0IExPQURfU0FHQVMgPSB7XG4gIFthY3Rpb25zLkxPQURfVFJBTlNBQ1RJT05dOiBsb2FkXG4gIC8vd2lsbCBhbHNvIGFkZCByZWNvbnN0cnVjdCBhY3Rpb24vc2FnYSBvbmNlIGl0IGV4aXN0c1xufTtcblxuZnVuY3Rpb24qIGxpc3RlbmVyU2FnYSgpIHtcbiAgd2hpbGUgKHRydWUpIHtcbiAgICBsZXQgYWN0aW9uID0geWllbGQgdGFrZShPYmplY3Qua2V5cyhMT0FEX1NBR0FTKSk7XG4gICAgbGV0IHNhZ2EgPSBMT0FEX1NBR0FTW2FjdGlvbi50eXBlXTtcblxuICAgIHlpZWxkIHB1dChhY3Rpb25zLndhaXQoKSk7XG4gICAgeWllbGQgcmFjZSh7XG4gICAgICBleGVjOiBjYWxsKHNhZ2EsIGFjdGlvbiksIC8vbm90IGFsbCB3aWxsIHVzZSB0aGlzXG4gICAgICBpbnRlcnJ1cHQ6IHRha2UoYWN0aW9ucy5JTlRFUlJVUFQpXG4gICAgfSk7XG4gICAgeWllbGQgcHV0KGFjdGlvbnMucmVhZHkoKSk7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uKiBzYWdhKCkge1xuICBkZWJ1ZyhcInN0YXJ0aW5nIGxpc3RlbmVyc1wiKTtcbiAgeWllbGQqIGZvcmtMaXN0ZW5lcnMoKTtcblxuICAvLyByZWNlaXZpbmcgJiBzYXZpbmcgY29udHJhY3RzIGludG8gc3RhdGVcbiAgZGVidWcoXCJ3YWl0aW5nIGZvciBjb250cmFjdCBpbmZvcm1hdGlvblwiKTtcbiAgbGV0IHsgY29udGV4dHMsIHNvdXJjZXMgfSA9IHlpZWxkIHRha2UoYWN0aW9ucy5SRUNPUkRfQ09OVFJBQ1RTKTtcblxuICBkZWJ1ZyhcInJlY29yZGluZyBjb250cmFjdCBiaW5hcmllc1wiKTtcbiAgeWllbGQqIHJlY29yZENvbnRleHRzKC4uLmNvbnRleHRzKTtcblxuICBkZWJ1ZyhcInJlY29yZGluZyBjb250cmFjdCBzb3VyY2VzXCIpO1xuICB5aWVsZCogcmVjb3JkU291cmNlcyguLi5zb3VyY2VzKTtcblxuICBkZWJ1ZyhcIm5vcm1hbGl6aW5nIGNvbnRleHRzXCIpO1xuICB5aWVsZCogZXZtLm5vcm1hbGl6ZUNvbnRleHRzKCk7XG5cbiAgZGVidWcoXCJ3YWl0aW5nIGZvciBzdGFydFwiKTtcbiAgLy8gd2FpdCBmb3Igc3RhcnQgc2lnbmFsXG4gIGxldCB7IHR4SGFzaCwgcHJvdmlkZXIgfSA9IHlpZWxkIHRha2UoYWN0aW9ucy5TVEFSVCk7XG4gIGRlYnVnKFwic3RhcnRpbmdcIik7XG5cbiAgZGVidWcoXCJ2aXNpdGluZyBBU1RzXCIpO1xuICAvLyB2aXNpdCBhc3RzXG4gIHlpZWxkKiBhc3QudmlzaXRBbGwoKTtcblxuICAvL3NhdmUgYWxsb2NhdGlvbiB0YWJsZVxuICBkZWJ1ZyhcInNhdmluZyBhbGxvY2F0aW9uIHRhYmxlXCIpO1xuICB5aWVsZCogZGF0YS5yZWNvcmRBbGxvY2F0aW9ucygpO1xuXG4gIC8vaW5pdGlhbGl6ZSB3ZWIzIGFkYXB0ZXJcbiAgeWllbGQqIHdlYjMuaW5pdChwcm92aWRlcik7XG5cbiAgLy9wcm9jZXNzIHRyYW5zYWN0aW9uIChpZiB0aGVyZSBpcyBvbmUpXG4gIC8vKG5vdGU6IHRoaXMgcGFydCBtYXkgYWxzbyBzZXQgdGhlIGVycm9yIHN0YXRlKVxuICBpZiAodHhIYXNoICE9PSB1bmRlZmluZWQpIHtcbiAgICB5aWVsZCogcHJvY2Vzc1RyYW5zYWN0aW9uKHR4SGFzaCk7XG4gIH1cblxuICBkZWJ1ZyhcInJlYWR5aW5nXCIpO1xuICAvLyBzaWduYWwgdGhhdCBjb21tYW5kcyBjYW4gYmVnaW5cbiAgeWllbGQqIHJlYWR5KCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiogcHJvY2Vzc1RyYW5zYWN0aW9uKHR4SGFzaCkge1xuICAvLyBwcm9jZXNzIHRyYW5zYWN0aW9uXG4gIGRlYnVnKFwiZmV0Y2hpbmcgdHJhbnNhY3Rpb24gaW5mb1wiKTtcbiAgbGV0IGVyciA9IHlpZWxkKiBmZXRjaFR4KHR4SGFzaCk7XG4gIGlmIChlcnIpIHtcbiAgICBkZWJ1ZyhcImVycm9yICVvXCIsIGVycik7XG4gICAgeWllbGQqIGVycm9yKGVycik7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgcHJlZml4TmFtZShcInNlc3Npb25cIiwgc2FnYSk7XG5cbmZ1bmN0aW9uKiBmb3JrTGlzdGVuZXJzKCkge1xuICB5aWVsZCBmb3JrKGxpc3RlbmVyU2FnYSk7IC8vc2Vzc2lvbiBsaXN0ZW5lcjsgdGhpcyBvbmUgaXMgc2VwYXJhdGUsIHNvcnJ5XG4gIC8vKEkgZGlkbid0IHdhbnQgdG8gbWVzcyB3LyB0aGUgZXhpc3Rpbmcgc3RydWN0dXJlIG9mIGRlZmF1bHRzKVxuICByZXR1cm4geWllbGQgYWxsKFxuICAgIFtjb250cm9sbGVyLCBkYXRhLCBldm0sIHNvbGlkaXR5LCB0cmFjZSwgd2ViM10ubWFwKFxuICAgICAgYXBwID0+IGZvcmsoYXBwLnNhZ2EpXG4gICAgICAvL2FzdCBubyBsb25nZXIgaGFzIGEgbGlzdGVuZXJcbiAgICApXG4gICk7XG59XG5cbmZ1bmN0aW9uKiBmZXRjaFR4KHR4SGFzaCkge1xuICBsZXQgcmVzdWx0ID0geWllbGQqIHdlYjMuaW5zcGVjdFRyYW5zYWN0aW9uKHR4SGFzaCk7XG4gIGRlYnVnKFwicmVzdWx0ICVvXCIsIHJlc3VsdCk7XG5cbiAgaWYgKHJlc3VsdC5lcnJvcikge1xuICAgIHJldHVybiByZXN1bHQuZXJyb3I7XG4gIH1cblxuICAvL2dldCBhZGRyZXNzZXMgY3JlYXRlZC9jYWxsZWQgZHVyaW5nIHRyYW5zYWN0aW9uXG4gIGRlYnVnKFwicHJvY2Vzc2luZyB0cmFjZSBmb3IgYWRkcmVzc2VzXCIpO1xuICBsZXQgYWRkcmVzc2VzID0geWllbGQqIHRyYWNlLnByb2Nlc3NUcmFjZShyZXN1bHQudHJhY2UpO1xuICAvL2FkZCBpbiB0aGUgYWRkcmVzcyBvZiB0aGUgY2FsbCBpdHNlbGYgKGlmIGEgY2FsbClcbiAgaWYgKHJlc3VsdC5hZGRyZXNzICYmICFhZGRyZXNzZXMuaW5jbHVkZXMocmVzdWx0LmFkZHJlc3MpKSB7XG4gICAgYWRkcmVzc2VzLnB1c2gocmVzdWx0LmFkZHJlc3MpO1xuICB9XG4gIC8vaWYgYSBjcmVhdGUsIG9ubHkgYWRkIGluIGFkZHJlc3MgaWYgaXQgd2FzIHN1Y2Nlc3NmdWxcbiAgaWYgKFxuICAgIHJlc3VsdC5iaW5hcnkgJiZcbiAgICByZXN1bHQuc3RhdHVzICYmXG4gICAgIWFkZHJlc3Nlcy5pbmNsdWRlcyhyZXN1bHQuc3RvcmFnZUFkZHJlc3MpXG4gICkge1xuICAgIGFkZHJlc3Nlcy5wdXNoKHJlc3VsdC5zdG9yYWdlQWRkcmVzcyk7XG4gIH1cblxuICBsZXQgYmxvY2tOdW1iZXIgPSByZXN1bHQuYmxvY2subnVtYmVyLnRvU3RyaW5nKCk7IC8vYSBCTiBpcyBub3QgYWNjZXB0ZWRcbiAgZGVidWcoXCJvYnRhaW5pbmcgYmluYXJpZXNcIik7XG4gIGxldCBiaW5hcmllcyA9IHlpZWxkKiB3ZWIzLm9idGFpbkJpbmFyaWVzKGFkZHJlc3NlcywgYmxvY2tOdW1iZXIpO1xuXG4gIGRlYnVnKFwicmVjb3JkaW5nIGluc3RhbmNlc1wiKTtcbiAgeWllbGQgYWxsKFxuICAgIGFkZHJlc3Nlcy5tYXAoKGFkZHJlc3MsIGkpID0+IGNhbGwocmVjb3JkSW5zdGFuY2UsIGFkZHJlc3MsIGJpbmFyaWVzW2ldKSlcbiAgKTtcblxuICBkZWJ1ZyhcInNlbmRpbmcgaW5pdGlhbCBjYWxsXCIpO1xuICB5aWVsZCogZXZtLmJlZ2luKHJlc3VsdCk7XG59XG5cbmZ1bmN0aW9uKiByZWNvcmRDb250ZXh0cyguLi5jb250ZXh0cykge1xuICBmb3IgKGxldCBjb250ZXh0IG9mIGNvbnRleHRzKSB7XG4gICAgeWllbGQqIGV2bS5hZGRDb250ZXh0KGNvbnRleHQpO1xuICB9XG59XG5cbmZ1bmN0aW9uKiByZWNvcmRTb3VyY2VzKC4uLnNvdXJjZXMpIHtcbiAgZm9yIChsZXQgc291cmNlRGF0YSBvZiBzb3VyY2VzKSB7XG4gICAgaWYgKHNvdXJjZURhdGEgIT09IHVuZGVmaW5lZCAmJiBzb3VyY2VEYXRhICE9PSBudWxsKSB7XG4gICAgICB5aWVsZCogc29saWRpdHkuYWRkU291cmNlKFxuICAgICAgICBzb3VyY2VEYXRhLnNvdXJjZSxcbiAgICAgICAgc291cmNlRGF0YS5zb3VyY2VQYXRoLFxuICAgICAgICBzb3VyY2VEYXRhLmFzdCxcbiAgICAgICAgc291cmNlRGF0YS5jb21waWxlclxuICAgICAgKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24qIHJlY29yZEluc3RhbmNlKGFkZHJlc3MsIGJpbmFyeSkge1xuICB5aWVsZCogZXZtLmFkZEluc3RhbmNlKGFkZHJlc3MsIGJpbmFyeSk7XG59XG5cbmZ1bmN0aW9uKiByZWFkeSgpIHtcbiAgeWllbGQgcHV0KGFjdGlvbnMucmVhZHkoKSk7XG59XG5cbmZ1bmN0aW9uKiBlcnJvcihlcnIpIHtcbiAgeWllbGQgcHV0KGFjdGlvbnMuZXJyb3IoZXJyKSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiogdW5sb2FkKCkge1xuICBkZWJ1ZyhcInVubG9hZGluZ1wiKTtcbiAgeWllbGQqIGRhdGEucmVzZXQoKTtcbiAgeWllbGQqIHNvbGlkaXR5LnJlc2V0KCk7XG4gIHlpZWxkKiBldm0udW5sb2FkKCk7XG4gIHlpZWxkKiB0cmFjZS51bmxvYWQoKTtcbiAgeWllbGQgcHV0KGFjdGlvbnMudW5sb2FkVHJhbnNhY3Rpb24oKSk7XG59XG5cbi8vbm90ZSB0aGF0IGxvYWQgdGFrZXMgYW4gYWN0aW9uIGFzIGl0cyBhcmd1bWVudCwgd2hpY2ggaXMgd2h5IGl0J3Mgc2VwYXJhdGVcbi8vZnJvbSBwcm9jZXNzVHJhbnNhY3Rpb25cbmZ1bmN0aW9uKiBsb2FkKHsgdHhIYXNoIH0pIHtcbiAgeWllbGQqIHByb2Nlc3NUcmFuc2FjdGlvbih0eEhhc2gpO1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIGxpYi9zZXNzaW9uL3NhZ2FzL2luZGV4LmpzIiwiaW1wb3J0IGRlYnVnTW9kdWxlIGZyb20gXCJkZWJ1Z1wiO1xuY29uc3QgZGVidWcgPSBkZWJ1Z01vZHVsZShcImRlYnVnZ2VyOmFzdDpzYWdhc1wiKTtcblxuaW1wb3J0IHsgYWxsLCBjYWxsLCBzZWxlY3QgfSBmcm9tIFwicmVkdXgtc2FnYS9lZmZlY3RzXCI7XG5cbmltcG9ydCAqIGFzIGRhdGEgZnJvbSBcImxpYi9kYXRhL3NhZ2FzXCI7XG5cbmltcG9ydCBhc3QgZnJvbSBcIi4uL3NlbGVjdG9yc1wiO1xuXG5mdW5jdGlvbiogd2Fsayhzb3VyY2VJZCwgbm9kZSwgcG9pbnRlciA9IFwiXCIsIHBhcmVudElkID0gbnVsbCkge1xuICBkZWJ1ZyhcIndhbGtpbmcgJW8gJW9cIiwgcG9pbnRlciwgbm9kZSk7XG5cbiAgeWllbGQqIGhhbmRsZUVudGVyKHNvdXJjZUlkLCBub2RlLCBwb2ludGVyLCBwYXJlbnRJZCk7XG5cbiAgaWYgKG5vZGUgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgIGZvciAobGV0IFtpLCBjaGlsZF0gb2Ygbm9kZS5lbnRyaWVzKCkpIHtcbiAgICAgIHlpZWxkIGNhbGwod2Fsaywgc291cmNlSWQsIGNoaWxkLCBgJHtwb2ludGVyfS8ke2l9YCwgcGFyZW50SWQpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChub2RlIGluc3RhbmNlb2YgT2JqZWN0KSB7XG4gICAgZm9yIChsZXQgW2tleSwgY2hpbGRdIG9mIE9iamVjdC5lbnRyaWVzKG5vZGUpKSB7XG4gICAgICB5aWVsZCBjYWxsKHdhbGssIHNvdXJjZUlkLCBjaGlsZCwgYCR7cG9pbnRlcn0vJHtrZXl9YCwgbm9kZS5pZCk7XG4gICAgfVxuICB9XG5cbiAgeWllbGQqIGhhbmRsZUV4aXQoc291cmNlSWQsIG5vZGUsIHBvaW50ZXIpO1xufVxuXG5mdW5jdGlvbiogaGFuZGxlRW50ZXIoc291cmNlSWQsIG5vZGUsIHBvaW50ZXIsIHBhcmVudElkKSB7XG4gIGlmICghKG5vZGUgaW5zdGFuY2VvZiBPYmplY3QpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgZGVidWcoXCJlbnRlcmluZyAlc1wiLCBwb2ludGVyKTtcblxuICBpZiAobm9kZS5pZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZGVidWcoXCIlcyByZWNvcmRpbmcgc2NvcGUgJXNcIiwgcG9pbnRlciwgbm9kZS5pZCk7XG4gICAgeWllbGQqIGRhdGEuc2NvcGUobm9kZS5pZCwgcG9pbnRlciwgcGFyZW50SWQsIHNvdXJjZUlkKTtcbiAgfVxuXG4gIHN3aXRjaCAobm9kZS5ub2RlVHlwZSkge1xuICAgIGNhc2UgXCJWYXJpYWJsZURlY2xhcmF0aW9uXCI6XG4gICAgICBkZWJ1ZyhcIiVzIHJlY29yZGluZyB2YXJpYWJsZSAlb1wiLCBwb2ludGVyLCBub2RlKTtcbiAgICAgIHlpZWxkKiBkYXRhLmRlY2xhcmUobm9kZSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiQ29udHJhY3REZWZpbml0aW9uXCI6XG4gICAgY2FzZSBcIlN0cnVjdERlZmluaXRpb25cIjpcbiAgICBjYXNlIFwiRW51bURlZmluaXRpb25cIjpcbiAgICAgIHlpZWxkKiBkYXRhLmRlZmluZVR5cGUobm9kZSk7XG4gICAgICBicmVhaztcbiAgfVxufVxuXG5mdW5jdGlvbiogaGFuZGxlRXhpdChzb3VyY2VJZCwgbm9kZSwgcG9pbnRlcikge1xuICBkZWJ1ZyhcImV4aXRpbmcgJXNcIiwgcG9pbnRlcik7XG5cbiAgLy8gbm8tb3AgcmlnaHQgbm93XG59XG5cbmV4cG9ydCBmdW5jdGlvbiogdmlzaXRBbGwoKSB7XG4gIGxldCBzb3VyY2VzID0geWllbGQgc2VsZWN0KGFzdC52aWV3cy5zb3VyY2VzKTtcblxuICB5aWVsZCBhbGwoXG4gICAgT2JqZWN0LmVudHJpZXMoc291cmNlcylcbiAgICAgIC5maWx0ZXIoKFtfLCBzb3VyY2VdKSA9PiBzb3VyY2UuYXN0KVxuICAgICAgLm1hcCgoW2lkLCB7IGFzdCB9XSkgPT4gY2FsbCh3YWxrLCBpZCwgYXN0KSlcbiAgKTtcblxuICBkZWJ1ZyhcImRvbmUgdmlzaXRpbmdcIik7XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gbGliL2FzdC9zYWdhcy9pbmRleC5qcyIsImltcG9ydCBkZWJ1Z01vZHVsZSBmcm9tIFwiZGVidWdcIjtcbmNvbnN0IGRlYnVnID0gZGVidWdNb2R1bGUoXCJkZWJ1Z2dlcjpzZXNzaW9uOnJlZHVjZXJzXCIpO1xuXG5pbXBvcnQgeyBjb21iaW5lUmVkdWNlcnMgfSBmcm9tIFwicmVkdXhcIjtcblxuaW1wb3J0IGRhdGEgZnJvbSBcImxpYi9kYXRhL3JlZHVjZXJzXCI7XG5pbXBvcnQgZXZtIGZyb20gXCJsaWIvZXZtL3JlZHVjZXJzXCI7XG5pbXBvcnQgc29saWRpdHkgZnJvbSBcImxpYi9zb2xpZGl0eS9yZWR1Y2Vyc1wiO1xuaW1wb3J0IHRyYWNlIGZyb20gXCJsaWIvdHJhY2UvcmVkdWNlcnNcIjtcbmltcG9ydCBjb250cm9sbGVyIGZyb20gXCJsaWIvY29udHJvbGxlci9yZWR1Y2Vyc1wiO1xuXG5pbXBvcnQgKiBhcyBhY3Rpb25zIGZyb20gXCIuL2FjdGlvbnNcIjtcblxuZnVuY3Rpb24gcmVhZHkoc3RhdGUgPSBmYWxzZSwgYWN0aW9uKSB7XG4gIHN3aXRjaCAoYWN0aW9uLnR5cGUpIHtcbiAgICBjYXNlIGFjdGlvbnMuUkVBRFk6XG4gICAgICBkZWJ1ZyhcInJlYWR5aW5nXCIpO1xuICAgICAgcmV0dXJuIHRydWU7XG5cbiAgICBjYXNlIGFjdGlvbnMuV0FJVDpcbiAgICAgIHJldHVybiBmYWxzZTtcblxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gc3RhdGU7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJvamVjdEluZm9Db21wdXRlZChzdGF0ZSA9IGZhbHNlLCBhY3Rpb24pIHtcbiAgc3dpdGNoIChhY3Rpb24udHlwZSkge1xuICAgIGNhc2UgYWN0aW9ucy5QUk9KRUNUX0lORk9fQ09NUFVURUQ6XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIHN0YXRlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGxhc3RMb2FkaW5nRXJyb3Ioc3RhdGUgPSBudWxsLCBhY3Rpb24pIHtcbiAgc3dpdGNoIChhY3Rpb24udHlwZSkge1xuICAgIGNhc2UgYWN0aW9ucy5FUlJPUjpcbiAgICAgIGRlYnVnKFwiZXJyb3I6ICVvXCIsIGFjdGlvbi5lcnJvcik7XG4gICAgICByZXR1cm4gYWN0aW9uLmVycm9yO1xuXG4gICAgY2FzZSBhY3Rpb25zLldBSVQ6XG4gICAgICByZXR1cm4gbnVsbDtcblxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gc3RhdGU7XG4gIH1cbn1cblxuZnVuY3Rpb24gdHJhbnNhY3Rpb24oc3RhdGUgPSB7fSwgYWN0aW9uKSB7XG4gIHN3aXRjaCAoYWN0aW9uLnR5cGUpIHtcbiAgICBjYXNlIGFjdGlvbnMuU0FWRV9UUkFOU0FDVElPTjpcbiAgICAgIHJldHVybiBhY3Rpb24udHJhbnNhY3Rpb247XG4gICAgY2FzZSBhY3Rpb25zLlVOTE9BRF9UUkFOU0FDVElPTjpcbiAgICAgIHJldHVybiB7fTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIHN0YXRlO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlY2VpcHQoc3RhdGUgPSB7fSwgYWN0aW9uKSB7XG4gIHN3aXRjaCAoYWN0aW9uLnR5cGUpIHtcbiAgICBjYXNlIGFjdGlvbnMuU0FWRV9SRUNFSVBUOlxuICAgICAgcmV0dXJuIGFjdGlvbi5yZWNlaXB0O1xuICAgIGNhc2UgYWN0aW9ucy5VTkxPQURfVFJBTlNBQ1RJT046XG4gICAgICByZXR1cm4ge307XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBzdGF0ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBibG9jayhzdGF0ZSA9IHt9LCBhY3Rpb24pIHtcbiAgc3dpdGNoIChhY3Rpb24udHlwZSkge1xuICAgIGNhc2UgYWN0aW9ucy5TQVZFX0JMT0NLOlxuICAgICAgcmV0dXJuIGFjdGlvbi5ibG9jaztcbiAgICBjYXNlIGFjdGlvbnMuVU5MT0FEX1RSQU5TQUNUSU9OOlxuICAgICAgcmV0dXJuIHt9O1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gc3RhdGU7XG4gIH1cbn1cblxuY29uc3Qgc2Vzc2lvbiA9IGNvbWJpbmVSZWR1Y2Vycyh7XG4gIHJlYWR5LFxuICBsYXN0TG9hZGluZ0Vycm9yLFxuICBwcm9qZWN0SW5mb0NvbXB1dGVkLFxuICB0cmFuc2FjdGlvbixcbiAgcmVjZWlwdCxcbiAgYmxvY2tcbn0pO1xuXG5jb25zdCByZWR1Y2VTdGF0ZSA9IGNvbWJpbmVSZWR1Y2Vycyh7XG4gIHNlc3Npb24sXG4gIGRhdGEsXG4gIGV2bSxcbiAgc29saWRpdHksXG4gIHRyYWNlLFxuICBjb250cm9sbGVyXG59KTtcblxuZXhwb3J0IGRlZmF1bHQgcmVkdWNlU3RhdGU7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gbGliL3Nlc3Npb24vcmVkdWNlcnMuanMiLCJpbXBvcnQgZGVidWdNb2R1bGUgZnJvbSBcImRlYnVnXCI7XG5jb25zdCBkZWJ1ZyA9IGRlYnVnTW9kdWxlKFwiZGVidWdnZXI6ZGF0YTpyZWR1Y2Vyc1wiKTtcblxuaW1wb3J0IHsgY29tYmluZVJlZHVjZXJzIH0gZnJvbSBcInJlZHV4XCI7XG5cbmltcG9ydCAqIGFzIGFjdGlvbnMgZnJvbSBcIi4vYWN0aW9uc1wiO1xuXG5pbXBvcnQgeyBzbG90QWRkcmVzcyB9IGZyb20gXCJ0cnVmZmxlLWRlY29kZXJcIjtcbmltcG9ydCB7IG1ha2VBc3NpZ25tZW50IH0gZnJvbSBcImxpYi9oZWxwZXJzXCI7XG5pbXBvcnQgeyBDb252ZXJzaW9uLCBEZWZpbml0aW9uLCBFVk0gfSBmcm9tIFwidHJ1ZmZsZS1kZWNvZGUtdXRpbHNcIjtcblxuY29uc3QgREVGQVVMVF9TQ09QRVMgPSB7XG4gIGJ5SWQ6IHt9XG59O1xuXG5mdW5jdGlvbiBzY29wZXMoc3RhdGUgPSBERUZBVUxUX1NDT1BFUywgYWN0aW9uKSB7XG4gIHZhciBzY29wZTtcbiAgdmFyIHZhcmlhYmxlcztcblxuICBzd2l0Y2ggKGFjdGlvbi50eXBlKSB7XG4gICAgY2FzZSBhY3Rpb25zLlNDT1BFOlxuICAgICAgc2NvcGUgPSBzdGF0ZS5ieUlkW2FjdGlvbi5pZF0gfHwge307XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGJ5SWQ6IHtcbiAgICAgICAgICAuLi5zdGF0ZS5ieUlkLFxuXG4gICAgICAgICAgW2FjdGlvbi5pZF06IHtcbiAgICAgICAgICAgIC4uLnNjb3BlLFxuXG4gICAgICAgICAgICBpZDogYWN0aW9uLmlkLFxuICAgICAgICAgICAgc291cmNlSWQ6IGFjdGlvbi5zb3VyY2VJZCxcbiAgICAgICAgICAgIHBhcmVudElkOiBhY3Rpb24ucGFyZW50SWQsXG4gICAgICAgICAgICBwb2ludGVyOiBhY3Rpb24ucG9pbnRlclxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgIGNhc2UgYWN0aW9ucy5ERUNMQVJFOlxuICAgICAgc2NvcGUgPSBzdGF0ZS5ieUlkW2FjdGlvbi5ub2RlLnNjb3BlXSB8fCB7fTtcbiAgICAgIHZhcmlhYmxlcyA9IHNjb3BlLnZhcmlhYmxlcyB8fCBbXTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYnlJZDoge1xuICAgICAgICAgIC4uLnN0YXRlLmJ5SWQsXG5cbiAgICAgICAgICBbYWN0aW9uLm5vZGUuc2NvcGVdOiB7XG4gICAgICAgICAgICAuLi5zY29wZSxcblxuICAgICAgICAgICAgdmFyaWFibGVzOiBbXG4gICAgICAgICAgICAgIC4uLnZhcmlhYmxlcyxcblxuICAgICAgICAgICAgICB7IG5hbWU6IGFjdGlvbi5ub2RlLm5hbWUsIGlkOiBhY3Rpb24ubm9kZS5pZCB9XG4gICAgICAgICAgICBdXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBzdGF0ZTtcbiAgfVxufVxuXG4vL2Egbm90ZSBvbiB0aGUgZm9sbG93aW5nIHJlZHVjZXI6IHNvbGlkaXR5IGFzc2lnbnMgYSB1bmlxdWUgQVNUIElEIHRvIGV2ZXJ5XG4vL0FTVCBub2RlIGFtb25nIGFsbCB0aGUgZmlsZXMgYmVpbmcgY29tcGlsZWQgdG9nZXRoZXIuICB0aHVzLCBpdCBpcywgZm9yIG5vdyxcbi8vc2FmZSB0byBpZGVudGlmeSB1c2VyLWRlZmluZWQgdHlwZXMgc29sZWx5IGJ5IHRoZWlyIEFTVCBJRC4gIEluIHRoZSBmdXR1cmUsXG4vL29uY2Ugd2UgZXZlbnR1YWxseSBzdXBwb3J0IGhhdmluZyBzb21lIGZpbGVzIGNvbXBpbGVkIHNlcGFyYXRlbHkgZnJvbSBvdGhlcnMsXG4vL3RoaXMgd2lsbCBiZWNvbWUgYSBidWcgeW91J2xsIGhhdmUgdG8gZml4LCBhbmQgeW91J2xsIGhhdmUgdG8gZml4IGl0IGluIHRoZVxuLy9kZWNvZGVyLCB0b28uICBTb3JyeSwgZnV0dXJlIG1lISAob3Igd2hvZXZlcidzIHN0dWNrIGRvaW5nIHRoaXMpXG5cbmZ1bmN0aW9uIHVzZXJEZWZpbmVkVHlwZXMoc3RhdGUgPSBbXSwgYWN0aW9uKSB7XG4gIHN3aXRjaCAoYWN0aW9uLnR5cGUpIHtcbiAgICBjYXNlIGFjdGlvbnMuREVGSU5FX1RZUEU6XG4gICAgICByZXR1cm4gWy4uLnN0YXRlLCBhY3Rpb24ubm9kZS5pZF07XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBzdGF0ZTtcbiAgfVxufVxuXG5jb25zdCBERUZBVUxUX0FMTE9DQVRJT05TID0ge1xuICBzdG9yYWdlOiB7fSxcbiAgbWVtb3J5OiB7fSxcbiAgY2FsbGRhdGE6IHt9XG59O1xuXG5mdW5jdGlvbiBhbGxvY2F0aW9ucyhzdGF0ZSA9IERFRkFVTFRfQUxMT0NBVElPTlMsIGFjdGlvbikge1xuICBpZiAoYWN0aW9uLnR5cGUgPT09IGFjdGlvbnMuQUxMT0NBVEUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc3RvcmFnZTogYWN0aW9uLnN0b3JhZ2UsXG4gICAgICBtZW1vcnk6IGFjdGlvbi5tZW1vcnksXG4gICAgICBjYWxsZGF0YTogYWN0aW9uLmNhbGxkYXRhXG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gc3RhdGU7XG4gIH1cbn1cblxuY29uc3QgaW5mbyA9IGNvbWJpbmVSZWR1Y2Vycyh7XG4gIHNjb3BlcyxcbiAgdXNlckRlZmluZWRUeXBlcyxcbiAgYWxsb2NhdGlvbnNcbn0pO1xuXG5jb25zdCBHTE9CQUxfQVNTSUdOTUVOVFMgPSBbXG4gIFt7IGJ1aWx0aW46IFwibXNnXCIgfSwgeyBzcGVjaWFsOiBcIm1zZ1wiIH1dLFxuICBbeyBidWlsdGluOiBcInR4XCIgfSwgeyBzcGVjaWFsOiBcInR4XCIgfV0sXG4gIFt7IGJ1aWx0aW46IFwiYmxvY2tcIiB9LCB7IHNwZWNpYWw6IFwiYmxvY2tcIiB9XSxcbiAgW3sgYnVpbHRpbjogXCJ0aGlzXCIgfSwgeyBzcGVjaWFsOiBcInRoaXNcIiB9XSxcbiAgW3sgYnVpbHRpbjogXCJub3dcIiB9LCB7IHNwZWNpYWw6IFwidGltZXN0YW1wXCIgfV0gLy93ZSBkb24ndCBoYXZlIGFuIGFsaWFzIFwibm93XCJcbl0ubWFwKChbaWRPYmosIHJlZl0pID0+IG1ha2VBc3NpZ25tZW50KGlkT2JqLCByZWYpKTtcblxuY29uc3QgREVGQVVMVF9BU1NJR05NRU5UUyA9IHtcbiAgYnlJZDogT2JqZWN0LmFzc2lnbihcbiAgICB7fSwgLy93ZSBzdGFydCBvdXQgd2l0aCBhbGwgZ2xvYmFscyBhc3NpZ25lZFxuICAgIC4uLkdMT0JBTF9BU1NJR05NRU5UUy5tYXAoYXNzaWdubWVudCA9PiAoeyBbYXNzaWdubWVudC5pZF06IGFzc2lnbm1lbnQgfSkpXG4gICksXG4gIGJ5QXN0SWQ6IHt9LCAvL25vIHJlZ3VsYXIgdmFyaWFibGVzIGFzc2lnbmVkIGF0IHN0YXJ0XG4gIGJ5QnVpbHRpbjogT2JqZWN0LmFzc2lnbihcbiAgICB7fSwgLy9hZ2FpbiwgYWxsIGdsb2JhbHMgc3RhcnQgYXNzaWduZWRcbiAgICAuLi5HTE9CQUxfQVNTSUdOTUVOVFMubWFwKGFzc2lnbm1lbnQgPT4gKHtcbiAgICAgIFthc3NpZ25tZW50LmJ1aWx0aW5dOiBbYXNzaWdubWVudC5pZF0gLy95ZXMsIHRoYXQncyBhIDEtZWxlbWVudCBhcnJheVxuICAgIH0pKVxuICApXG59O1xuXG5mdW5jdGlvbiBhc3NpZ25tZW50cyhzdGF0ZSA9IERFRkFVTFRfQVNTSUdOTUVOVFMsIGFjdGlvbikge1xuICBzd2l0Y2ggKGFjdGlvbi50eXBlKSB7XG4gICAgY2FzZSBhY3Rpb25zLkFTU0lHTjpcbiAgICBjYXNlIGFjdGlvbnMuTUFQX1BBVEhfQU5EX0FTU0lHTjpcbiAgICAgIGRlYnVnKFwiYWN0aW9uLnR5cGUgJU9cIiwgYWN0aW9uLnR5cGUpO1xuICAgICAgZGVidWcoXCJhY3Rpb24uYXNzaWdubWVudHMgJU9cIiwgYWN0aW9uLmFzc2lnbm1lbnRzKTtcbiAgICAgIHJldHVybiBPYmplY3QudmFsdWVzKGFjdGlvbi5hc3NpZ25tZW50cykucmVkdWNlKChhY2MsIGFzc2lnbm1lbnQpID0+IHtcbiAgICAgICAgbGV0IHsgaWQsIGFzdElkIH0gPSBhc3NpZ25tZW50O1xuICAgICAgICAvL3dlIGFzc3VtZSBmb3Igbm93IHRoYXQgb25seSBvcmRpbmFyeSB2YXJpYWJsZXMgd2lsbCBiZSBhc3NpZ25lZCB0aGlzXG4gICAgICAgIC8vd2F5LCBhbmQgbm90IGdsb2JhbHM7IGdsb2JhbHMgYXJlIGhhbmRsZWQgaW4gREVGQVVMVF9BU1NJR05NRU5UU1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIC4uLmFjYyxcbiAgICAgICAgICBieUlkOiB7XG4gICAgICAgICAgICAuLi5hY2MuYnlJZCxcbiAgICAgICAgICAgIFtpZF06IGFzc2lnbm1lbnRcbiAgICAgICAgICB9LFxuICAgICAgICAgIGJ5QXN0SWQ6IHtcbiAgICAgICAgICAgIC4uLmFjYy5ieUFzdElkLFxuICAgICAgICAgICAgW2FzdElkXTogWy4uLm5ldyBTZXQoWy4uLihhY2MuYnlBc3RJZFthc3RJZF0gfHwgW10pLCBpZF0pXVxuICAgICAgICAgICAgLy93ZSB1c2UgYSBzZXQgZm9yIHVuaXF1ZW5lc3NcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9LCBzdGF0ZSk7XG5cbiAgICBjYXNlIGFjdGlvbnMuUkVTRVQ6XG4gICAgICByZXR1cm4gREVGQVVMVF9BU1NJR05NRU5UUztcblxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gc3RhdGU7XG4gIH1cbn1cblxuY29uc3QgREVGQVVMVF9QQVRIUyA9IHtcbiAgYnlBZGRyZXNzOiB7fVxufTtcblxuLy9XQVJOSU5HOiBkbyAqbm90KiByZWx5IG9uIG1hcHBlZFBhdGhzIHRvIGtlZXAgdHJhY2sgb2YgcGF0aHMgdGhhdCBkbyBub3Rcbi8vaW52b2x2ZSBtYXBwaW5nIGtleXMhICBZZXMsIG1hbnkgd2lsbCBnZXQgbWFwcGVkLCBidXQgdGhlcmUgaXMgbm8gZ3VhcmFudGVlLlxuLy9Pbmx5IHdoZW4gbWFwcGluZyBrZXlzIGFyZSBpbnZvbHZlZCBkb2VzIGl0IG5lY2Vzc2FyaWx5IHdvcmsgcmVsaWFibHkgLS1cbi8vd2hpY2ggaXMgZmluZSwgYXMgdGhhdCdzIGFsbCB3ZSBuZWVkIGl0IGZvci5cbmZ1bmN0aW9uIG1hcHBlZFBhdGhzKHN0YXRlID0gREVGQVVMVF9QQVRIUywgYWN0aW9uKSB7XG4gIHN3aXRjaCAoYWN0aW9uLnR5cGUpIHtcbiAgICBjYXNlIGFjdGlvbnMuTUFQX1BBVEhfQU5EX0FTU0lHTjpcbiAgICAgIGxldCB7IGFkZHJlc3MsIHNsb3QsIHR5cGVJZGVudGlmaWVyLCBwYXJlbnRUeXBlIH0gPSBhY3Rpb247XG4gICAgICAvL2hvdyB0aGlzIGNhc2Ugd29ya3M6IGZpcnN0LCB3ZSBmaW5kIHRoZSBzcG90IGluIG91ciB0YWJsZSAoYmFzZWQgb25cbiAgICAgIC8vYWRkcmVzcywgdHlwZSBpZGVudGlmaWVyLCBhbmQgc2xvdCBhZGRyZXNzKSB3aGVyZSB0aGUgbmV3IGVudHJ5IHNob3VsZFxuICAgICAgLy9iZSBhZGRlZDsgaWYgbmVlZGVkIHdlIHNldCB1cCBhbGwgdGhlIG9iamVjdHMgbmVlZGVkIGFsb25nIHRoZSB3YXkuICBJZlxuICAgICAgLy90aGVyZSdzIGFscmVhZHkgc29tZXRoaW5nIHRoZXJlLCB3ZSBkbyBub3RoaW5nLiAgSWYgdGhlcmUncyBub3RoaW5nXG4gICAgICAvL3RoZXJlLCB3ZSByZWNvcmQgb3VyIGdpdmVuIHNsb3QgaW4gdGhhdCBzcG90IGluIHRoYXQgdGFibGUgLS0gaG93ZXZlcixcbiAgICAgIC8vd2UgYWx0ZXIgaXQgaW4gb25lIGtleSB3YXkuICBCZWZvcmUgZW50cnksIHdlIGNoZWNrIGlmIHRoZSBzbG90J3NcbiAgICAgIC8vKnBhcmVudCogaGFzIGEgc3BvdCBpbiB0aGUgdGFibGUsIGJhc2VkIG9uIGFkZHJlc3MgKHNhbWUgZm9yIGJvdGggY2hpbGRcbiAgICAgIC8vYW5kIHBhcmVudCksIHBhcmVudFR5cGUsIGFuZCB0aGUgcGFyZW50J3Mgc2xvdCBhZGRyZXNzICh3aGljaCBjYW4gYmVcbiAgICAgIC8vZm91bmQgYXMgdGhlIHNsb3RBZGRyZXNzIG9mIHRoZSBzbG90J3MgcGF0aCBvYmplY3QsIGlmIGl0IGV4aXN0cyAtLSBpZlxuICAgICAgLy9pdCBkb2Vzbid0IHRoZW4gd2UgY29uY2x1ZGUgdGhhdCBubyB0aGUgcGFyZW50IGRvZXMgbm90IGhhdmUgYSBzcG90IGluXG4gICAgICAvL3RoZSB0YWJsZSkuICBJZiB0aGUgcGFyZW50IGhhcyBhIHNsb3QgaW4gdGhlIHRhYmxlIGFscmVhZHksIHRoZW4gd2VcbiAgICAgIC8vYWx0ZXIgdGhlIGNoaWxkIHNsb3QgYnkgcmVwbGFjaW5nIGl0cyBwYXRoIHdpdGggdGhlIHBhcmVudCBzbG90LiAgVGhpc1xuICAgICAgLy93aWxsIGtlZXAgdGhlIHNsb3RBZGRyZXNzIHRoZSBzYW1lLCBidXQgc2luY2UgdGhlIHZlcnNpb25zIGtlcHQgaW4gdGhlXG4gICAgICAvL3RhYmxlIGhlcmUgYXJlIHN1cHBvc2VkIHRvIHByZXNlcnZlIHBhdGggaW5mb3JtYXRpb24sIHdlJ2xsIGJlXG4gICAgICAvL3JlcGxhY2luZyBhIGZhaXJseSBiYXJlLWJvbmVzIFNsb3Qgb2JqZWN0IHdpdGggb25lIHdpdGggYSBmdWxsIHBhdGguXG5cbiAgICAgIC8vd2UgZG8gTk9UIHdhbnQgdG8gZGlzdGluZ3Vpc2ggYmV0d2VlbiB0eXBlcyB3aXRoIGFuZCB3aXRob3V0IFwiX3B0clwiIG9uXG4gICAgICAvL3RoZSBlbmQgaGVyZSFcbiAgICAgIGRlYnVnKFwidHlwZUlkZW50aWZpZXIgJXNcIiwgdHlwZUlkZW50aWZpZXIpO1xuICAgICAgdHlwZUlkZW50aWZpZXIgPSBEZWZpbml0aW9uLnJlc3RvcmVQdHIodHlwZUlkZW50aWZpZXIpO1xuICAgICAgcGFyZW50VHlwZSA9IERlZmluaXRpb24ucmVzdG9yZVB0cihwYXJlbnRUeXBlKTtcblxuICAgICAgZGVidWcoXCJzbG90ICVvXCIsIHNsb3QpO1xuICAgICAgbGV0IGhleFNsb3RBZGRyZXNzID0gQ29udmVyc2lvbi50b0hleFN0cmluZyhcbiAgICAgICAgc2xvdEFkZHJlc3Moc2xvdCksXG4gICAgICAgIEVWTS5XT1JEX1NJWkVcbiAgICAgICk7XG4gICAgICBsZXQgcGFyZW50QWRkcmVzcyA9IHNsb3QucGF0aFxuICAgICAgICA/IENvbnZlcnNpb24udG9IZXhTdHJpbmcoc2xvdEFkZHJlc3Moc2xvdC5wYXRoKSwgRVZNLldPUkRfU0laRSlcbiAgICAgICAgOiB1bmRlZmluZWQ7XG5cbiAgICAgIC8vdGhpcyBpcyBnb2luZyB0byBiZSBtZXNzeSBhbmQgcHJvY2VkdXJhbCwgc29ycnkuICBidXQgbGV0J3Mgc3RhcnQgd2l0aFxuICAgICAgLy90aGUgZWFzeSBzdHVmZjogY3JlYXRlIHRoZSBuZXcgYWRkcmVzcyBpZiBuZWVkZWQsIGNsb25lIGlmIG5vdFxuICAgICAgbGV0IG5ld1N0YXRlID0ge1xuICAgICAgICAuLi5zdGF0ZSxcbiAgICAgICAgYnlBZGRyZXNzOiB7XG4gICAgICAgICAgLi4uc3RhdGUuYnlBZGRyZXNzLFxuICAgICAgICAgIFthZGRyZXNzXToge1xuICAgICAgICAgICAgYnlUeXBlOiB7XG4gICAgICAgICAgICAgIC4uLihzdGF0ZS5ieUFkZHJlc3NbYWRkcmVzc10gfHwgeyBieVR5cGU6IHt9IH0pLmJ5VHlwZVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgLy9ub3csIGxldCdzIGFkZCBpbiB0aGUgbmV3IHR5cGUsIGlmIG5lZWRlZFxuICAgICAgbmV3U3RhdGUuYnlBZGRyZXNzW2FkZHJlc3NdLmJ5VHlwZSA9IHtcbiAgICAgICAgLi4ubmV3U3RhdGUuYnlBZGRyZXNzW2FkZHJlc3NdLmJ5VHlwZSxcbiAgICAgICAgW3R5cGVJZGVudGlmaWVyXToge1xuICAgICAgICAgIGJ5U2xvdEFkZHJlc3M6IHtcbiAgICAgICAgICAgIC4uLihcbiAgICAgICAgICAgICAgbmV3U3RhdGUuYnlBZGRyZXNzW2FkZHJlc3NdLmJ5VHlwZVt0eXBlSWRlbnRpZmllcl0gfHwge1xuICAgICAgICAgICAgICAgIGJ5U2xvdEFkZHJlc3M6IHt9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICkuYnlTbG90QWRkcmVzc1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgbGV0IG9sZFNsb3QgPVxuICAgICAgICBuZXdTdGF0ZS5ieUFkZHJlc3NbYWRkcmVzc10uYnlUeXBlW3R5cGVJZGVudGlmaWVyXS5ieVNsb3RBZGRyZXNzW1xuICAgICAgICAgIGhleFNsb3RBZGRyZXNzXG4gICAgICAgIF07XG4gICAgICAvL3llcywgdGhpcyBsb29rcyBzdHJhbmdlLCBidXQgd2UgaGF2ZW4ndCBjaGFuZ2VkIGl0IHlldCBleGNlcHQgdG9cbiAgICAgIC8vY2xvbmUgb3IgY3JlYXRlIGVtcHR5IChhbmQgd2UgZG9uJ3Qgd2FudCB1bmRlZmluZWQhKVxuICAgICAgLy9ub3c6IGlzIHRoZXJlIHNvbWV0aGluZyBhbHJlYWR5IHRoZXJlIG9yIG5vPyAgaWYgbm8sIHdlIG11c3QgYWRkXG4gICAgICBpZiAob2xkU2xvdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxldCBuZXdTbG90O1xuICAgICAgICBkZWJ1ZyhcInBhcmVudEFkZHJlc3MgJW9cIiwgcGFyZW50QWRkcmVzcyk7XG4gICAgICAgIGlmIChcbiAgICAgICAgICBwYXJlbnRBZGRyZXNzICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICBuZXdTdGF0ZS5ieUFkZHJlc3NbYWRkcmVzc10uYnlUeXBlW3BhcmVudFR5cGVdICYmXG4gICAgICAgICAgbmV3U3RhdGUuYnlBZGRyZXNzW2FkZHJlc3NdLmJ5VHlwZVtwYXJlbnRUeXBlXS5ieVNsb3RBZGRyZXNzW1xuICAgICAgICAgICAgcGFyZW50QWRkcmVzc1xuICAgICAgICAgIF1cbiAgICAgICAgKSB7XG4gICAgICAgICAgLy9pZiB0aGUgcGFyZW50IGlzIGFscmVhZHkgcHJlc2VudCwgdXNlIHRoYXQgaW5zdGVhZCBvZiB0aGUgZ2l2ZW5cbiAgICAgICAgICAvL3BhcmVudCFcbiAgICAgICAgICBuZXdTbG90ID0ge1xuICAgICAgICAgICAgLi4uc2xvdCxcbiAgICAgICAgICAgIHBhdGg6XG4gICAgICAgICAgICAgIG5ld1N0YXRlLmJ5QWRkcmVzc1thZGRyZXNzXS5ieVR5cGVbcGFyZW50VHlwZV0uYnlTbG90QWRkcmVzc1tcbiAgICAgICAgICAgICAgICBwYXJlbnRBZGRyZXNzXG4gICAgICAgICAgICAgIF1cbiAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5ld1Nsb3QgPSBzbG90O1xuICAgICAgICB9XG4gICAgICAgIG5ld1N0YXRlLmJ5QWRkcmVzc1thZGRyZXNzXS5ieVR5cGVbdHlwZUlkZW50aWZpZXJdLmJ5U2xvdEFkZHJlc3NbXG4gICAgICAgICAgaGV4U2xvdEFkZHJlc3NcbiAgICAgICAgXSA9IG5ld1Nsb3Q7XG4gICAgICB9XG4gICAgICAvL2lmIHRoZXJlJ3MgYWxyZWFkeSBzb21ldGhpbmcgdGhlcmUsIHdlIGRvbid0IG5lZWQgdG8gZG8gYW55dGhpbmdcblxuICAgICAgcmV0dXJuIG5ld1N0YXRlO1xuXG4gICAgY2FzZSBhY3Rpb25zLlJFU0VUOlxuICAgICAgcmV0dXJuIERFRkFVTFRfUEFUSFM7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIHN0YXRlO1xuICB9XG59XG5cbmNvbnN0IHByb2MgPSBjb21iaW5lUmVkdWNlcnMoe1xuICBhc3NpZ25tZW50cyxcbiAgbWFwcGVkUGF0aHNcbn0pO1xuXG5jb25zdCByZWR1Y2VyID0gY29tYmluZVJlZHVjZXJzKHtcbiAgaW5mbyxcbiAgcHJvY1xufSk7XG5cbmV4cG9ydCBkZWZhdWx0IHJlZHVjZXI7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gbGliL2RhdGEvcmVkdWNlcnMuanMiLCJpbXBvcnQgZGVidWdNb2R1bGUgZnJvbSBcImRlYnVnXCI7XG5jb25zdCBkZWJ1ZyA9IGRlYnVnTW9kdWxlKFwiZGVidWdnZXI6ZXZtOnJlZHVjZXJzXCIpO1xuXG5pbXBvcnQgeyBjb21iaW5lUmVkdWNlcnMgfSBmcm9tIFwicmVkdXhcIjtcblxuaW1wb3J0ICogYXMgYWN0aW9ucyBmcm9tIFwiLi9hY3Rpb25zXCI7XG5pbXBvcnQgeyBrZWNjYWsyNTYsIGV4dHJhY3RQcmltYXJ5U291cmNlIH0gZnJvbSBcImxpYi9oZWxwZXJzXCI7XG5pbXBvcnQgKiBhcyBEZWNvZGVVdGlscyBmcm9tIFwidHJ1ZmZsZS1kZWNvZGUtdXRpbHNcIjtcblxuaW1wb3J0IEJOIGZyb20gXCJibi5qc1wiO1xuXG5jb25zdCBERUZBVUxUX0NPTlRFWFRTID0ge1xuICBieUNvbnRleHQ6IHt9XG59O1xuXG5mdW5jdGlvbiBjb250ZXh0cyhzdGF0ZSA9IERFRkFVTFRfQ09OVEVYVFMsIGFjdGlvbikge1xuICBzd2l0Y2ggKGFjdGlvbi50eXBlKSB7XG4gICAgLypcbiAgICAgKiBBZGRpbmcgYSBuZXcgY29udGV4dFxuICAgICAqL1xuICAgIGNhc2UgYWN0aW9ucy5BRERfQ09OVEVYVDpcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgY29udHJhY3ROYW1lLFxuICAgICAgICBiaW5hcnksXG4gICAgICAgIHNvdXJjZU1hcCxcbiAgICAgICAgY29tcGlsZXIsXG4gICAgICAgIGFiaSxcbiAgICAgICAgY29udHJhY3RJZCxcbiAgICAgICAgY29udHJhY3RLaW5kLFxuICAgICAgICBpc0NvbnN0cnVjdG9yXG4gICAgICB9ID0gYWN0aW9uO1xuICAgICAgZGVidWcoXCJhY3Rpb24gJU9cIiwgYWN0aW9uKTtcbiAgICAgIC8vTk9URTogd2UgdGFrZSBoYXNoIGFzICpzdHJpbmcqLCBub3QgYXMgYnl0ZXMsIGJlY2F1c2UgdGhlIGJpbmFyeSBtYXlcbiAgICAgIC8vY29udGFpbiBsaW5rIHJlZmVyZW5jZXMhXG4gICAgICBjb25zdCBjb250ZXh0ID0ga2VjY2FrMjU2KHsgdHlwZTogXCJzdHJpbmdcIiwgdmFsdWU6IGJpbmFyeSB9KTtcbiAgICAgIGxldCBwcmltYXJ5U291cmNlO1xuICAgICAgaWYgKHNvdXJjZU1hcCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHByaW1hcnlTb3VyY2UgPSBleHRyYWN0UHJpbWFyeVNvdXJjZShzb3VyY2VNYXApO1xuICAgICAgfVxuICAgICAgLy9vdGhlcndpc2UgbGVhdmUgaXQgdW5kZWZpbmVkXG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLnN0YXRlLFxuICAgICAgICBieUNvbnRleHQ6IHtcbiAgICAgICAgICAuLi5zdGF0ZS5ieUNvbnRleHQsXG4gICAgICAgICAgW2NvbnRleHRdOiB7XG4gICAgICAgICAgICBjb250cmFjdE5hbWUsXG4gICAgICAgICAgICBjb250ZXh0LFxuICAgICAgICAgICAgYmluYXJ5LFxuICAgICAgICAgICAgc291cmNlTWFwLFxuICAgICAgICAgICAgcHJpbWFyeVNvdXJjZSxcbiAgICAgICAgICAgIGNvbXBpbGVyLFxuICAgICAgICAgICAgYWJpLFxuICAgICAgICAgICAgY29udHJhY3RJZCxcbiAgICAgICAgICAgIGNvbnRyYWN0S2luZCxcbiAgICAgICAgICAgIGlzQ29uc3RydWN0b3JcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICBjYXNlIGFjdGlvbnMuTk9STUFMSVpFX0NPTlRFWFRTOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYnlDb250ZXh0OiBEZWNvZGVVdGlscy5Db250ZXh0cy5ub3JtYWxpemVDb250ZXh0cyhzdGF0ZS5ieUNvbnRleHQpXG4gICAgICB9O1xuXG4gICAgLypcbiAgICAgKiBEZWZhdWx0IGNhc2VcbiAgICAgKi9cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIHN0YXRlO1xuICB9XG59XG5cbmNvbnN0IGluZm8gPSBjb21iaW5lUmVkdWNlcnMoe1xuICBjb250ZXh0c1xufSk7XG5cbmNvbnN0IERFRkFVTFRfVFggPSB7XG4gIGdhc3ByaWNlOiBuZXcgQk4oMCksXG4gIG9yaWdpbjogRGVjb2RlVXRpbHMuRVZNLlpFUk9fQUREUkVTU1xufTtcblxuZnVuY3Rpb24gdHgoc3RhdGUgPSBERUZBVUxUX1RYLCBhY3Rpb24pIHtcbiAgc3dpdGNoIChhY3Rpb24udHlwZSkge1xuICAgIGNhc2UgYWN0aW9ucy5TQVZFX0dMT0JBTFM6XG4gICAgICBsZXQgeyBnYXNwcmljZSwgb3JpZ2luIH0gPSBhY3Rpb247XG4gICAgICByZXR1cm4geyBnYXNwcmljZSwgb3JpZ2luIH07XG4gICAgY2FzZSBhY3Rpb25zLlVOTE9BRF9UUkFOU0FDVElPTjpcbiAgICAgIHJldHVybiBERUZBVUxUX1RYO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gc3RhdGU7XG4gIH1cbn1cblxuY29uc3QgREVGQVVMVF9CTE9DSyA9IHtcbiAgY29pbmJhc2U6IERlY29kZVV0aWxzLkVWTS5aRVJPX0FERFJFU1MsXG4gIGRpZmZpY3VsdHk6IG5ldyBCTigwKSxcbiAgZ2FzbGltaXQ6IG5ldyBCTigwKSxcbiAgbnVtYmVyOiBuZXcgQk4oMCksXG4gIHRpbWVzdGFtcDogbmV3IEJOKDApXG59O1xuXG5mdW5jdGlvbiBibG9jayhzdGF0ZSA9IERFRkFVTFRfQkxPQ0ssIGFjdGlvbikge1xuICBzd2l0Y2ggKGFjdGlvbi50eXBlKSB7XG4gICAgY2FzZSBhY3Rpb25zLlNBVkVfR0xPQkFMUzpcbiAgICAgIHJldHVybiBhY3Rpb24uYmxvY2s7XG4gICAgY2FzZSBhY3Rpb25zLlVOTE9BRF9UUkFOU0FDVElPTjpcbiAgICAgIHJldHVybiBERUZBVUxUX0JMT0NLO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gc3RhdGU7XG4gIH1cbn1cblxuY29uc3QgZ2xvYmFscyA9IGNvbWJpbmVSZWR1Y2Vycyh7XG4gIHR4LFxuICBibG9ja1xufSk7XG5cbmZ1bmN0aW9uIHN0YXR1cyhzdGF0ZSA9IG51bGwsIGFjdGlvbikge1xuICBzd2l0Y2ggKGFjdGlvbi50eXBlKSB7XG4gICAgY2FzZSBhY3Rpb25zLlNBVkVfU1RBVFVTOlxuICAgICAgcmV0dXJuIGFjdGlvbi5zdGF0dXM7XG4gICAgY2FzZSBhY3Rpb25zLlVOTE9BRF9UUkFOU0FDVElPTjpcbiAgICAgIHJldHVybiBudWxsO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gc3RhdGU7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5pdGlhbENhbGwoc3RhdGUgPSBudWxsLCBhY3Rpb24pIHtcbiAgc3dpdGNoIChhY3Rpb24udHlwZSkge1xuICAgIGNhc2UgYWN0aW9ucy5DQUxMOlxuICAgIGNhc2UgYWN0aW9ucy5DUkVBVEU6XG4gICAgICAvL3dlIG9ubHkgd2FudCB0byBzYXZlIHRoZSBpbml0aWFsIGNhbGwsIHNvIHJldHVyblxuICAgICAgLy90aGUgY3VycmVudCBzdGF0ZSBpZiBpdCdzIG5vdCBudWxsXG4gICAgICBpZiAoc3RhdGUgIT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy93ZSdsbCBqdXN0IHN0b3JlIHRoZSBhY3Rpb24gaXRzZWxmIGluIHRoZSBzdGF0ZVxuICAgICAgICByZXR1cm4gYWN0aW9uO1xuICAgICAgfVxuICAgIGNhc2UgYWN0aW9ucy5VTkxPQURfVFJBTlNBQ1RJT046XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIHN0YXRlO1xuICB9XG59XG5cbmNvbnN0IHRyYW5zYWN0aW9uID0gY29tYmluZVJlZHVjZXJzKHtcbiAgZ2xvYmFscyxcbiAgc3RhdHVzLFxuICBpbml0aWFsQ2FsbFxufSk7XG5cbmZ1bmN0aW9uIGNhbGxzdGFjayhzdGF0ZSA9IFtdLCBhY3Rpb24pIHtcbiAgc3dpdGNoIChhY3Rpb24udHlwZSkge1xuICAgIGNhc2UgYWN0aW9ucy5DQUxMOiB7XG4gICAgICBjb25zdCB7IGFkZHJlc3MsIGRhdGEsIHN0b3JhZ2VBZGRyZXNzLCBzZW5kZXIsIHZhbHVlIH0gPSBhY3Rpb247XG4gICAgICByZXR1cm4gc3RhdGUuY29uY2F0KFt7IGFkZHJlc3MsIGRhdGEsIHN0b3JhZ2VBZGRyZXNzLCBzZW5kZXIsIHZhbHVlIH1dKTtcbiAgICB9XG5cbiAgICBjYXNlIGFjdGlvbnMuQ1JFQVRFOiB7XG4gICAgICBjb25zdCB7IGJpbmFyeSwgc3RvcmFnZUFkZHJlc3MsIHNlbmRlciwgdmFsdWUgfSA9IGFjdGlvbjtcbiAgICAgIHJldHVybiBzdGF0ZS5jb25jYXQoXG4gICAgICAgIFt7IGJpbmFyeSwgZGF0YTogXCIweFwiLCBzdG9yYWdlQWRkcmVzcywgc2VuZGVyLCB2YWx1ZSB9XVxuICAgICAgICAvL3RoZSBlbXB0eSBkYXRhIGZpZWxkIGlzIHRvIG1ha2UgbXNnLmRhdGEgYW5kIG1zZy5zaWcgY29tZSBvdXQgcmlnaHRcbiAgICAgICk7XG4gICAgfVxuXG4gICAgY2FzZSBhY3Rpb25zLlJFVFVSTl9DQUxMOlxuICAgIGNhc2UgYWN0aW9ucy5SRVRVUk5fQ1JFQVRFOlxuICAgIGNhc2UgYWN0aW9ucy5GQUlMOlxuICAgICAgLy9wb3AgdGhlIHN0YWNrLi4uIHVubGVzcyAoSEFDSykgdGhhdCB3b3VsZCBsZWF2ZSBpdCBlbXB0eSAodGhpcyB3aWxsXG4gICAgICAvL29ubHkgaGFwcGVuIGF0IHRoZSBlbmQgd2hlbiB3ZSB3YW50IHRvIGtlZXAgdGhlIGxhc3Qgb25lIGFyb3VuZClcbiAgICAgIHJldHVybiBzdGF0ZS5sZW5ndGggPiAxID8gc3RhdGUuc2xpY2UoMCwgLTEpIDogc3RhdGU7XG5cbiAgICBjYXNlIGFjdGlvbnMuUkVTRVQ6XG4gICAgY2FzZSBhY3Rpb25zLlVOTE9BRF9UUkFOU0FDVElPTjpcbiAgICAgIHJldHVybiBbXTtcblxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gc3RhdGU7XG4gIH1cbn1cblxuY29uc3QgREVGQVVMVF9DT0RFWCA9IFtcbiAge1xuICAgIGFjY291bnRzOiB7fVxuICAgIC8vd2lsbCBiZSBtb3JlIGhlcmUgaW4gdGhlIGZ1dHVyZSFcbiAgfVxuXTtcblxuZnVuY3Rpb24gY29kZXgoc3RhdGUgPSBERUZBVUxUX0NPREVYLCBhY3Rpb24pIHtcbiAgbGV0IG5ld1N0YXRlLCB0b3BDb2RleDtcblxuICBjb25zdCB1cGRhdGVGcmFtZVN0b3JhZ2UgPSAoZnJhbWUsIGFkZHJlc3MsIHNsb3QsIHZhbHVlKSA9PiAoe1xuICAgIC4uLmZyYW1lLFxuICAgIGFjY291bnRzOiB7XG4gICAgICAuLi5mcmFtZS5hY2NvdW50cyxcbiAgICAgIFthZGRyZXNzXToge1xuICAgICAgICAuLi5mcmFtZS5hY2NvdW50c1thZGRyZXNzXSxcbiAgICAgICAgc3RvcmFnZToge1xuICAgICAgICAgIC4uLmZyYW1lLmFjY291bnRzW2FkZHJlc3NdLnN0b3JhZ2UsXG4gICAgICAgICAgW3Nsb3RdOiB2YWx1ZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICBjb25zdCB1cGRhdGVGcmFtZUNvZGUgPSAoZnJhbWUsIGFkZHJlc3MsIGNvZGUsIGNvbnRleHQpID0+IHtcbiAgICBsZXQgZXhpc3RpbmdQYWdlID0gZnJhbWUuYWNjb3VudHNbYWRkcmVzc10gfHwgeyBzdG9yYWdlOiB7fSB9O1xuICAgIHJldHVybiB7XG4gICAgICAuLi5mcmFtZSxcbiAgICAgIGFjY291bnRzOiB7XG4gICAgICAgIC4uLmZyYW1lLmFjY291bnRzLFxuICAgICAgICBbYWRkcmVzc106IHtcbiAgICAgICAgICAuLi5leGlzdGluZ1BhZ2UsXG4gICAgICAgICAgY29kZTogY29kZSxcbiAgICAgICAgICBjb250ZXh0OiBjb250ZXh0XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9O1xuXG4gIC8vbGF0ZXI6IHdpbGwgYWRkIFwiZm9yY2VcIiBwYXJhbWV0ZXJcbiAgY29uc3Qgc2FmZVBvcCA9IGFycmF5ID0+IChhcnJheS5sZW5ndGggPiAyID8gYXJyYXkuc2xpY2UoMCwgLTEpIDogYXJyYXkpO1xuXG4gIC8vbGF0ZXI6IHdpbGwgYWRkIFwiZm9yY2VcIiBwYXJhbWV0ZXJcbiAgY29uc3Qgc2FmZVNhdmUgPSBhcnJheSA9PlxuICAgIGFycmF5Lmxlbmd0aCA+IDJcbiAgICAgID8gYXJyYXkuc2xpY2UoMCwgLTIpLmNvbmNhdChbYXJyYXlbYXJyYXkubGVuZ3RoIC0gMV1dKVxuICAgICAgOiBhcnJheTtcblxuICBzd2l0Y2ggKGFjdGlvbi50eXBlKSB7XG4gICAgY2FzZSBhY3Rpb25zLkNBTEw6XG4gICAgICBkZWJ1ZyhcImNhbGwgYWN0aW9uXCIpO1xuICAgICAgZGVidWcoXCJjb2RleDogJU9cIiwgc3RhdGUpO1xuICAgICAgLy9vbiBhIGNhbGwsIHdlIGNhbiBqdXN0IG1ha2UgYSBuZXcgc3RhY2tmcmFtZSBieSBjbG9uaW5nIHRoZSB0b3BcbiAgICAgIC8vc3RhY2tmcmFtZTsgdGhlcmUgc2hvdWxkIGFscmVhZHkgYmUgYW4gYWNjb3VudCBmb3IgdGhlIGFkZHJlc3Mgd2UncmVcbiAgICAgIC8vY2FsbGluZyBpbnRvLCBzbyB3ZSBkb24ndCBuZWVkIHRvIG1ha2Ugb25lXG4gICAgICByZXR1cm4gWy4uLnN0YXRlLCBzdGF0ZVtzdGF0ZS5sZW5ndGggLSAxXV07XG5cbiAgICBjYXNlIGFjdGlvbnMuQ1JFQVRFOlxuICAgICAgLy9vbiBhIGNyZWF0ZSwgbWFrZSBhIG5ldyBzdGFja2ZyYW1lLCB0aGVuIGFkZCBhIG5ldyBwYWdlcyB0byB0aGVcbiAgICAgIC8vY29kZXggaWYgbmVjZXNzYXJ5OyBkb24ndCBhZGQgYSB6ZXJvIHBhZ2UgdGhvdWdoIChvciBwYWdlcyB0aGF0IGFscmVhZHlcbiAgICAgIC8vZXhpc3QpXG5cbiAgICAgIC8vZmlyc3QsIGFkZCBhIG5ldyBzdGFja2ZyYW1lIGJ5IGNsb25pbmcgdGhlIHRvcCBvbmVcbiAgICAgIG5ld1N0YXRlID0gWy4uLnN0YXRlLCBzdGF0ZVtzdGF0ZS5sZW5ndGggLSAxXV07XG4gICAgICB0b3BDb2RleCA9IG5ld1N0YXRlW25ld1N0YXRlLmxlbmd0aCAtIDFdO1xuICAgICAgLy9ub3csIGRvIHdlIG5lZWQgdG8gYWRkIGEgbmV3IGFkZHJlc3MgdG8gdGhpcyBzdGFja2ZyYW1lP1xuICAgICAgaWYgKFxuICAgICAgICB0b3BDb2RleC5hY2NvdW50c1thY3Rpb24uc3RvcmFnZUFkZHJlc3NdICE9PSB1bmRlZmluZWQgfHxcbiAgICAgICAgYWN0aW9uLnN0b3JhZ2VBZGRyZXNzID09PSBEZWNvZGVVdGlscy5FVk0uWkVST19BRERSRVNTXG4gICAgICApIHtcbiAgICAgICAgLy9pZiB3ZSBkb24ndFxuICAgICAgICByZXR1cm4gbmV3U3RhdGU7XG4gICAgICB9XG4gICAgICAvL2lmIHdlIGRvXG4gICAgICBuZXdTdGF0ZVtuZXdTdGF0ZS5sZW5ndGggLSAxXSA9IHtcbiAgICAgICAgLi4udG9wQ29kZXgsXG4gICAgICAgIGFjY291bnRzOiB7XG4gICAgICAgICAgLi4udG9wQ29kZXguYWNjb3VudHMsXG4gICAgICAgICAgW2FjdGlvbi5zdG9yYWdlQWRkcmVzc106IHtcbiAgICAgICAgICAgIHN0b3JhZ2U6IHt9LFxuICAgICAgICAgICAgY29kZTogXCIweFwiLFxuICAgICAgICAgICAgY29udGV4dDogbnVsbFxuICAgICAgICAgICAgLy90aGVyZSB3aWxsIGJlIG1vcmUgaGVyZSBpbiB0aGUgZnV0dXJlIVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHJldHVybiBuZXdTdGF0ZTtcblxuICAgIGNhc2UgYWN0aW9ucy5TVE9SRToge1xuICAgICAgLy9vbiBhIHN0b3JlLCB0aGUgcmVsZXZhbnQgcGFnZSBzaG91bGQgYWxyZWFkeSBleGlzdCwgc28gd2UgY2FuIGp1c3RcbiAgICAgIC8vYWRkIG9yIHVwZGF0ZSB0aGUgbmVlZGVkIHNsb3RcbiAgICAgIGNvbnN0IHsgYWRkcmVzcywgc2xvdCwgdmFsdWUgfSA9IGFjdGlvbjtcbiAgICAgIGlmIChhZGRyZXNzID09PSBEZWNvZGVVdGlscy5FVk0uWkVST19BRERSRVNTKSB7XG4gICAgICAgIC8vYXMgYWx3YXlzLCB3ZSBkbyBub3QgbWFpbnRhaW4gYSB6ZXJvIHBhZ2VcbiAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgICAgfVxuICAgICAgbmV3U3RhdGUgPSBzdGF0ZS5zbGljZSgpOyAvL2Nsb25lIHRoZSBzdGF0ZVxuICAgICAgdG9wQ29kZXggPSBuZXdTdGF0ZVtuZXdTdGF0ZS5sZW5ndGggLSAxXTtcbiAgICAgIG5ld1N0YXRlW25ld1N0YXRlLmxlbmd0aCAtIDFdID0gdXBkYXRlRnJhbWVTdG9yYWdlKFxuICAgICAgICB0b3BDb2RleCxcbiAgICAgICAgYWRkcmVzcyxcbiAgICAgICAgc2xvdCxcbiAgICAgICAgdmFsdWVcbiAgICAgICk7XG4gICAgICByZXR1cm4gbmV3U3RhdGU7XG4gICAgfVxuXG4gICAgY2FzZSBhY3Rpb25zLkxPQUQ6IHtcbiAgICAgIC8vbG9hZHMgYXJlIGEgbGl0dGxlIG1vcmUgY29tcGxpY2F0ZWQgLS0gdXN1YWxseSB3ZSBkbyBub3RoaW5nLCBidXQgaWZcbiAgICAgIC8vaXQncyBhbiBleHRlcm5hbCBsb2FkICh0aGVyZSB3YXMgbm90aGluZyBhbHJlYWR5IHRoZXJlKSwgdGhlbiB3ZSB3YW50XG4gICAgICAvL3RvIHVwZGF0ZSAqZXZlcnkqIHN0YWNrZnJhbWVcbiAgICAgIGNvbnN0IHsgYWRkcmVzcywgc2xvdCwgdmFsdWUgfSA9IGFjdGlvbjtcbiAgICAgIGlmIChhZGRyZXNzID09PSBEZWNvZGVVdGlscy5FVk0uWkVST19BRERSRVNTKSB7XG4gICAgICAgIC8vYXMgYWx3YXlzLCB3ZSBkbyBub3QgbWFpbnRhaW4gYSB6ZXJvIHBhZ2VcbiAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgICAgfVxuICAgICAgdG9wQ29kZXggPSBzdGF0ZVtzdGF0ZS5sZW5ndGggLSAxXTtcbiAgICAgIGlmICh0b3BDb2RleC5hY2NvdW50c1thZGRyZXNzXS5zdG9yYWdlW3Nsb3RdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy9pZiB3ZSBhbHJlYWR5IGhhdmUgYSB2YWx1ZSBpbiB0aGUgKnRvcCogc3RhY2tmcmFtZSwgdXBkYXRlICpubypcbiAgICAgICAgLy9zdGFja2ZyYW1lczsgZG9uJ3QgdXBkYXRlIHRoZSB0b3AgKG5vIG5lZWQsIGl0J3MganVzdCBhIGxvYWQsIG5vdCBhXG4gICAgICAgIC8vc3RvcmUpLCBkb24ndCB1cGRhdGUgdGhlIHJlc3QgKHRoYXQgd291bGQgYmUgd3JvbmcsIHlvdSBtaWdodCBiZVxuICAgICAgICAvL2xvYWRpbmcgYSB2YWx1ZSB0aGF0IHdpbGwgZ2V0IHJldmVydGVkIGxhdGVyKVxuICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvL2lmIHdlICpkb24ndCogYWxyZWFkeSBoYXZlIGEgdmFsdWUgaW4gdGhlIHRvcCBzdGFja2ZyYW1lLCB0aGF0IG1lYW5zXG4gICAgICAgIC8vd2UncmUgbG9hZGluZyBhIHZhbHVlIGZyb20gYSBwcmV2aW91cyB0cmFuc2FjdGlvbiEgIFRoYXQncyBub3QgYVxuICAgICAgICAvL3ZhbHVlIHRoYXQgd2lsbCBnZXQgcmV2ZXJ0ZWQgaWYgdGhpcyBjYWxsIGZhaWxzLCBzbyB1cGRhdGUgKmV2ZXJ5KlxuICAgICAgICAvL3N0YWNrZnJhbWVcbiAgICAgICAgcmV0dXJuIHN0YXRlLm1hcChmcmFtZSA9PlxuICAgICAgICAgIHVwZGF0ZUZyYW1lU3RvcmFnZShmcmFtZSwgYWRkcmVzcywgc2xvdCwgdmFsdWUpXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY2FzZSBhY3Rpb25zLlJFVFVSTl9DQUxMOlxuICAgICAgLy93ZSB3YW50IHRvIHBvcCB0aGUgdG9wIHdoaWxlIG1ha2luZyB0aGUgbmV3IHRvcCBhIGNvcHkgb2YgdGhlIG9sZCB0b3A7XG4gICAgICAvL3RoYXQgaXMgdG8gc2F5LCB3ZSB3YW50IHRvIGRyb3AganVzdCB0aGUgZWxlbWVudCAqc2Vjb25kKiBmcm9tIHRoZSB0b3BcbiAgICAgIC8vTk9URTogd2UgZG9uJ3QgZXZlciBnbyBkb3duIHRvIDEgZWxlbWVudCFcbiAgICAgIHJldHVybiBzYWZlU2F2ZShzdGF0ZSk7XG5cbiAgICBjYXNlIGFjdGlvbnMuUkVUVVJOX0NSRUFURToge1xuICAgICAgLy93ZSdyZSBnb2luZyB0byBkbyB0aGUgc2FtZSB0aGluZ3MgaW4gdGhpcyBjYXNlIGFzIGluIHRoZSB1c3VhbCByZXR1cm5cbiAgICAgIC8vY2FzZSwgYnV0IGZpcnN0IHdlIG5lZWQgdG8gcmVjb3JkIHRoZSBjb2RlIHRoYXQgd2FzIHJldHVybmVkXG4gICAgICBjb25zdCB7IGFkZHJlc3MsIGNvZGUsIGNvbnRleHQgfSA9IGFjdGlvbjtcbiAgICAgIG5ld1N0YXRlID0gc3RhdGUuc2xpY2UoKTsgLy9jbG9uZSB0aGUgc3RhdGVcbiAgICAgIC8vTk9URTogc2luY2UgdGhpcyBpcyBvbmx5IGZvciBSRVRVUk5fQ1JFQVRFLCBhbmQgbm90IEZBSUwsIHdlIHNob3VsZG4ndFxuICAgICAgLy9oYXZlIHRvIHdvcnJ5IGFib3V0IGFjY2lkZW50YWxseSBnZXR0aW5nIGEgemVybyBhZGRyZXNzIGhlcmVcbiAgICAgIG5ld1N0YXRlW25ld1N0YXRlLmxlbmd0aCAtIDFdID0gdXBkYXRlRnJhbWVDb2RlKFxuICAgICAgICBuZXdTdGF0ZVtuZXdTdGF0ZS5sZW5ndGggLSAxXSxcbiAgICAgICAgYWRkcmVzcyxcbiAgICAgICAgY29kZSxcbiAgICAgICAgY29udGV4dFxuICAgICAgKTtcbiAgICAgIGRlYnVnKFwibmV3U3RhdGU6ICVPXCIsIG5ld1N0YXRlKTtcbiAgICAgIHJldHVybiBzYWZlU2F2ZShuZXdTdGF0ZSk7XG4gICAgfVxuXG4gICAgY2FzZSBhY3Rpb25zLkZBSUw6XG4gICAgICAvL3BvcCB0aGUgc3RhY2tcbiAgICAgIC8vTk9URTogd2UgZG9uJ3QgZXZlciBnbyBkb3duIHRvIDEgZWxlbWVudCFcbiAgICAgIHJldHVybiBzYWZlUG9wKHN0YXRlKTtcblxuICAgIGNhc2UgYWN0aW9ucy5SRVNFVDpcbiAgICAgIHJldHVybiBbc3RhdGVbMF1dOyAvL2xlYXZlIHRoZSAtMSBmcmFtZSBvbiB0aGUgc3RhY2tcblxuICAgIGNhc2UgYWN0aW9ucy5VTkxPQURfVFJBTlNBQ1RJT046XG4gICAgICByZXR1cm4gREVGQVVMVF9DT0RFWDtcblxuICAgIGNhc2UgYWN0aW9ucy5BRERfSU5TVEFOQ0U6IHtcbiAgICAgIC8vYWRkIHRoZSBpbnN0YW5jZSB0byBldmVyeSBmcmFtZVxuICAgICAgLy8odGhpcyBpcyBhIGxpdHRsZSBIQUNLeSwgYnV0IGl0ICpzaG91bGQqIGJlIGZpbmUpXG4gICAgICBkZWJ1ZyhcImFkZGluZyBpbnN0YW5jZVwiKTtcbiAgICAgIGNvbnN0IHsgYWRkcmVzcywgYmluYXJ5LCBjb250ZXh0IH0gPSBhY3Rpb247XG4gICAgICByZXR1cm4gc3RhdGUubWFwKGZyYW1lID0+XG4gICAgICAgIHVwZGF0ZUZyYW1lQ29kZShmcmFtZSwgYWRkcmVzcywgYmluYXJ5LCBjb250ZXh0KVxuICAgICAgKTtcbiAgICB9XG5cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIHN0YXRlO1xuICB9XG59XG5cbmNvbnN0IHByb2MgPSBjb21iaW5lUmVkdWNlcnMoe1xuICBjYWxsc3RhY2ssXG4gIGNvZGV4XG59KTtcblxuY29uc3QgcmVkdWNlciA9IGNvbWJpbmVSZWR1Y2Vycyh7XG4gIGluZm8sXG4gIHRyYW5zYWN0aW9uLFxuICBwcm9jXG59KTtcblxuZXhwb3J0IGRlZmF1bHQgcmVkdWNlcjtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBsaWIvZXZtL3JlZHVjZXJzLmpzIiwiaW1wb3J0IHsgY29tYmluZVJlZHVjZXJzIH0gZnJvbSBcInJlZHV4XCI7XG5cbmltcG9ydCAqIGFzIGFjdGlvbnMgZnJvbSBcIi4vYWN0aW9uc1wiO1xuXG5jb25zdCBERUZBVUxUX1NPVVJDRVMgPSB7XG4gIGJ5SWQ6IHt9XG59O1xuXG5mdW5jdGlvbiBzb3VyY2VzKHN0YXRlID0gREVGQVVMVF9TT1VSQ0VTLCBhY3Rpb24pIHtcbiAgc3dpdGNoIChhY3Rpb24udHlwZSkge1xuICAgIC8qXG4gICAgICogQWRkaW5nIGEgbmV3IHNvdXJjZVxuICAgICAqL1xuICAgIGNhc2UgYWN0aW9ucy5BRERfU09VUkNFOlxuICAgICAgbGV0IHsgYXN0LCBzb3VyY2UsIHNvdXJjZVBhdGgsIGNvbXBpbGVyIH0gPSBhY3Rpb247XG5cbiAgICAgIGxldCBpZCA9IE9iamVjdC5rZXlzKHN0YXRlLmJ5SWQpLmxlbmd0aDtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYnlJZDoge1xuICAgICAgICAgIC4uLnN0YXRlLmJ5SWQsXG5cbiAgICAgICAgICBbaWRdOiB7XG4gICAgICAgICAgICBpZCxcbiAgICAgICAgICAgIGFzdCxcbiAgICAgICAgICAgIHNvdXJjZSxcbiAgICAgICAgICAgIHNvdXJjZVBhdGgsXG4gICAgICAgICAgICBjb21waWxlclxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgIC8qXG4gICAgICogRGVmYXVsdCBjYXNlXG4gICAgICovXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBzdGF0ZTtcbiAgfVxufVxuXG5jb25zdCBpbmZvID0gY29tYmluZVJlZHVjZXJzKHtcbiAgc291cmNlc1xufSk7XG5cbmZ1bmN0aW9uIGZ1bmN0aW9uRGVwdGhTdGFjayhzdGF0ZSA9IFswXSwgYWN0aW9uKSB7XG4gIHN3aXRjaCAoYWN0aW9uLnR5cGUpIHtcbiAgICBjYXNlIGFjdGlvbnMuSlVNUDpcbiAgICAgIGxldCBuZXdTdGF0ZSA9IHN0YXRlLnNsaWNlKCk7IC8vY2xvbmUgdGhlIHN0YXRlXG4gICAgICBjb25zdCBkZWx0YSA9IHNwZWx1bmsoYWN0aW9uLmp1bXBEaXJlY3Rpb24pO1xuICAgICAgbGV0IHRvcCA9IG5ld1N0YXRlW25ld1N0YXRlLmxlbmd0aCAtIDFdO1xuICAgICAgbmV3U3RhdGVbbmV3U3RhdGUubGVuZ3RoIC0gMV0gPSB0b3AgKyBkZWx0YTtcbiAgICAgIHJldHVybiBuZXdTdGF0ZTtcblxuICAgIGNhc2UgYWN0aW9ucy5SRVNFVDpcbiAgICAgIHJldHVybiBbMF07XG5cbiAgICBjYXNlIGFjdGlvbnMuRVhURVJOQUxfQ0FMTDpcbiAgICAgIHJldHVybiBbLi4uc3RhdGUsIHN0YXRlW3N0YXRlLmxlbmd0aCAtIDFdICsgMV07XG5cbiAgICBjYXNlIGFjdGlvbnMuRVhURVJOQUxfUkVUVVJOOlxuICAgICAgLy9qdXN0IHBvcCB0aGUgc3RhY2shIHVubGVzcywgSEFDSywgdGhhdCB3b3VsZCBsZWF2ZSBpdCBlbXB0eVxuICAgICAgcmV0dXJuIHN0YXRlLmxlbmd0aCA+IDEgPyBzdGF0ZS5zbGljZSgwLCAtMSkgOiBzdGF0ZTtcblxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gc3RhdGU7XG4gIH1cbn1cblxuZnVuY3Rpb24gc3BlbHVuayhqdW1wKSB7XG4gIGlmIChqdW1wID09PSBcImlcIikge1xuICAgIHJldHVybiAxO1xuICB9IGVsc2UgaWYgKGp1bXAgPT09IFwib1wiKSB7XG4gICAgcmV0dXJuIC0xO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiAwO1xuICB9XG59XG5cbmNvbnN0IHByb2MgPSBjb21iaW5lUmVkdWNlcnMoe1xuICBmdW5jdGlvbkRlcHRoU3RhY2tcbn0pO1xuXG5jb25zdCByZWR1Y2VyID0gY29tYmluZVJlZHVjZXJzKHtcbiAgaW5mbyxcbiAgcHJvY1xufSk7XG5cbmV4cG9ydCBkZWZhdWx0IHJlZHVjZXI7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gbGliL3NvbGlkaXR5L3JlZHVjZXJzLmpzIiwiaW1wb3J0IGRlYnVnTW9kdWxlIGZyb20gXCJkZWJ1Z1wiO1xuY29uc3QgZGVidWcgPSBkZWJ1Z01vZHVsZShcImRlYnVnZ2VyOnRyYWNlOnJlZHVjZXJzXCIpO1xuXG5pbXBvcnQgeyBjb21iaW5lUmVkdWNlcnMgfSBmcm9tIFwicmVkdXhcIjtcblxuaW1wb3J0ICogYXMgYWN0aW9ucyBmcm9tIFwiLi9hY3Rpb25zXCI7XG5cbmZ1bmN0aW9uIGluZGV4KHN0YXRlID0gMCwgYWN0aW9uKSB7XG4gIHN3aXRjaCAoYWN0aW9uLnR5cGUpIHtcbiAgICBjYXNlIGFjdGlvbnMuVE9DSzpcbiAgICAgIHJldHVybiBzdGF0ZSArIDE7XG5cbiAgICBjYXNlIGFjdGlvbnMuUkVTRVQ6XG4gICAgY2FzZSBhY3Rpb25zLlVOTE9BRF9UUkFOU0FDVElPTjpcbiAgICAgIHJldHVybiAwO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBzdGF0ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBmaW5pc2hlZChzdGF0ZSA9IGZhbHNlLCBhY3Rpb24pIHtcbiAgc3dpdGNoIChhY3Rpb24udHlwZSkge1xuICAgIGNhc2UgYWN0aW9ucy5FTkRfT0ZfVFJBQ0U6XG4gICAgICByZXR1cm4gdHJ1ZTtcblxuICAgIGNhc2UgYWN0aW9ucy5SRVNFVDpcbiAgICBjYXNlIGFjdGlvbnMuVU5MT0FEX1RSQU5TQUNUSU9OOlxuICAgICAgcmV0dXJuIGZhbHNlO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBzdGF0ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzdGVwcyhzdGF0ZSA9IG51bGwsIGFjdGlvbikge1xuICBzd2l0Y2ggKGFjdGlvbi50eXBlKSB7XG4gICAgY2FzZSBhY3Rpb25zLlNBVkVfU1RFUFM6XG4gICAgICByZXR1cm4gYWN0aW9uLnN0ZXBzO1xuICAgIGNhc2UgYWN0aW9ucy5VTkxPQURfVFJBTlNBQ1RJT046XG4gICAgICBkZWJ1ZyhcInVubG9hZGluZ1wiKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gc3RhdGU7XG4gIH1cbn1cblxuY29uc3QgdHJhbnNhY3Rpb24gPSBjb21iaW5lUmVkdWNlcnMoe1xuICBzdGVwc1xufSk7XG5cbmNvbnN0IHByb2MgPSBjb21iaW5lUmVkdWNlcnMoe1xuICBpbmRleCxcbiAgZmluaXNoZWRcbn0pO1xuXG5jb25zdCByZWR1Y2VyID0gY29tYmluZVJlZHVjZXJzKHtcbiAgdHJhbnNhY3Rpb24sXG4gIHByb2Ncbn0pO1xuXG5leHBvcnQgZGVmYXVsdCByZWR1Y2VyO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIGxpYi90cmFjZS9yZWR1Y2Vycy5qcyIsImltcG9ydCBkZWJ1Z01vZHVsZSBmcm9tIFwiZGVidWdcIjtcbmNvbnN0IGRlYnVnID0gZGVidWdNb2R1bGUoXCJkZWJ1Z2dlcjpjb250cm9sbGVyOnJlZHVjZXJzXCIpO1xuXG5pbXBvcnQgeyBjb21iaW5lUmVkdWNlcnMgfSBmcm9tIFwicmVkdXhcIjtcblxuaW1wb3J0ICogYXMgYWN0aW9ucyBmcm9tIFwiLi9hY3Rpb25zXCI7XG5cbmZ1bmN0aW9uIGJyZWFrcG9pbnRzKHN0YXRlID0gW10sIGFjdGlvbikge1xuICBzd2l0Y2ggKGFjdGlvbi50eXBlKSB7XG4gICAgY2FzZSBhY3Rpb25zLkFERF9CUkVBS1BPSU5UOlxuICAgICAgLy9jaGVjayBmb3IgYW55IGV4aXN0aW5nIGlkZW50aWNhbCBicmVha3BvaW50cyB0byBhdm9pZCByZWR1bmRhbmN5XG4gICAgICBpZiAoXG4gICAgICAgIHN0YXRlLmZpbHRlcihcbiAgICAgICAgICBicmVha3BvaW50ID0+XG4gICAgICAgICAgICBicmVha3BvaW50LnNvdXJjZUlkID09PSBhY3Rpb24uYnJlYWtwb2ludC5zb3VyY2VJZCAmJlxuICAgICAgICAgICAgYnJlYWtwb2ludC5saW5lID09PSBhY3Rpb24uYnJlYWtwb2ludC5saW5lICYmXG4gICAgICAgICAgICBicmVha3BvaW50Lm5vZGUgPT09IGFjdGlvbi5icmVha3BvaW50Lm5vZGUgLy9tYXkgYmUgdW5kZWZpbmVkXG4gICAgICAgICkubGVuZ3RoID4gMFxuICAgICAgKSB7XG4gICAgICAgIC8vaWYgaXQncyBhbHJlYWR5IHRoZXJlLCBkbyBub3RoaW5nXG4gICAgICAgIHJldHVybiBzdGF0ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vb3RoZXJ3aXNlIGFkZCBpdFxuICAgICAgICByZXR1cm4gc3RhdGUuY29uY2F0KFthY3Rpb24uYnJlYWtwb2ludF0pO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIGFjdGlvbnMuUkVNT1ZFX0JSRUFLUE9JTlQ6XG4gICAgICByZXR1cm4gc3RhdGUuZmlsdGVyKFxuICAgICAgICBicmVha3BvaW50ID0+XG4gICAgICAgICAgYnJlYWtwb2ludC5zb3VyY2VJZCAhPT0gYWN0aW9uLmJyZWFrcG9pbnQuc291cmNlSWQgfHxcbiAgICAgICAgICBicmVha3BvaW50LmxpbmUgIT09IGFjdGlvbi5icmVha3BvaW50LmxpbmUgfHxcbiAgICAgICAgICBicmVha3BvaW50Lm5vZGUgIT09IGFjdGlvbi5icmVha3BvaW50Lm5vZGUgLy9tYXkgYmUgdW5kZWZpbmVkXG4gICAgICApO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIGFjdGlvbnMuUkVNT1ZFX0FMTF9CUkVBS1BPSU5UUzpcbiAgICAgIHJldHVybiBbXTtcblxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gc3RhdGU7XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNTdGVwcGluZyhzdGF0ZSA9IGZhbHNlLCBhY3Rpb24pIHtcbiAgc3dpdGNoIChhY3Rpb24udHlwZSkge1xuICAgIGNhc2UgYWN0aW9ucy5TVEFSVF9TVEVQUElORzpcbiAgICAgIGRlYnVnKFwiZ290IHN0ZXAgc3RhcnQgYWN0aW9uXCIpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgY2FzZSBhY3Rpb25zLkRPTkVfU1RFUFBJTkc6XG4gICAgICBkZWJ1ZyhcImdvdCBzdGVwIHN0b3AgYWN0aW9uXCIpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gc3RhdGU7XG4gIH1cbn1cblxuY29uc3QgcmVkdWNlciA9IGNvbWJpbmVSZWR1Y2Vycyh7XG4gIGJyZWFrcG9pbnRzLFxuICBpc1N0ZXBwaW5nXG59KTtcblxuZXhwb3J0IGRlZmF1bHQgcmVkdWNlcjtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBsaWIvY29udHJvbGxlci9yZWR1Y2Vycy5qcyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUM3REE7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDS0E7QUFRQTtBQVlBO0FBZUE7QUFPQTtBQVFBO0FBUUE7QUFTQTtBQVFBO0FBUUE7QUFRQTtBQVFBO0FBU0E7QUFTQTtBQUNBO0FBM0hBO0FBQ0E7QUFEQTtBQUNBOzs7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUM5SEE7Ozs7OztBQ0FBOzs7Ozs7QUNBQTs7Ozs7O0FDQUE7Ozs7OztBQ0FBOzs7Ozs7QUNBQTs7Ozs7O0FDQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNBQTtBQUNBOzs7QUFFQTtBQUNBO0FBQUE7QUFDQTs7O0FBQ0E7QUFDQTs7O0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFBQTtBQUNBOzs7OztBQVRBO0FBQ0E7QUFpQkE7Ozs7QUFJQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFJQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFHQTs7Ozs7QUFLQTtBQUNBO0FBR0E7OztBQUdBO0FBQ0E7QUFHQTs7O0FBR0E7QUFDQTtBQUNBOzs7Ozs7OztBQVFBO0FBQ0E7QUFHQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFsR0E7QUFDQTtBQXVHQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7O0FBS0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7QUFLQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7QUFLQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FBTUE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7OztBQVFBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQW5KQTtBQXNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7Ozs7OztBQU1BO0FBUEE7QUFUQTtBQUNBO0FBcUJBOzs7QUFHQTtBQUNBOzs7QUFHQTtBQUNBOzs7QUFHQTtBQUNBOzs7QUFHQTtBQVJBO0FBQ0E7QUFVQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQXZCQTtBQUNBO0FBeUJBOzs7QUFHQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFLQTs7O0FBR0E7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBTUE7QUFDQTtBQUNBO0FBRUE7Ozs7O0FBS0E7QUFHQTtBQURBO0FBQ0E7QUFJQTs7O0FBR0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7O0FBTUE7QUFDQTtBQUlBOzs7O0FBSUE7QUFDQTtBQUlBOzs7QUFHQTtBQVFBO0FBR0E7QUFYQTtBQUNBO0FBYUE7Ozs7OztBQU1BO0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQW5GQTtBQUNBO0FBc0ZBOzs7QUFHQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBOzs7Ozs7O0FBT0E7QUFHQTtBQUNBO0FBSUE7OztBQUdBO0FBS0E7QUFEQTtBQTdCQTtBQXJLQTtBQUNBO0FBME1BOzs7QUFHQTtBQUNBOzs7OztBQUtBO0FBR0E7QUFEQTtBQUNBO0FBSUE7OztBQUdBO0FBaEJBO0FBQ0E7QUFrQkE7OztBQUdBO0FBQ0E7Ozs7O0FBS0E7QUFHQTtBQURBO0FBUkE7QUFuU0E7QUFDQTtBQWlUQTs7Ozs7Ozs7Ozs7OztBQ3RsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFWQTtBQUNBO0FBWUE7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUlBOzs7OztBQUtBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBSUE7Ozs7O0FBS0E7QUFBQTtBQUNBO0FBSUE7Ozs7Ozs7QUFPQTtBQUNBO0FBS0E7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBL0VBO0FBQ0E7QUFpRkE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNqR0E7QUFDQTs7O0FBRUE7QUFDQTtBQUFBO0FBQ0E7OztBQUFBO0FBQ0E7OztBQUNBO0FBQ0E7QUFBQTtBQUNBOzs7QUFDQTtBQUNBOzs7QUFBQTtBQUNBOzs7OztBQVhBO0FBQ0E7QUFXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFGQTtBQUxBO0FBSEE7QUFjQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7O0FBR0E7QUFDQTtBQUtBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFLQTs7O0FBR0E7QUF4Q0E7QUE4Q0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7O0FBR0E7QUFKQTtBQUNBO0FBTUE7OztBQUdBO0FBQ0E7OztBQUdBO0FBQUE7QUFDQTtBQUtBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFJQTs7O0FBR0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUdBO0FBREE7QUFNQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBRkE7QUFMQTtBQUNBO0FBVUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVBBO0FBU0E7QUFDQTtBQUNBO0FBRUE7OztBQUdBO0FBT0E7QUFEQTtBQUNBO0FBNUlBO0FBQ0E7QUFrSkE7OztBQUdBO0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFFQTs7O0FBR0E7QUFRQTtBQUNBO0FBSkE7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBREE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVhBO0FBREE7QUFlQTtBQUNBO0FBR0E7OztBQUdBO0FBQ0E7QUFLQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBSUE7OztBQUdBO0FBQ0E7QUFJQTs7O0FBR0E7QUFDQTtBQUNBOzs7Ozs7O0FBT0E7QUF2U0E7QUFDQTtBQTZTQTs7Ozs7QUFLQTtBQXRVQTtBQUNBO0FBd1VBOzs7Ozs7Ozs7Ozs7QUN4WkE7QUFRQTtBQUtBO0FBS0E7QUFLQTtBQUtBO0FBS0E7QUFLQTtBQXZDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDN0JBO0FBOENBO0FBSUE7QUEwQkE7QUFJQTtBQUlBO0FBQ0E7QUFqR0E7QUFDQTs7O0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQVZBO0FBQ0E7QUFVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFPQTtBQUVBO0FBQ0E7QUFFQTtBQVZBO0FBQ0E7QUFpQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ25HQTtBQVNBO0FBUUE7QUFLQTtBQU9BO0FBT0E7QUFPQTtBQVFBO0FBT0E7QUFTQTtBQVFBO0FBUUE7QUFwRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBOzs7Ozs7QUN6RkE7Ozs7OztBQ0FBOzs7Ozs7Ozs7Ozs7Ozs7OztBQzRCQTtBQUlBO0FBSUE7QUFZQTtBQThoQkE7QUFJQTtBQXFGQTtBQUNBO0FBeHFCQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBREE7QUFDQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBQUE7QUFDQTtBQURBO0FBQ0E7QUFBQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQUE7QUFDQTtBQU9BO0FBQ0E7Ozs7Ozs7QUExQkE7QUFDQTtBQTBCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFUQTtBQUNBO0FBV0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQTNCQTtBQTZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBSEE7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBRkE7QUFEQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFPQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBcENBO0FBc0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUEE7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQWpCQTtBQW1CQTtBQUNBO0FBQ0E7QUFDQTtBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBellBO0FBMllBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFEQTtBQU1BO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFNQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FDM3FCQTs7Ozs7O0FDQUE7Ozs7Ozs7Ozs7OztBQ0NBO0FBS0E7QUFLQTtBQUtBO0FBS0E7QUFLQTtBQUtBO0FBS0E7QUFTQTtBQVFBO0FBUUE7QUFPQTtBQU9BO0FBM0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDL0VBO0FBQ0E7OztBQUVBO0FBQ0E7QUFBQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQUE7QUFDQTs7O0FBQ0E7QUFDQTtBQURBO0FBQ0E7Ozs7O0FBWEE7QUFDQTtBQVdBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFSQTtBQVVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQVZBO0FBWUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU5BO0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFOQTtBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7O0FBR0E7QUFDQTtBQUlBOzs7QUFHQTtBQUNBOzs7QUFHQTtBQUNBOzs7O0FBSUE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7OztBQUdBO0FBT0E7QUFDQTtBQUVBO0FBSEE7QUFEQTtBQXpCQTtBQUpBO0FBQ0E7QUEyQ0E7OztBQUdBO0FBQ0E7Ozs7QUFJQTtBQUxBO0FBQ0E7QUFhQTs7O0FBR0E7QUFDQTtBQVFBOzs7QUFHQTtBQUNBO0FBV0E7Ozs7QUFJQTtBQUNBO0FBR0E7Ozs7O0FBS0E7QUFJQTtBQURBO0FBQ0E7QUFLQTs7Ozs7Ozs7Ozs7QUFXQTtBQU1BO0FBREE7QUExSUE7QUFDQTtBQWdKQTs7O0FBR0E7QUFDQTs7O0FBR0E7QUFDQTs7Ozs7OztBQU9BO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBSUE7QUFDQTtBQUhBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTs7O0FBR0E7QUF2REE7QUFDQTtBQXlEQTs7O0FBR0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBZEE7QUFDQTtBQWdCQTs7O0FBR0E7QUFyRkE7QUFDQTtBQTBGQTs7O0FBR0E7QUFDQTs7O0FBR0E7QUFHQTtBQUNBO0FBSkE7QUFDQTtBQU1BOzs7QUFHQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFyQkE7QUFDQTtBQTBCQTs7O0FBR0E7QUFDQTs7O0FBR0E7QUFDQTs7O0FBR0E7QUFDQTtBQUtBOzs7QUFHQTtBQUNBO0FBS0E7OztBQUdBO0FBQ0E7QUFLQTs7O0FBR0E7QUFPQTtBQURBO0FBQ0E7QUFLQTs7Ozs7O0FBTUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFOQTtBQVdBO0FBREE7QUFRQTtBQURBO0FBcEVBO0FBQ0E7QUEyRUE7OztBQUdBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7OztBQUlBO0FBQ0E7QUFDQTs7Ozs7O0FBTUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBSUE7OztBQUdBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQWFBO0FBVUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7QUFHQTtBQUdBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7QUFLQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7O0FBS0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7QUFHQTtBQUNBOzs7Ozs7QUFNQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBO0FBQ0E7QUFPQTtBQUNBO0FBQ0E7QUFFQTs7O0FBR0E7QUFDQTs7O0FBR0E7QUFJQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7OztBQUtBO0FBdkNBO0FBQ0E7QUFrREE7Ozs7O0FBS0E7QUFLQTtBQUpBO0FBWUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUE5SkE7QUFoUkE7QUFDQTtBQW9iQTs7O0FBR0E7QUFDQTs7Ozs7QUFLQTtBQUNBOzs7QUFHQTtBQUpBO0FBQ0E7QUFVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7OztBQUdBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFuRUE7QUFDQTtBQXFFQTs7O0FBR0E7QUFDQTs7Ozs7OztBQU9BO0FBQ0E7OztBQUdBO0FBSkE7QUFSQTtBQXZ4QkE7QUFDQTtBQTh5QkE7Ozs7OztBQzkzQkE7Ozs7Ozs7Ozs7OztBQ2tCQTtBQVdBO0FBVUE7QUFVQTtBQTRCQTtBQStFQTtBQU1BO0FBSUE7QUFDQTtBQXZLQTtBQUNBOzs7QUFFQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7QUFEQTtBQUNBOzs7OztBQVhBO0FBQ0E7QUFXQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVRBO0FBV0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7OztBQzFLQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQUE7QUFDQTs7O0FBQUE7QUFDQTs7O0FBQ0E7QUFDQTs7O0FBVEE7QUFDQTtBQVNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7OztBQUdBO0FBQ0E7OztBQUdBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7OztBQUdBO0FBQ0E7QUFJQTs7O0FBR0E7QUFDQTtBQUlBOzs7QUFHQTtBQUNBO0FBSUE7OztBQUdBO0FBNUJBO0FBQ0E7QUFpQ0E7OztBQUdBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFUQTtBQXhEQTtBQUNBO0FBb0VBOzs7QUFHQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQWhEQTtBQUNBO0FBa0RBOzs7O0FBSUE7QUFDQTtBQUNBOzs7QUFHQTtBQTVJQTtBQUNBO0FBOElBOzs7Ozs7Ozs7Ozs7Ozs7OztBQ3hKQTtBQWNBO0FBOEJBO0FBa0JBO0FBYUE7QUFDQTtBQXRGQTtBQUNBOzs7QUFFQTtBQUNBOzs7QUFBQTtBQUNBOzs7QUFBQTtBQUNBOzs7QUFMQTtBQUNBO0FBS0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBR0E7QUFFQTtBQUNBO0FBTkE7QUFRQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDL0ZBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFBQTtBQUNBOzs7QUFBQTtBQUNBOzs7OztBQVBBO0FBQ0E7QUFPQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7OztBQUdBO0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFEQTtBQU9BO0FBaENBO0FBQ0E7QUFxQ0E7OztBQUdBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQWpCQTtBQUNBO0FBbUJBOzs7QUFHQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFJQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBSUE7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFsREE7QUF6RUE7QUFDQTtBQWlJQTs7Ozs7Ozs7Ozs7O0FDMUlBO0FBV0E7QUFRQTtBQVFBO0FBa0JBO0FBS0E7QUFRQTtBQTNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTEE7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFOQTtBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFNQTs7Ozs7O0FDbEVBOzs7Ozs7Ozs7Ozs7QUNDQTtBQXdCQTtBQUtBO0FBVUE7QUFVQTtBQVFBO0FBWUE7QUFXQTtBQU9BO0FBVUE7QUFPQTtBQVVBO0FBVUE7QUFRQTtBQXJJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVJBO0FBVUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFUQTtBQVdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFOQTtBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTEE7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7Ozs7Ozs7Ozs7OztBQ3pDQTtBQTBDQTtBQXVCQTtBQUlBO0FBQ0E7QUF0S0E7QUFDQTs7O0FBRUE7QUFDQTtBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQUE7QUFDQTs7O0FBQUE7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FBckJBO0FBQ0E7QUFDQTtBQW9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTEE7QUFDQTtBQU9BO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUkE7QUFXQTtBQUNBO0FBR0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVBBO0FBVUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVRBO0FBV0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFWQTtBQVlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQzlLQTs7Ozs7O0FDQUE7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDeUJBO0FBa09BO0FBQ0E7QUE1UEE7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBQUE7QUFDQTtBQURBO0FBQ0E7QUFBQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQWRBO0FBQ0E7QUFjQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU5BO0FBQ0E7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFJQTtBQUNBO0FBRUE7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUUE7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUFZQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ3BQQTtBQWlDQTtBQUlBO0FBQ0E7QUFsREE7QUFDQTs7O0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUFWQTtBQUNBO0FBVUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUNwREE7QUFXQTtBQVFBO0FBS0E7QUFLQTtBQTlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTEE7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNoQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBTEE7QUFDQTtBQUtBOzs7QUFHQTtBQUNBOzs7QUFHQTtBQUNBOzs7QUFHQTtBQUpBO0FBSkE7QUFDQTtBQVdBOzs7Ozs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ0hBO0FBQ0E7OztBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFBQTtBQUNBOzs7QUFBQTtBQUNBOzs7QUFBQTtBQUNBOzs7QUFBQTtBQUNBOzs7QUFBQTtBQUNBOzs7QUFBQTtBQUNBOzs7OztBQWRBO0FBQ0E7QUFDQTtBQWFBOzs7Ozs7Ozs7QUFTQTtBQUNBOzs7O0FBSUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUFPQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBbEJBO0FBbUJBO0FBQ0E7QUFDQTs7Ozs7O0FBTUE7QUFBQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQVhBO0FBWUE7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7O0FBY0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUEE7QUFTQTtBQTdGQTtBQUNBO0FBREE7Ozs7Ozs7Ozs7Ozs7Ozs7QUN6QkE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDQUE7QUFDQTs7O0FBRUE7QUFDQTs7O0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFBQTtBQUNBO0FBREE7QUFDQTtBQUFBO0FBQ0E7OztBQUFBO0FBQ0E7OztBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBQUE7QUFDQTtBQURBO0FBQ0E7QUFBQTtBQUNBO0FBREE7QUFDQTtBQUFBO0FBQ0E7OztBQUVBO0FBQ0E7Ozs7Ozs7QUFmQTtBQUNBO0FBZUE7OztBQUdBO0FBQ0E7Ozs7Ozs7QUFPQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQURBO0FBQ0E7QUFEQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBekJBO0FBMEJBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FBWUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVZBO0FBQ0E7QUFZQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUkE7QUFVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFSQTtBQVVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBSUE7QUFDQTtBQUNBOzs7Ozs7QUFNQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBREE7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBRkE7QUFHQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQW5CQTtBQW9CQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVRBO0FBVUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFOQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQURBO0FBQ0E7QUFEQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBREE7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBREE7QUFDQTtBQURBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQURBO0FBQ0E7QUFEQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBREE7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTEE7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBREE7QUFDQTtBQURBO0FBSUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQURBO0FBQ0E7QUFEQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBREE7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBREE7QUFDQTtBQURBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBREE7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBS0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBaEJBO0FBaUJBO0FBcFRBO0FBQUE7Ozs7OztBQ3BCQTs7Ozs7Ozs7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNOQTtBQUNBOzs7OztBQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNPQTtBQXFDQTtBQUNBO0FBOUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFBQTtBQUNBOzs7QUFBQTtBQUNBOzs7OztBQU5BO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUZBO0FBSUE7QUFQQTtBQUNBO0FBU0E7QUFDQTtBQU1BO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUM3RUE7Ozs7OztBQ0FBOzs7Ozs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNuRkE7QUFDQTs7Ozs7OztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ2hSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ3pKQTs7Ozs7O0FDQUE7Ozs7Ozs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQ25zQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUM1Q0E7QUFRQTtBQVFBO0FBU0E7QUFTQTtBQVFBO0FBMEJBO0FBckVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFUQTtBQVdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFWQTtBQVlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTs7Ozs7Ozs7Ozs7Ozs7Ozs7QUMxRUE7QUFDQTs7O0FBRUE7QUFDQTs7O0FBQUE7QUFDQTs7O0FBSkE7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFmQTtBQWdCQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBREE7QUFDQTtBQURBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQURBO0FBQ0E7QUFEQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBREE7QUFFQTtBQUNBO0FBQ0E7Ozs7OztBQU1BO0FBQUE7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFJQTtBQTdDQTtBQUFBOzs7Ozs7QUNOQTs7Ozs7O0FDQUE7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDb0NBO0FBNENBO0FBMkZBO0FBQ0E7QUE1S0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBQUE7QUFDQTtBQURBO0FBQ0E7QUFBQTtBQUNBO0FBREE7QUFDQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBQUE7QUFDQTtBQURBO0FBQ0E7QUFBQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBOzs7OztBQWZBO0FBQ0E7QUFlQTtBQUNBO0FBQ0E7QUFGQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFGQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7OztBQzlIQTtBQUNBO0FBM0RBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUFQQTtBQUNBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFUQTtBQVdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3BFQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQUE7QUFDQTs7O0FBQUE7QUFDQTs7O0FBQUE7QUFDQTs7O0FBQUE7QUFDQTs7O0FBQ0E7QUFDQTtBQURBO0FBQ0E7Ozs7O0FBWEE7QUFDQTtBQVdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFUQTtBQVdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBVEE7QUFXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU5BO0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFOQTtBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTkE7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFOQTtBQUNBO0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFOQTtBQUNBO0FBUUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDckdBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTs7Ozs7QUFUQTtBQUNBO0FBU0E7QUFDQTtBQURBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBTkE7QUFIQTtBQURBO0FBQ0E7QUFjQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUhBO0FBSEE7QUFEQTtBQUNBO0FBZUE7QUFDQTtBQXhDQTtBQTBDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBQ0E7QUFLQTtBQUFBO0FBQ0E7QUFPQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQURBO0FBUkE7QUFDQTtBQWFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBRkE7QUFJQTtBQUVBO0FBQ0E7QUFIQTtBQU5BO0FBWUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUEzQkE7QUE2QkE7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFEQTtBQUZBO0FBRkE7QUFDQTtBQVdBO0FBQ0E7QUFFQTtBQUNBO0FBR0E7QUFEQTtBQUhBO0FBRkE7QUFDQTtBQVlBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFPQTtBQUNBO0FBQ0E7QUFFQTtBQUZBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQXZHQTtBQXlHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUZBO0FBQ0E7QUFJQTs7Ozs7Ozs7Ozs7Ozs7Ozs7QUMzUkE7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQVRBO0FBQ0E7QUFTQTtBQUNBO0FBREE7QUFDQTtBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFSQTtBQVVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFWQTtBQUZBO0FBRkE7QUFDQTtBQWtCQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBR0E7OztBQUdBO0FBQ0E7QUFyREE7QUF1REE7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBRkE7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVBBO0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBO0FBQ0E7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTkE7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFOQTtBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQWRBO0FBZ0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBMUJBO0FBNEJBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFGQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBRUE7QUFFQTtBQUZBO0FBRkE7QUFGQTtBQUZBO0FBQ0E7QUFhQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBRUE7QUFDQTtBQUhBO0FBRkE7QUFGQTtBQVdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQUZBO0FBRkE7QUFZQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFuSUE7QUFxSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBQ0E7QUFLQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDM1hBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTs7Ozs7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBO0FBSEE7QUFEQTtBQUNBO0FBYUE7OztBQUdBO0FBQ0E7QUEzQkE7QUE2QkE7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBbkJBO0FBcUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBRkE7QUFDQTtBQUlBOzs7Ozs7Ozs7Ozs7O0FDdkZBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTs7Ozs7QUFMQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVRBO0FBV0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFUQTtBQVdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFQQTtBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUZBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFGQTtBQUNBO0FBSUE7Ozs7Ozs7Ozs7Ozs7QUM3REE7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBOzs7OztBQUxBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFoQ0E7QUFrQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUkE7QUFVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFDQTtBQUlBOzs7O0EiLCJzb3VyY2VSb290IjoiIn0=