"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const debug_1 = __importDefault(require("debug"));
const debug = debug_1.default("decode-utils:values");
//objects for Solidity values
//Note: This is NOT intended to represent every possible value that exists
//in Solidity!  Only possible values of variables.  (Though there may be
//some expansion in the future.)  We do however count the builtin variables
//msg, block, and tx as variables (not other builtins though for now) so
//there is some support for the magic type.
//We don't include fixed and ufixed for now.  Those will be added when
//implemented.
//NOTE: not all of these optional fields are actually implemented. Some are
//just intended for the future.  More optional fields may be added in the
//future.
//Note: Many of the errors defined here deliberately *don't* extend Error.
//This is because their intended use is a little different.  Only the ones
//that are for throwing extend Error.
const bn_js_1 = __importDefault(require("bn.js"));
const types_1 = require("./types");
const util_1 = __importDefault(require("util"));
const definition_1 = require("./definition");
var Values;
(function (Values) {
    /*
     * SECTION 0: Some irrelevant stuff for dealing with util.inspect.custom.
     * You can probably ignore these.
     */
    //HACK -- inspect options are ridiculous, I swear >_>
    function cleanStylize(options) {
        return Object.assign({}, ...Object.entries(options).map(([key, value]) => key === "stylize"
            ? {}
            : { [key]: value }));
    }
    ;
    //A ValueProper encodes an actual value, not an error.  HOWEVER, if it is a
    //container type (Array, Struct, or Mapping), it is still possible for some
    //of the individual values within it to be errors!
    //The exact type of the value field depends on the type of the Value; don't
    //worry, the more specific types will have more specific type annotations.
    class ValueProper extends Value {
    }
    Values.ValueProper = ValueProper;
    ;
    //A ValueError, on the other hand, encodes an error.  Rather than a value field,
    //it has an error field, of type ValueErrorDirect.
    //See section 2 regarding the toSoliditySha3Input method.
    class ValueError extends Value {
        [util_1.default.inspect.custom](depth, options) {
            return util_1.default.inspect(this.error, options);
        }
        toSoliditySha3Input() {
            return undefined; //will cause an error! should not occur!
        }
        nativize() {
            return undefined;
        }
    }
    Values.ValueError = ValueError;
    ;
    //in fact, here's a subclass of ValueError just for holding those generic errors.
    class GenericError extends ValueError {
        constructor(error) {
            super();
            this.error = error;
        }
    }
    Values.GenericError = GenericError;
    //and here's the type definition for those errors themselves
    //See section 8 for the actual generic errors.
    class GenericErrorDirect {
        [util_1.default.inspect.custom](depth, options) {
            return this.message();
        }
    }
    Values.GenericErrorDirect = GenericErrorDirect;
    //Finally, for when we need to throw an error, here's a wrapper class that extends Error.
    //Apologies about the confusing name, but I wanted something that would make
    //sense should it not be caught and thus accidentally exposed to the outside.
    class DecodingError extends Error {
        constructor(error) {
            super(error.message());
            this.error = error;
            this.name = "DecodingError";
        }
    }
    Values.DecodingError = DecodingError;
    //However, here's a class representing *proper* elementary values.
    //A key thing about elementary values is that they can be used as mapping keys,
    //and so they have a method that gives what input to soliditySha3() they correspond
    //to.  Note that errors, above, also have this method, but for them it just
    //returns undefined.
    class ElementaryValueProper extends ValueProper {
        toString() {
            return this.value.toString();
        }
    }
    Values.ElementaryValueProper = ElementaryValueProper;
    class UintValueProper extends ElementaryValueProper {
        constructor(uintType, value) {
            super();
            this.type = uintType;
            this.value = value;
        }
        [util_1.default.inspect.custom](depth, options) {
            return options.stylize(this.value.toString(), "number");
        }
        toSoliditySha3Input() {
            return {
                type: "uint",
                value: this.value
            };
        }
        nativize() {
            return this.value.toNumber(); //beware!
        }
    }
    Values.UintValueProper = UintValueProper;
    class IntValueProper extends ElementaryValueProper {
        constructor(intType, value) {
            super();
            this.type = intType;
            this.value = value;
        }
        [util_1.default.inspect.custom](depth, options) {
            return options.stylize(this.value.toString(), "number");
        }
        toSoliditySha3Input() {
            return {
                type: "int",
                value: this.value
            };
        }
        nativize() {
            return this.value.toNumber(); //beware!
        }
    }
    Values.IntValueProper = IntValueProper;
    class BoolValueProper extends ElementaryValueProper {
        constructor(boolType, value) {
            super();
            this.type = boolType;
            this.value = value;
        }
        [util_1.default.inspect.custom](depth, options) {
            return util_1.default.inspect(this.value, options);
        }
        toSoliditySha3Input() {
            return {
                type: "uint",
                value: this.value ? new bn_js_1.default(1) : new bn_js_1.default(0) //true & false won't work here
            };
        }
        nativize() {
            return this.value;
        }
    }
    Values.BoolValueProper = BoolValueProper;
    //errors for bools
    class BoolValueError extends ValueError {
        constructor(boolType, error) {
            super();
            this.type = boolType;
            this.error = error;
        }
    }
    Values.BoolValueError = BoolValueError;
    class BoolDecodingError {
    }
    Values.BoolDecodingError = BoolDecodingError;
    class BoolOutOfRangeError extends BoolDecodingError {
        constructor(raw) {
            super();
            this.raw = raw;
        }
        [util_1.default.inspect.custom](depth, options) {
            return `Invalid boolean (numeric value ${this.raw.toString()})`;
        }
    }
    Values.BoolOutOfRangeError = BoolOutOfRangeError;
    class BytesValueProper extends ElementaryValueProper {
        constructor(bytesType, value) {
            super();
            this.type = bytesType;
            this.value = value;
        }
        [util_1.default.inspect.custom](depth, options) {
            switch (this.type.kind) {
                case "static":
                    return options.stylize(this.value, "number");
                case "dynamic":
                    return options.stylize(`hex'${this.value.slice(2)}'`, "string");
            }
        }
        toSoliditySha3Input() {
            switch (this.type.kind) {
                case "static":
                    return {
                        type: "bytes32",
                        value: this.value
                    };
                case "dynamic":
                    return {
                        type: "bytes",
                        value: this.value
                    };
            }
        }
        nativize() {
            return this.value;
        }
    }
    Values.BytesValueProper = BytesValueProper;
    class AddressValueProper extends ElementaryValueProper {
        constructor(addressType, value) {
            super();
            this.type = addressType;
            this.value = value;
        }
        [util_1.default.inspect.custom](depth, options) {
            return options.stylize(this.value, "number");
        }
        toSoliditySha3Input() {
            return {
                type: "uint",
                value: this.value
            };
        }
        nativize() {
            return this.value;
        }
    }
    Values.AddressValueProper = AddressValueProper;
    class StringValueProper extends ElementaryValueProper {
        constructor(stringType, value) {
            super();
            this.type = stringType;
            this.value = value;
        }
        [util_1.default.inspect.custom](depth, options) {
            return util_1.default.inspect(this.value, options);
        }
        toSoliditySha3Input() {
            return {
                type: "string",
                value: this.value
            };
        }
        nativize() {
            return this.value;
        }
    }
    Values.StringValueProper = StringValueProper;
    class FixedValueError extends ValueError {
        constructor(dataType, raw) {
            super();
            this.type = dataType;
            this.error = new FixedDecodingError(raw);
        }
    }
    Values.FixedValueError = FixedValueError;
    class UfixedValueError extends ValueError {
        constructor(dataType, raw) {
            super();
            this.type = dataType;
            this.error = new FixedDecodingError(raw);
        }
    }
    Values.UfixedValueError = UfixedValueError;
    //not distinguishing fixed vs ufixed here
    class FixedDecodingError {
        constructor(raw) {
            this.raw = raw;
        }
        [util_1.default.inspect.custom](depth, options) {
            return `Fixed-point decoding not yet supported (raw value: ${this.raw.toString()})`;
        }
    }
    Values.FixedDecodingError = FixedDecodingError;
    //Function for wrapping a value as an ElementaryValueProper
    //WARNING: this function does not check its inputs! Please check before using!
    //How to use:
    //numbers may be BN, number, or numeric string
    //strings should be given as strings. duh.
    //bytes should be given as hex strings beginning with "0x"
    //addresses are like bytes; checksum case is not required
    //booleans may be given either as booleans, or as string "true" or "false"
    function wrapElementaryValue(value, definition) {
        let dataType = types_1.Types.definitionToType(definition, null); //force location to undefined
        switch (dataType.typeClass) {
            case "string":
                return new StringValueProper(dataType, value);
            case "bytes":
                return new BytesValueProper(dataType, value);
            case "address":
                return new AddressValueProper(dataType, value);
            case "int":
                if (value instanceof bn_js_1.default) {
                    value = value.clone();
                }
                else {
                    value = new bn_js_1.default(value);
                }
                return new IntValueProper(dataType, value);
            case "uint":
                if (value instanceof bn_js_1.default) {
                    value = value.clone();
                }
                else {
                    value = new bn_js_1.default(value);
                }
                return new UintValueProper(dataType, value);
            case "bool":
                if (typeof value === "string") {
                    value = value !== "false";
                }
                return new BoolValueProper(dataType, value);
        }
    }
    Values.wrapElementaryValue = wrapElementaryValue;
    /*
     * SECTION 3: CONTAINER TYPES (including magic)
     */
    //this function will be used in the future for displaying circular
    //structures
    function formatCircular(loopLength, options) {
        return options.stylize(`[Circular (=up ${this.loopLength})]`, "special");
    }
    class ArrayValueProper extends ValueProper {
        constructor(arrayType, value, reference) {
            super();
            this.type = arrayType;
            this.value = value;
            this.reference = reference;
        }
        [util_1.default.inspect.custom](depth, options) {
            if (this.reference !== undefined) {
                return formatCircular(this.reference, options);
            }
            return util_1.default.inspect(this.value, options);
        }
        nativize() {
            return this.value.map(element => element.nativize());
        }
    }
    Values.ArrayValueProper = ArrayValueProper;
    class MappingValueProper extends ValueProper {
        constructor(mappingType, value) {
            super();
            this.type = mappingType;
            this.value = value;
        }
        [util_1.default.inspect.custom](depth, options) {
            return util_1.default.inspect(new Map(this.value), options);
        }
        nativize() {
            //if only I could use Object.fromEntries() here!
            return Object.assign({}, ...this.value.map(([key, value]) => ({ [key.toString()]: value.nativize() })));
        }
    }
    Values.MappingValueProper = MappingValueProper;
    class StructValueProper extends ValueProper {
        constructor(structType, value, reference) {
            super();
            this.type = structType;
            this.value = value;
            this.reference = reference;
        }
        [util_1.default.inspect.custom](depth, options) {
            if (this.reference !== undefined) {
                return formatCircular(this.reference, options);
            }
            return util_1.default.inspect(this.value, options);
        }
        nativize() {
            return Object.assign({}, ...Object.entries(this.value).map(([key, value]) => ({ [key]: value.nativize() })));
        }
    }
    Values.StructValueProper = StructValueProper;
    class MagicValueProper extends ValueProper {
        constructor(magicType, value) {
            super();
            this.type = magicType;
            this.value = value;
        }
        [util_1.default.inspect.custom](depth, options) {
            return util_1.default.inspect(this.value, options);
        }
        nativize() {
            return Object.assign({}, ...Object.entries(this.value).map(([key, value]) => ({ [key]: value.nativize() })));
        }
    }
    Values.MagicValueProper = MagicValueProper;
    class EnumValueProper extends ValueProper {
        constructor(enumType, numeric, name) {
            super();
            this.type = enumType;
            this.value = { name, numeric };
        }
        fullName() {
            return `${this.type.definingContractName}.${this.type.typeName}.${this.value.name}`;
        }
        [util_1.default.inspect.custom](depth, options) {
            return this.fullName();
        }
        nativize() {
            return this.fullName();
        }
    }
    Values.EnumValueProper = EnumValueProper;
    ;
    //Enum errors
    class EnumValueError extends ValueError {
        constructor(enumType, error) {
            super();
            this.type = enumType;
            this.error = error;
        }
    }
    Values.EnumValueError = EnumValueError;
    ;
    class EnumDecodingError {
    }
    Values.EnumDecodingError = EnumDecodingError;
    class EnumOutOfRangeError extends EnumDecodingError {
        constructor(enumType, raw) {
            super();
            this.type = enumType;
            this.raw = raw;
        }
        [util_1.default.inspect.custom](depth, options) {
            let typeName = this.type.definingContractName + "." + this.type.typeName;
            return `Invalid ${typeName} (numeric value ${this.raw.toString()})`;
        }
    }
    Values.EnumOutOfRangeError = EnumOutOfRangeError;
    class EnumNotFoundDecodingError extends EnumDecodingError {
        constructor(enumType, raw) {
            super();
            this.type = enumType;
            this.raw = raw;
        }
        [util_1.default.inspect.custom](depth, options) {
            let typeName = this.type.definingContractName + "." + this.type.typeName;
            return `Unknown enum type ${typeName} of id ${this.type.id} (numeric value ${this.raw.toString()})`;
        }
    }
    Values.EnumNotFoundDecodingError = EnumNotFoundDecodingError;
    //Contract values have a special new type as their value: ContractValueDirect.
    class ContractValueProper extends ValueProper {
        constructor(contractType, value) {
            super();
            this.type = contractType;
            this.value = value;
        }
        [util_1.default.inspect.custom](depth, options) {
            return util_1.default.inspect(this.value, options);
        }
        nativize() {
            return this.value.nativize();
        }
    }
    Values.ContractValueProper = ContractValueProper;
    //when we can identify the class
    class ContractValueDirectKnown {
        constructor(address, contractClass) {
            this.kind = "known";
            this.address = address;
            this.class = contractClass;
        }
        //may have more optional members defined later, but I'll leave these out for now
        [util_1.default.inspect.custom](depth, options) {
            return options.stylize(this.address, "number") + ` (${this.class.typeName})`;
        }
        nativize() {
            return `${this.class.typeName}(${this.address})`;
        }
    }
    Values.ContractValueDirectKnown = ContractValueDirectKnown;
    //when we can't
    class ContractValueDirectUnknown {
        constructor(address) {
            this.kind = "unknown";
            this.address = address;
        }
        [util_1.default.inspect.custom](depth, options) {
            debug("options: %O", options);
            return options.stylize(this.address, "number") + " of unknown class";
        }
        nativize() {
            return this.address;
        }
    }
    Values.ContractValueDirectUnknown = ContractValueDirectUnknown;
    //known function of known class
    class FunctionValueExternalProperKnown extends ValueProper {
        constructor(functionType, contract, selector, name) {
            super();
            this.type = functionType;
            this.value = { contract, selector, name, kind: "known" };
        }
        [util_1.default.inspect.custom](depth, options) {
            //first, let's inspect that contract, but w/o color
            let contractString = util_1.default.inspect(this.value.contract, Object.assign({}, cleanStylize(options), { colors: false }));
            let firstLine = `[Function: ${this.value.name} of`;
            let secondLine = `${contractString}]`;
            let breakingSpace = firstLine.length >= options.breakLength ? "\n" : " ";
            //now, put it together
            return options.stylize(firstLine + breakingSpace + secondLine, "special");
        }
        nativize() {
            return `${this.value.contract.nativize()}.${this.value.name}`;
        }
    }
    Values.FunctionValueExternalProperKnown = FunctionValueExternalProperKnown;
    //known class but can't locate function
    class FunctionValueExternalProperInvalid extends ValueProper {
        constructor(functionType, contract, selector) {
            super();
            this.type = functionType;
            this.value = { contract, selector, kind: "invalid" };
        }
        [util_1.default.inspect.custom](depth, options) {
            //first, let's inspect that contract, but w/o color
            let contractString = util_1.default.inspect(this.value.contract, Object.assign({}, cleanStylize(options), { colors: false }));
            let selectorString = `Unknown selector 0x${this.value.selector}`;
            let firstLine = `[Function: ${selectorString} of`;
            let secondLine = `${contractString}]`;
            let breakingSpace = firstLine.length >= options.breakLength ? "\n" : " ";
            //now, put it together
            return options.stylize(firstLine + breakingSpace + secondLine, "special");
        }
        nativize() {
            return `${this.value.contract.nativize()}.call(${this.value.selector}...)`;
        }
    }
    Values.FunctionValueExternalProperInvalid = FunctionValueExternalProperInvalid;
    //can't even locate class
    class FunctionValueExternalProperUnknown extends ValueProper {
        constructor(functionType, contract, selector) {
            super();
            this.type = functionType;
            this.value = { contract, selector, kind: "unknown" };
        }
        [util_1.default.inspect.custom](depth, options) {
            //first, let's inspect that contract, but w/o color
            let contractString = util_1.default.inspect(this.value.contract, Object.assign({}, cleanStylize(options), { colors: false }));
            let selectorString = `Unknown selector 0x${this.value.selector}`;
            let firstLine = `[Function: ${selectorString} of`;
            let secondLine = `${contractString}]`;
            let breakingSpace = firstLine.length >= options.breakLength ? "\n" : " ";
            //now, put it together
            return options.stylize(firstLine + breakingSpace + secondLine, "special");
        }
        nativize() {
            return `${this.value.contract.nativize()}.call(${this.value.selector}...)`;
        }
    }
    Values.FunctionValueExternalProperUnknown = FunctionValueExternalProperUnknown;
    //actual function
    class FunctionValueInternalProperKnown extends ValueProper {
        constructor(functionType, context, deployedProgramCounter, constructorProgramCounter, name, definedIn) {
            super();
            this.type = functionType;
            this.value = {
                context,
                deployedProgramCounter,
                constructorProgramCounter,
                name,
                definedIn,
                kind: "function"
            };
        }
        [util_1.default.inspect.custom](depth, options) {
            return options.stylize(`[Function: ${this.value.definedIn.typeName}.${this.value.name}]`, "special");
        }
        nativize() {
            return `${this.value.definedIn.typeName}.${this.value.name}`;
        }
    }
    Values.FunctionValueInternalProperKnown = FunctionValueInternalProperKnown;
    //default value
    class FunctionValueInternalProperException extends ValueProper {
        constructor(functionType, context, deployedProgramCounter, constructorProgramCounter) {
            super();
            this.type = functionType;
            this.value = { context, deployedProgramCounter, constructorProgramCounter, kind: "exception" };
        }
        [util_1.default.inspect.custom](depth, options) {
            return this.value.deployedProgramCounter === 0
                ? options.stylize(`[Function: <zero>]`, "special")
                : options.stylize(`[Function: assert(false)]`, "special");
        }
        nativize() {
            return this.value.deployedProgramCounter === 0
                ? `<zero>`
                : `assert(false)`;
        }
    }
    Values.FunctionValueInternalProperException = FunctionValueInternalProperException;
    //value returned to indicate that decoding is not supported outside the debugger
    class FunctionValueInternalProperUnknown extends ValueProper {
        constructor(functionType, context, deployedProgramCounter, constructorProgramCounter) {
            super();
            this.type = functionType;
            this.value = { context, deployedProgramCounter, constructorProgramCounter, kind: "unknown" };
        }
        [util_1.default.inspect.custom](depth, options) {
            return options.stylize(`[Function: decoding not supported (raw info: deployed PC=${this.value.deployedProgramCounter}, constructor PC=${this.value.constructorProgramCounter})]`, "special");
        }
        nativize() {
            return `<decoding not supported>`;
        }
    }
    Values.FunctionValueInternalProperUnknown = FunctionValueInternalProperUnknown;
    //Internal function errors
    class FunctionValueInternalError extends ValueError {
        constructor(functionType, error) {
            super();
            this.type = functionType;
            this.error = error;
        }
    }
    Values.FunctionValueInternalError = FunctionValueInternalError;
    class FunctionInternalDecodingError {
    }
    Values.FunctionInternalDecodingError = FunctionInternalDecodingError;
    class NoSuchInternalFunctionError extends FunctionInternalDecodingError {
        constructor(context, deployedProgramCounter, constructorProgramCounter) {
            super();
            this.context = context;
            this.deployedProgramCounter = deployedProgramCounter;
            this.constructorProgramCounter = constructorProgramCounter;
        }
        [util_1.default.inspect.custom](depth, options) {
            return `Invalid function (Deployed PC=${this.deployedProgramCounter}, constructor PC=${this.constructorProgramCounter}) of contract ${this.context.typeName}`;
        }
    }
    Values.NoSuchInternalFunctionError = NoSuchInternalFunctionError;
    class DeployedFunctionInConstructorError extends FunctionInternalDecodingError {
        constructor(context, deployedProgramCounter) {
            super();
            this.context = context;
            this.deployedProgramCounter = deployedProgramCounter;
            this.constructorProgramCounter = 0;
        }
        [util_1.default.inspect.custom](depth, options) {
            return `Deployed-style function (PC=${this.deployedProgramCounter}) in constructor`;
        }
    }
    Values.DeployedFunctionInConstructorError = DeployedFunctionInConstructorError;
    class MalformedInternalFunctionError extends FunctionInternalDecodingError {
        constructor(context, constructorProgramCounter) {
            super();
            this.context = context;
            this.deployedProgramCounter = 0;
            this.constructorProgramCounter = constructorProgramCounter;
        }
        [util_1.default.inspect.custom](depth, options) {
            return `Malformed internal function w/constructor PC only (value: ${this.constructorProgramCounter})`;
        }
    }
    Values.MalformedInternalFunctionError = MalformedInternalFunctionError;
    /*
     * SECTION 8: GENERIC ERRORS
     */
    //type-location error
    class UserDefinedTypeNotFoundError extends GenericErrorDirect {
        constructor(unknownType) {
            super();
            this.type = unknownType;
        }
        message() {
            let typeName = types_1.Types.isContractDefinedType(this.type)
                ? this.type.definingContractName + "." + this.type.typeName
                : this.type.typeName;
            return `Unknown ${this.type.typeClass} type ${typeName} of id ${this.type.id}`;
        }
    }
    Values.UserDefinedTypeNotFoundError = UserDefinedTypeNotFoundError;
    //Read errors
    class UnsupportedConstantError extends GenericErrorDirect {
        constructor(definition) {
            super();
            this.definition = definition;
        }
        message() {
            return `Unsupported constant type ${definition_1.Definition.typeClass(this.definition)}$`;
        }
    }
    Values.UnsupportedConstantError = UnsupportedConstantError;
    class ReadErrorStack extends GenericErrorDirect {
        constructor(from, to) {
            super();
            this.from = from;
            this.to = to;
        }
        message() {
            return `Can't read stack from position ${this.from} to ${this.to}`;
        }
    }
    Values.ReadErrorStack = ReadErrorStack;
})(Values = exports.Values || (exports.Values = {}));
//# sourceMappingURL=values.js.map