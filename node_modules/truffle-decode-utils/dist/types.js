"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const debug_1 = __importDefault(require("debug"));
const debug = debug_1.default("decode-utils:types");
//type objects for Solidity types
//these will just be defined as interfaces; there's not any particular need for
//classes here (at least for now)
//Note: This is NOT intended to represent every possible type representable by
//a Solidity type identifier!  Only possible types of variables, not of all
//possible values.  (Though there may be some expansion in the future.)
//We do however count the builtin variables msg, block, and tx as variables
//(not other builtins though for now) so there is some support for the magic
//type.
//We do include fixed and ufixed, even though these aren't implemented yet;
//note though that values.ts does not include these.
//NOTE: not all of these optional fields are actually implemented. Some are
//just intended for the future.
const bn_js_1 = __importDefault(require("bn.js"));
const definition_1 = require("./definition");
var Types;
(function (Types) {
    ;
    //NOTE: the following function will *not* work for arbitrary nodes! It will,
    //however, work for the ones we need (i.e., variable definitions, and arbitrary
    //things of elementary type)
    //NOTE: set forceLocation to *null* to force no location. leave it undefined
    //to not force a location.
    function definitionToType(definition, forceLocation) {
        debug("definition %O", definition);
        let typeClass = definition_1.Definition.typeClass(definition);
        switch (typeClass) {
            case "bool":
                return {
                    typeClass
                };
            case "address": {
                let payable = definition_1.Definition.isAddressPayable(definition);
                return {
                    typeClass,
                    payable
                };
            }
            case "uint": {
                let bytes = definition_1.Definition.specifiedSize(definition);
                return {
                    typeClass,
                    bits: bytes * 8
                };
            }
            case "int": { //typeScript won't let me group these for some reason
                let bytes = definition_1.Definition.specifiedSize(definition);
                return {
                    typeClass,
                    bits: bytes * 8
                };
            }
            case "fixed": { //typeScript won't let me group these for some reason
                let bytes = definition_1.Definition.specifiedSize(definition);
                let places = definition_1.Definition.decimalPlaces(definition);
                return {
                    typeClass,
                    bits: bytes * 8,
                    places
                };
            }
            case "ufixed": {
                let bytes = definition_1.Definition.specifiedSize(definition);
                let places = definition_1.Definition.decimalPlaces(definition);
                return {
                    typeClass,
                    bits: bytes * 8,
                    places
                };
            }
            case "string": {
                if (forceLocation === null) {
                    return {
                        typeClass
                    };
                }
                let location = forceLocation || definition_1.Definition.referenceType(definition);
                return {
                    typeClass,
                    location
                };
            }
            case "bytes": {
                let length = definition_1.Definition.specifiedSize(definition);
                if (length !== null) {
                    return {
                        typeClass,
                        kind: "static",
                        length
                    };
                }
                else {
                    if (forceLocation === null) {
                        return {
                            typeClass,
                            kind: "dynamic"
                        };
                    }
                    let location = forceLocation || definition_1.Definition.referenceType(definition);
                    return {
                        typeClass,
                        kind: "dynamic",
                        location
                    };
                }
            }
            case "array": {
                let baseDefinition = definition_1.Definition.baseDefinition(definition);
                let baseType = definitionToType(baseDefinition, forceLocation);
                let location = forceLocation || definition_1.Definition.referenceType(definition);
                if (definition_1.Definition.isDynamicArray(definition)) {
                    if (forceLocation !== null) {
                        return {
                            typeClass,
                            baseType,
                            kind: "dynamic",
                            location
                        };
                    }
                    else {
                        return {
                            typeClass,
                            baseType,
                            kind: "dynamic"
                        };
                    }
                }
                else {
                    let length = new bn_js_1.default(definition_1.Definition.staticLengthAsString(definition));
                    if (forceLocation !== null) {
                        return {
                            typeClass,
                            baseType,
                            kind: "static",
                            length,
                            location
                        };
                    }
                    else {
                        return {
                            typeClass,
                            baseType,
                            kind: "static",
                            length
                        };
                    }
                }
            }
            case "mapping": {
                let keyDefinition = definition_1.Definition.keyDefinition(definition);
                //note that we can skip the scopes argument here! that's only needed when
                //a general node, rather than a declaration, is being passed in
                let keyType = definitionToType(keyDefinition, null);
                //suppress the location on the key type (it'll be given as memory but
                //this is meaningless)
                //also, we have to tell TypeScript ourselves that this will be an elementary
                //type; it has no way of knowing that
                let valueDefinition = definition.valueType || definition.typeName.valueType;
                let valueType = definitionToType(valueDefinition, forceLocation);
                if (forceLocation === null) {
                    return {
                        typeClass,
                        keyType,
                        valueType
                    };
                }
                return {
                    typeClass,
                    keyType,
                    valueType,
                    location: "storage"
                };
            }
            case "function": {
                let visibility = definition_1.Definition.visibility(definition);
                let mutability = definition.stateMutability || definition.typeName.stateMutability;
                let [inputParameters, outputParameters] = definition_1.Definition.parameters(definition);
                //In JS I could just write `let x = y.map(definitionToType)`, but that won't work
                //in TypeScript
                //note: don't force a location on these! use the listed location!
                let inputParameterTypes = inputParameters.map(parameter => definitionToType(parameter));
                let outputParameterTypes = outputParameters.map(parameter => definitionToType(parameter));
                return {
                    typeClass,
                    visibility,
                    mutability,
                    inputParameterTypes,
                    outputParameterTypes
                };
            }
            case "struct": {
                let id = definition_1.Definition.typeId(definition);
                let qualifiedName = definition.typeName
                    ? definition.typeName.name
                    : definition.name;
                let [definingContractName, typeName] = qualifiedName.split(".");
                if (forceLocation === null) {
                    return {
                        typeClass,
                        id,
                        typeName,
                        definingContractName
                    };
                }
                let location = forceLocation || definition_1.Definition.referenceType(definition);
                return {
                    typeClass,
                    id,
                    typeName,
                    definingContractName,
                    location
                };
            }
            case "enum": {
                let id = definition_1.Definition.typeId(definition);
                let qualifiedName = definition.typeName
                    ? definition.typeName.name
                    : definition.name;
                let [definingContractName, typeName] = qualifiedName.split(".");
                return {
                    typeClass,
                    id,
                    typeName,
                    definingContractName
                };
            }
            case "contract": {
                let id = definition_1.Definition.typeId(definition);
                let typeName = definition.typeName
                    ? definition.typeName.name
                    : definition.name;
                let contractKind = definition_1.Definition.contractKind(definition);
                return {
                    typeClass,
                    id,
                    typeName,
                    contractKind
                };
            }
            case "magic": {
                let typeIdentifier = definition_1.Definition.typeIdentifier(definition);
                let variable = typeIdentifier.match(/^t_magic_(.*)$/)[1];
                return {
                    typeClass,
                    variable
                };
            }
        }
    }
    Types.definitionToType = definitionToType;
    //whereas the above takes variable definitions, this takes the actual type
    //definition
    function definitionToStoredType(definition) {
        switch (definition.nodeType) {
            case "StructDefinition": {
                let id = definition.id;
                let [definingContractName, typeName] = definition.canonicalName.split(".");
                let memberTypes = Object.assign({}, ...definition.members.map(member => ({ [member.name]: definitionToType(member, null) })));
                return {
                    typeClass: "struct",
                    id,
                    typeName,
                    definingContractName,
                    memberTypes
                };
            }
            case "EnumDefinition": {
                let id = definition.id;
                let [definingContractName, typeName] = definition.canonicalName.split(".");
                let options = definition.members.map(member => member.name);
                return {
                    typeClass: "enum",
                    id,
                    typeName,
                    definingContractName,
                    options
                };
            }
            case "ContractDefinition": {
                let id = definition.id;
                let typeName = definition.name;
                let contractKind = definition.contractKind;
                let payable = definition_1.Definition.isContractPayable(definition);
                return {
                    typeClass: "contract",
                    id,
                    typeName,
                    contractKind,
                    payable
                };
            }
        }
    }
    Types.definitionToStoredType = definitionToStoredType;
    function definitionsToStoredTypes(definitions) {
        return Object.assign({}, ...Object.entries(definitions).map(([id, definition]) => ({ [id]: definitionToStoredType(definition) })));
    }
    Types.definitionsToStoredTypes = definitionsToStoredTypes;
    //one could define a counterpart function that stripped all unnecessary information
    //from the type object, but at the moment I see no need for that
    function fullType(basicType, userDefinedTypes) {
        if (!isUserDefinedType(basicType)) {
            return basicType;
        }
        let id = basicType.id;
        let storedType = userDefinedTypes[id];
        if (!storedType) {
            return basicType;
        }
        let returnType = Object.assign({}, basicType, storedType);
        if (isReferenceType(basicType) && basicType.location !== undefined) {
            returnType = specifyLocation(returnType, basicType.location);
        }
        if (isContractDefinedType(returnType)) {
            let contractName = returnType.typeName;
            returnType.definingContract = Object.values(userDefinedTypes).find(storedType => storedType.typeClass === "contract"
                && storedType.typeName === contractName);
        }
        return returnType;
    }
    Types.fullType = fullType;
    function isUserDefinedType(anyType) {
        const userDefinedTypes = ["contract", "enum", "struct"];
        return userDefinedTypes.includes(anyType.typeClass);
    }
    Types.isUserDefinedType = isUserDefinedType;
    function isContractDefinedType(anyType) {
        const contractDefinedTypes = ["enum", "struct"];
        return contractDefinedTypes.includes(anyType.typeClass);
    }
    Types.isContractDefinedType = isContractDefinedType;
    function isReferenceType(anyType) {
        const alwaysReferenceTypes = ["array", "mapping", "struct", "string"];
        if (alwaysReferenceTypes.includes(anyType.typeClass)) {
            return true;
        }
        else if (anyType.typeClass === "bytes") {
            return anyType.kind === "dynamic";
        }
        else {
            return false;
        }
    }
    Types.isReferenceType = isReferenceType;
    //the location argument here always forces, so passing undefined *will* force undefined
    function specifyLocation(dataType, location) {
        if (isReferenceType(dataType)) {
            switch (dataType.typeClass) {
                case "string":
                case "bytes":
                    return Object.assign({}, dataType, { location });
                case "array":
                    return Object.assign({}, dataType, { location, baseType: specifyLocation(dataType.baseType, location) });
                case "mapping":
                    return Object.assign({}, dataType, { location, valueType: specifyLocation(dataType.valueType, location) });
                case "struct":
                    let returnType = Object.assign({}, dataType, { location });
                    if (returnType.memberTypes) {
                        for (let name in returnType.memberTypes) {
                            returnType.memberTypes[name] = specifyLocation(returnType.memberTypes[name], location);
                        }
                    }
                    return returnType;
            }
        }
        else {
            return dataType;
        }
    }
    Types.specifyLocation = specifyLocation;
})(Types = exports.Types || (exports.Types = {}));
//# sourceMappingURL=types.js.map