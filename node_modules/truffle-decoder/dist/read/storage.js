"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const debug_1 = __importDefault(require("debug"));
const debug = debug_1.default("decoder:read:storage");
const DecodeUtils = __importStar(require("truffle-decode-utils"));
const bn_js_1 = __importDefault(require("bn.js"));
/**
 * convert a slot to a word corresponding to actual storage address
 *
 * if `slot` is an array, return hash of array values.
 * if `slot` array is nested, recurse on sub-arrays
 *
 * @param slot - number or possibly-nested array of numbers
 */
function slotAddress(slot) {
    if (slot.key !== undefined && slot.path !== undefined) {
        // mapping reference
        let key = slot.key;
        let keyEncoding = slot.keyEncoding;
        if (keyEncoding === undefined) { //HACK: booleans must be handled manually
            key = key ? new bn_js_1.default(1) : new bn_js_1.default(0);
            keyEncoding = "uint";
        }
        return DecodeUtils.EVM.keccak256({ type: keyEncoding, value: key }, slotAddress(slot.path)).add(slot.offset);
    }
    else if (slot.path !== undefined) {
        const pathAddress = slotAddress(slot.path);
        const path = slot.hashPath ? DecodeUtils.EVM.keccak256(pathAddress) : pathAddress;
        return path.add(slot.offset);
    }
    else {
        return slot.offset;
    }
}
exports.slotAddress = slotAddress;
function slotAddressPrintout(slot) {
    if (slot.key !== undefined && slot.path !== undefined) {
        // mapping reference
        let keyEncoding = slot.keyEncoding ? slot.keyEncoding : "uint"; //HACK for booleans
        return "keccak(" + slot.key + " as " + keyEncoding + ", " + slotAddressPrintout(slot.path) + ") + " + slot.offset.toString();
    }
    else if (slot.path !== undefined) {
        const pathAddressPrintout = slotAddressPrintout(slot.path);
        return slot.hashPath
            ? "keccak(" + pathAddressPrintout + ")" + slot.offset.toString()
            : pathAddressPrintout + slot.offset.toString();
    }
    else {
        return slot.offset.toString();
    }
}
exports.slotAddressPrintout = slotAddressPrintout;
/**
 * read slot from storage
 *
 * @param slot - see slotAddress() code to understand how these work
 * @param offset - for array, offset from the keccak determined location
 */
function* read(storage, slot) {
    debug("Slot printout: %s", slotAddressPrintout(slot));
    const address = slotAddress(slot);
    // debug("reading slot: %o", DecodeUtils.toHexString(address));
    const hexAddress = DecodeUtils.Conversion.toHexString(address, DecodeUtils.EVM.WORD_SIZE);
    let word = storage[hexAddress];
    //if we can't find the word in the map, we place a request to the invoker to supply it
    //(contract-decoder will look it up from the blockchain, while the debugger will just
    //say 0)
    if (word === undefined) {
        word = yield {
            type: "storage",
            slot: address
        };
    }
    return word;
}
exports.read = read;
/**
 * read all bytes in some range.
 *
 * parameters `from` and `to` are objects with the following properties:
 *
 *   slot - see the slotAddress() code to understand how these work
 *
 *     ref: https://solidity.readthedocs.io/en/v0.4.23/miscellaneous.html#layout-of-state-variables-in-storage
 *     (search "concatenation")
 *
 *  index - (default: 0) byte index in word
 *
 * @param from - location (see ^)
 * @param to - location (see ^). inclusive.
 * @param length - instead of `to`, number of bytes after `from`
 */
function* readRange(storage, range) {
    // debug("readRange %o", range);
    let { from, to, length } = range;
    if (typeof length === "undefined" && !to || length && to) {
        throw new Error("must specify exactly one `to`|`length`");
    }
    from = {
        slot: from.slot,
        index: from.index || 0
    };
    if (typeof length !== "undefined") {
        to = {
            slot: {
                path: from.slot.path || undefined,
                offset: from.slot.offset.addn(Math.floor((from.index + length - 1) / DecodeUtils.EVM.WORD_SIZE))
            },
            index: (from.index + length - 1) % DecodeUtils.EVM.WORD_SIZE
        };
    }
    else {
        to = {
            slot: to.slot,
            index: to.index
        };
    }
    // debug("normalized readRange %o", {from,to});
    let totalWords = to.slot.offset.sub(from.slot.offset).addn(1);
    if (totalWords.bitLength() > 53) {
        throw new Error("must specify range that is less than 53 bits");
    }
    totalWords = totalWords.toNumber();
    // debug("totalWords %o", totalWords);
    let data = new Uint8Array(totalWords * DecodeUtils.EVM.WORD_SIZE);
    for (let i = 0; i < totalWords; i++) {
        let offset = from.slot.offset.addn(i);
        const word = yield* read(storage, Object.assign({}, from.slot, { offset }));
        if (typeof word !== "undefined") {
            data.set(word, i * DecodeUtils.EVM.WORD_SIZE);
        }
    }
    // debug("words %o", data);
    data = data.slice(from.index, (totalWords - 1) * DecodeUtils.EVM.WORD_SIZE + to.index + 1);
    // debug("data: %o", data);
    return data;
}
exports.readRange = readRange;
//# sourceMappingURL=storage.js.map