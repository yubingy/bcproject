"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const debug_1 = __importDefault(require("debug"));
const debug = debug_1.default("decoder:interface:contract-decoder");
const DecodeUtils = __importStar(require("truffle-decode-utils"));
const async_eventemitter_1 = __importDefault(require("async-eventemitter"));
const web3_1 = __importDefault(require("web3"));
const bn_js_1 = __importDefault(require("bn.js"));
const general = __importStar(require("../allocate/general"));
const storage = __importStar(require("../allocate/storage"));
const pointer_1 = require("../types/pointer");
const storage_1 = require("../types/storage");
const request_1 = require("../types/request");
const errors_1 = require("../types/errors");
const decode_1 = __importDefault(require("../decode"));
const truffle_decode_utils_1 = require("truffle-decode-utils");
const abi_decoder_1 = __importDefault(require("abi-decoder"));
const lodash_isequal_1 = __importDefault(require("lodash.isequal")); //util.isDeepStrictEqual doesn't exist in Node 8
;
;
;
;
;
;
;
//note: may return undefined
function getContractNode(contract) {
    return (contract.ast || { nodes: [] }).nodes.find((contractNode) => contractNode.nodeType === "ContractDefinition"
        && (contractNode.name === contract.contractName
            || contractNode.name === contract.contract_name));
}
class TruffleContractDecoder extends async_eventemitter_1.default {
    constructor(contract, relevantContracts, provider, address) {
        super();
        this.contracts = {};
        this.contractNodes = {};
        this.contexts = {};
        this.mappingKeys = [];
        this.storageCache = {};
        this.codeCache = {};
        this.web3 = new web3_1.default(provider);
        this.contract = contract;
        this.relevantContracts = relevantContracts;
        if (address !== undefined) {
            this.contractAddress = address;
        }
        this.contractNode = getContractNode(this.contract);
        if (this.contractNode === undefined) {
            throw new errors_1.ContractBeingDecodedHasNoNodeError();
        }
        this.contracts[this.contractNode.id] = this.contract;
        this.contractNodes[this.contractNode.id] = this.contractNode;
        if (this.contract.deployedBinary) { //just to be safe
            this.context = this.makeContext(this.contract, this.contractNode);
            this.contexts[this.contractNode.id] = this.context;
        }
        abi_decoder_1.default.addABI(this.contract.abi);
        for (let relevantContract of this.relevantContracts) {
            abi_decoder_1.default.addABI(relevantContract.abi);
            let node = getContractNode(relevantContract);
            if (node !== undefined) {
                this.contracts[node.id] = relevantContract;
                this.contractNodes[node.id] = node;
                if (relevantContract.deployedBinary) {
                    this.contexts[node.id] = this.makeContext(relevantContract, node);
                }
            }
        }
        this.contexts = DecodeUtils.Contexts.normalizeContexts(this.contexts);
    }
    makeContext(contract, node) {
        //we want the non-constructor context here
        return {
            contractName: contract.contractName,
            binary: contract.deployedBytecode,
            contractId: node.id,
            contractKind: node.contractKind,
            isConstructor: false,
            abi: DecodeUtils.Contexts.abiToFunctionAbiWithSignatures(contract.abi)
        };
    }
    init() {
        return __awaiter(this, void 0, void 0, function* () {
            this.contractNetwork = (yield this.web3.eth.net.getId()).toString();
            if (this.contractAddress === undefined) {
                this.contractAddress = this.contract.networks[this.contractNetwork].address;
            }
            debug("init called");
            this.referenceDeclarations = general.getReferenceDeclarations(Object.values(this.contractNodes));
            this.eventDefinitions = general.getEventDefinitions(Object.values(this.contractNodes));
            this.eventDefinitionIdsByName = {};
            for (let id in this.eventDefinitions) {
                this.eventDefinitionIdsByName[this.eventDefinitions[id].name] = parseInt(id);
                //this parseInt shouldn't be necessary, but TypeScript refuses to believe
                //that id must be a number even though the definition of AstReferences
                //says so
            }
            debug("done with event definitions");
            this.storageAllocations = storage.getStorageAllocations(this.referenceDeclarations, { [this.contractNode.id]: this.contractNode });
            debug("done with allocation");
            this.stateVariableReferences = this.storageAllocations[this.contractNode.id].members;
            debug("stateVariableReferences %O", this.stateVariableReferences);
            this.contractCode = yield this.web3.eth.getCode(this.contractAddress);
        });
    }
    decodeVariable(variable, block) {
        return __awaiter(this, void 0, void 0, function* () {
            const info = {
                state: {
                    stack: [],
                    storage: {},
                    memory: new Uint8Array(0)
                },
                mappingKeys: this.mappingKeys,
                referenceDeclarations: this.referenceDeclarations,
                storageAllocations: this.storageAllocations,
                contexts: this.contexts,
                currentContext: this.context
            };
            const decoder = decode_1.default(variable.definition, variable.pointer, info);
            let result = decoder.next();
            while (!result.done) {
                let request = (result.value);
                let response;
                if (request_1.isStorageRequest(request)) {
                    response = yield this.getStorage(this.contractAddress, request.slot, block);
                }
                else if (request_1.isCodeRequest(request)) {
                    response = yield this.getCode(request.address, block);
                }
                //note: one of the above conditionals *must* be true by the type system.
                result = decoder.next(response);
            }
            //at this point, result.value holds the final value
            return {
                name: variable.definition.name,
                type: truffle_decode_utils_1.Definition.typeClass(variable.definition),
                value: result.value
            };
        });
    }
    state(block = "latest") {
        return __awaiter(this, void 0, void 0, function* () {
            let blockNumber = typeof block === "number"
                ? block
                : (yield this.web3.eth.getBlock(block)).number;
            let result = {
                name: this.contract.contractName,
                code: this.contractCode,
                balance: new bn_js_1.default(yield this.web3.eth.getBalance(this.contractAddress, blockNumber)),
                nonce: new bn_js_1.default(yield this.web3.eth.getTransactionCount(this.contractAddress, blockNumber)),
                variables: {}
            };
            debug("state called");
            for (const variable of Object.values(this.stateVariableReferences)) {
                debug("about to decode %s", variable.definition.name);
                const decodedVariable = yield this.decodeVariable(variable, blockNumber);
                debug("decoded");
                result.variables[variable.definition.name] = decodedVariable;
                debug("var %O", result.variables[variable.definition.name]);
            }
            return result;
        });
    }
    variable(nameOrId, block = "latest") {
        return __awaiter(this, void 0, void 0, function* () {
            let blockNumber = typeof block === "number"
                ? block
                : (yield this.web3.eth.getBlock(block)).number;
            let variable;
            if (typeof nameOrId === "number") {
                variable = this.stateVariableReferences[nameOrId];
            }
            else { //search by name
                variable = Object.values(this.stateVariableReferences)
                    .find(({ definition }) => definition.name === nameOrId); //there should be exactly one
            }
            if (variable === undefined) { //if user put in a bad name
                return undefined;
            }
            return yield this.decodeVariable(variable, blockNumber);
        });
    }
    getStorage(address, slot, block) {
        return __awaiter(this, void 0, void 0, function* () {
            //first, set up any preliminary layers as needed
            if (this.storageCache[block] === undefined) {
                this.storageCache[block] = {};
            }
            if (this.storageCache[block][address] === undefined) {
                this.storageCache[block][address] = {};
            }
            //now, if we have it cached, just return it
            if (this.storageCache[block][address][slot.toString()] !== undefined) {
                return this.storageCache[block][address][slot.toString()];
            }
            //otherwise, get it, cache it, and return it
            let word = DecodeUtils.Conversion.toBytes(yield this.web3.eth.getStorageAt(address, slot, block), DecodeUtils.EVM.WORD_SIZE);
            this.storageCache[block][address][slot.toString()] = word;
            return word;
        });
    }
    getCode(address, block) {
        return __awaiter(this, void 0, void 0, function* () {
            //first, set up any preliminary layers as needed
            if (this.codeCache[block] === undefined) {
                this.codeCache[block] = {};
            }
            //now, if we have it cached, just return it
            if (this.codeCache[block][address] !== undefined) {
                return this.codeCache[block][address];
            }
            //otherwise, get it, cache it, and return it
            let code = DecodeUtils.Conversion.toBytes(yield this.web3.eth.getCode(address, block));
            this.codeCache[block][address] = code;
            return code;
        });
    }
    //EXAMPLE: to watch a.b.c[d][e], use watchMappingKey("a", "b", "c", d, e)
    //(this will watch all ancestors too, or at least ones given by mapping keys)
    //feel free to mix arrays, mappings, and structs here!
    //see the comment on constructSlot for more detail on what forms are accepted
    watchMappingKey(variable, ...indices) {
        let slot = this.constructSlot(variable, ...indices)[0];
        //add mapping key and all ancestors
        while (slot !== undefined &&
            this.mappingKeys.every(existingSlot => !lodash_isequal_1.default(existingSlot, slot)
            //we put the newness requirement in the while condition rather than a
            //separate if because if we hit one ancestor that's not new, the futher
            //ones won't be either
            )) {
            if (slot.key !== undefined) { //only add mapping keys
                this.mappingKeys = [...this.mappingKeys, slot];
            }
            slot = slot.path;
        }
    }
    //input is similar to watchMappingKey; will unwatch all descendants too
    unwatchMappingKey(variable, ...indices) {
        let slot = this.constructSlot(variable, ...indices)[0];
        if (slot === undefined) {
            return; //not strictly necessary, but may as well
        }
        //remove mapping key and all descendants
        this.mappingKeys = this.mappingKeys.filter(existingSlot => {
            while (existingSlot !== undefined) {
                if (lodash_isequal_1.default(existingSlot, slot)) {
                    return false; //if it matches, remove it
                }
                existingSlot = existingSlot.path;
            }
            return true; //if we didn't match, keep the key
        });
    }
    //NOTE: if you decide to add a way to remove a mapping key *without* removing
    //all descendants, you'll need to alter watchMappingKey to use an if rather
    //than a while
    decodeTransaction(transaction) {
        const decodedData = abi_decoder_1.default.decodeMethod(transaction.input);
        return decodedData;
    }
    decodeLog(log) {
        const decodedLogs = this.decodeLogs([log]);
        return decodedLogs[0];
    }
    decodeLogs(logs) {
        const decodedLogs = abi_decoder_1.default.decodeLogs(logs);
        return decodedLogs;
    }
    decodeEvent(event) {
        let contractEvent = {
            logIndex: event.logIndex,
            name: event.event,
            blockHash: event.blockHash,
            blockNumber: event.blockNumber,
            transactionHash: event.transactionHash,
            transactionIndex: event.transactionIndex,
            variables: {}
        };
        const eventDefinition = this.eventDefinitions[this.eventDefinitionIdsByName[contractEvent.name]];
        if (typeof eventDefinition.parameters !== "undefined" && typeof eventDefinition.parameters.parameters !== "undefined") {
            const argumentDefinitions = eventDefinition.parameters.parameters;
            for (let i = 0; i < argumentDefinitions.length; i++) {
                const definition = argumentDefinitions[i];
                if (definition.nodeType === "VariableDeclaration") {
                    contractEvent.variables[definition.name] = {
                        name: definition.name,
                        type: truffle_decode_utils_1.Definition.typeClass(definition),
                        value: event.returnValues[definition.name] // TODO: this should be a decoded value, it currently is a string always
                    };
                }
            }
        }
        return contractEvent;
    }
    events(name = null, block = "latest") {
        return __awaiter(this, void 0, void 0, function* () {
            const web3Contract = new this.web3.eth.Contract(this.contract.abi, this.contractAddress);
            const events = yield web3Contract.getPastEvents(name, {
                fromBlock: block,
                toBlock: block
            });
            let contractEvents = [];
            for (let i = 0; i < events.length; i++) {
                contractEvents.push(this.decodeEvent(events[i]));
            }
            return contractEvents;
        });
    }
    onEvent(name, callback) {
        //this.web3.eth.subscribe(name);
    }
    removeEventListener(name) {
    }
    //in addition to returning the slot we want, it also returns a definition
    //used in the recursive call
    //HOW TO USE:
    //variable may be either a variable id (number) or name (string)
    //struct members may be given either by id (number) or name (string)
    //array indices and numeric mapping keys may be BN, number, or numeric string
    //string mapping keys should be given as strings. duh.
    //bytes mapping keys should be given as hex strings beginning with "0x"
    //address mapping keys are like bytes; checksum case is not required
    //boolean mapping keys may be given either as booleans, or as string "true" or "false"
    constructSlot(variable, ...indices) {
        //base case: we need to locate the variable and its definition
        if (indices.length === 0) {
            let allocation;
            if (typeof variable === "number") {
                allocation = this.stateVariableReferences[variable];
            }
            else {
                allocation = Object.values(this.stateVariableReferences)
                    .find(({ definition }) => definition.name === variable);
            }
            let definition = allocation.definition;
            let pointer = allocation.pointer;
            if (!pointer_1.isStoragePointer(pointer)) { //if it's a constant
                return [undefined, undefined];
            }
            return [pointer.storage.from.slot, definition];
        }
        //main case
        let parentIndices = indices.slice(0, -1); //remove last index
        let [parentSlot, parentDefinition] = this.constructSlot(variable, ...parentIndices);
        if (parentSlot === undefined) {
            return [undefined, undefined];
        }
        let rawIndex = indices[indices.length - 1];
        let index;
        let slot;
        let definition;
        switch (truffle_decode_utils_1.Definition.typeClass(parentDefinition)) {
            case "array":
                if (rawIndex instanceof bn_js_1.default) {
                    index = rawIndex.clone();
                }
                else {
                    index = new bn_js_1.default(rawIndex);
                }
                definition = parentDefinition.baseType || parentDefinition.typeName.baseType;
                let size = storage.storageSize(definition, this.referenceDeclarations, this.storageAllocations);
                if (!storage_1.isWordsLength(size)) {
                    return [undefined, undefined];
                }
                slot = {
                    path: parentSlot,
                    offset: index.muln(size.words),
                    hashPath: truffle_decode_utils_1.Definition.isDynamicArray(parentDefinition)
                };
                break;
            case "mapping":
                let keyDefinition = parentDefinition.keyType || parentDefinition.typeName.keyType;
                switch (truffle_decode_utils_1.Definition.typeClass(keyDefinition)) {
                    case "string":
                    case "bytes":
                        index = rawIndex;
                        break;
                    case "address":
                        index = web3_1.default.utils.toChecksumAddress(rawIndex);
                        break;
                    case "int":
                    case "uint":
                        if (rawIndex instanceof bn_js_1.default) {
                            index = rawIndex.clone();
                        }
                        else {
                            index = new bn_js_1.default(rawIndex);
                        }
                        break;
                    case "bool":
                        if (typeof rawIndex === "string") {
                            index = rawIndex !== "false";
                        }
                        else {
                            index = rawIndex;
                        }
                        break;
                    default: //there is no other case, except fixed and ufixed, but
                        return [undefined, undefined];
                }
                definition = parentDefinition.valueType || parentDefinition.typeName.valueType;
                slot = {
                    path: parentSlot,
                    key: index,
                    keyEncoding: truffle_decode_utils_1.Definition.keyEncoding(keyDefinition),
                    offset: new bn_js_1.default(0)
                };
                break;
            case "struct":
                let parentId = truffle_decode_utils_1.Definition.typeId(parentDefinition);
                let allocation;
                if (typeof rawIndex === "number") {
                    index = rawIndex;
                    allocation = this.storageAllocations[parentId].members[index];
                    definition = allocation.definition;
                }
                else {
                    allocation = Object.values(this.storageAllocations[parentId].members)
                        .find(({ definition }) => definition.name === rawIndex); //there should be exactly one
                    definition = allocation.definition;
                    index = definition.id; //not really necessary, but may as well
                }
                slot = {
                    path: parentSlot,
                    //need type coercion here -- we know structs don't contain constants but the compiler doesn't
                    offset: allocation.pointer.storage.from.slot.offset.clone()
                };
                break;
            default:
                return [undefined, undefined];
        }
        return [slot, definition];
    }
}
exports.default = TruffleContractDecoder;
//# sourceMappingURL=contract-decoder.js.map