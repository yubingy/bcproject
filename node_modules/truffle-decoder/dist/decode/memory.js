"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const debug_1 = __importDefault(require("debug"));
const debug = debug_1.default("decoder:decode:memory");
const read_1 = __importDefault(require("../read"));
const DecodeUtils = __importStar(require("truffle-decode-utils"));
const value_1 = __importDefault(require("./value"));
function* decodeMemory(definition, pointer, info) {
    if (DecodeUtils.Definition.isReference(definition)) {
        return yield* decodeMemoryReferenceByAddress(definition, pointer, info);
    }
    else {
        return yield* value_1.default(definition, pointer, info);
    }
}
exports.default = decodeMemory;
function* decodeMemoryReferenceByAddress(definition, pointer, info) {
    const { state } = info;
    // debug("pointer %o", pointer);
    let rawValue = yield* read_1.default(pointer, state);
    let startPosition = DecodeUtils.Conversion.toBN(rawValue).toNumber();
    let length;
    switch (DecodeUtils.Definition.typeClass(definition)) {
        case "bytes":
        case "string":
            length = DecodeUtils.Conversion.toBN(yield* read_1.default({
                memory: { start: startPosition, length: DecodeUtils.EVM.WORD_SIZE }
            }, state)).toNumber(); //initial word contains length
            let childPointer = {
                memory: { start: startPosition + DecodeUtils.EVM.WORD_SIZE, length }
            };
            return yield* value_1.default(definition, childPointer, info);
        case "array":
            if (DecodeUtils.Definition.isDynamicArray(definition)) {
                length = DecodeUtils.Conversion.toBN(yield* read_1.default({
                    memory: { start: startPosition, length: DecodeUtils.EVM.WORD_SIZE },
                }, state)).toNumber(); // initial word contains array length
                startPosition += DecodeUtils.EVM.WORD_SIZE; //increment startPosition to
                //next word, as first word was used for length
            }
            else {
                length = DecodeUtils.Definition.staticLength(definition);
            }
            let baseDefinition = definition.baseType || definition.typeName.baseType;
            //I'm deliberately not using the DecodeUtils function for this, because
            //we should *not* need a faked-up type here!
            // replace erroneous `_storage_` type identifiers with `_memory_`
            baseDefinition = DecodeUtils.Definition.spliceLocation(baseDefinition, "memory");
            let decodedChildren = [];
            for (let index = 0; index < length; index++) {
                decodedChildren.push(yield* decodeMemory(baseDefinition, { memory: {
                        start: startPosition + index * DecodeUtils.EVM.WORD_SIZE,
                        length: DecodeUtils.EVM.WORD_SIZE
                    } }, info));
            }
            return decodedChildren;
        case "struct":
            const { referenceDeclarations, memoryAllocations } = info;
            const referencedDeclaration = definition.typeName
                ? definition.typeName.referencedDeclaration
                : definition.referencedDeclaration;
            const structAllocation = memoryAllocations[referencedDeclaration];
            debug("structAllocation %O", structAllocation);
            let decodedMembers = {};
            for (let memberAllocation of Object.values(structAllocation.members)) {
                const memberPointer = memberAllocation.pointer;
                const childPointer = {
                    memory: {
                        start: startPosition + memberPointer.memory.start,
                        length: memberPointer.memory.length //always equals WORD_SIZE
                    }
                };
                let memberDefinition = memberAllocation.definition;
                // replace erroneous `_storage` type identifiers with `_memory`
                memberDefinition = DecodeUtils.Definition.spliceLocation(memberDefinition, "memory");
                //there also used to be code here to add on the "_ptr" ending when absent, but we
                //presently ignore that ending, so we'll skip that
                let decoded = yield* decodeMemory(memberDefinition, childPointer, info);
                decodedMembers[memberDefinition.name] = decoded;
            }
            return decodedMembers;
        default:
            // debug("Unknown memory reference type: %s", DecodeUtils.typeIdentifier(definition));
            return undefined;
    }
}
exports.decodeMemoryReferenceByAddress = decodeMemoryReferenceByAddress;
//# sourceMappingURL=memory.js.map