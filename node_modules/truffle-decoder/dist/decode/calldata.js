"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const debug_1 = __importDefault(require("debug"));
const debug = debug_1.default("decoder:decode:calldata");
const read_1 = __importDefault(require("../read"));
const DecodeUtils = __importStar(require("truffle-decode-utils"));
const value_1 = __importDefault(require("./value"));
const calldata_1 = require("../allocate/calldata");
function* decodeCalldata(definition, pointer, info, base = 0) {
    if (DecodeUtils.Definition.isReference(definition)) {
        let dynamic = calldata_1.calldataSize(definition, info.referenceDeclarations, info.calldataAllocations)[1];
        if (dynamic) {
            return yield* decodeCalldataReferenceByAddress(definition, pointer, info, base);
        }
        else {
            return yield* decodeCalldataReferenceStatic(definition, pointer, info);
        }
    }
    else {
        debug("pointer %o", pointer);
        return yield* value_1.default(definition, pointer, info);
    }
}
exports.default = decodeCalldata;
function* decodeCalldataReferenceByAddress(definition, pointer, info, base = 0) {
    const { state } = info;
    debug("pointer %o", pointer);
    let rawValue = yield* read_1.default(pointer, state);
    let startPosition = DecodeUtils.Conversion.toBN(rawValue).toNumber() + base;
    debug("startPosition %d", startPosition);
    let [size, dynamic] = calldata_1.calldataSize(definition, info.referenceDeclarations, info.calldataAllocations);
    if (!dynamic) { //this will only come up when called from stack.ts
        let staticPointer = {
            calldata: {
                start: startPosition,
                length: size
            }
        };
        return yield* decodeCalldataReferenceStatic(definition, staticPointer, info);
    }
    let length;
    switch (DecodeUtils.Definition.typeClass(definition)) {
        case "bytes":
        case "string":
            length = DecodeUtils.Conversion.toBN(yield* read_1.default({
                calldata: { start: startPosition, length: DecodeUtils.EVM.WORD_SIZE }
            }, state)).toNumber(); //initial word contains length
            let childPointer = {
                calldata: { start: startPosition + DecodeUtils.EVM.WORD_SIZE, length }
            };
            return yield* value_1.default(definition, childPointer, info);
        case "array":
            if (DecodeUtils.Definition.isDynamicArray(definition)) {
                length = DecodeUtils.Conversion.toBN(yield* read_1.default({
                    calldata: { start: startPosition, length: DecodeUtils.EVM.WORD_SIZE },
                }, state)).toNumber(); // initial word contains array length
                startPosition += DecodeUtils.EVM.WORD_SIZE; //increment startPosition to
                //next word, as first word was used for length
            }
            else {
                length = DecodeUtils.Definition.staticLength(definition);
            }
            //note: I've written this fairly generically, but it is worth noting that
            //since this array is of dynamic type, we know that if it's static length
            //then size must be EVM.WORD_SIZE
            let baseDefinition = definition.baseType || definition.typeName.baseType;
            //I'm deliberately not using the DecodeUtils function for this, because
            //we should *not* need a faked-up type here!
            // replace erroneous `_storage_` type identifiers with `_calldata_`
            baseDefinition = DecodeUtils.Definition.spliceLocation(baseDefinition, "calldata");
            let baseSize = calldata_1.calldataSize(baseDefinition, info.referenceDeclarations, info.calldataAllocations)[0];
            let decodedChildren = [];
            for (let index = 0; index < length; index++) {
                decodedChildren.push(yield* decodeCalldata(baseDefinition, { calldata: {
                        start: startPosition + index * baseSize,
                        length: baseSize
                    } }, info, startPosition)); //pointer base is always start of list, never the length
            }
            return decodedChildren;
        case "struct":
            return yield* decodeCalldataStructByPosition(definition, startPosition, info);
        default:
            // debug("Unknown calldata reference type: %s", DecodeUtils.typeIdentifier(definition));
            return undefined;
    }
}
exports.decodeCalldataReferenceByAddress = decodeCalldataReferenceByAddress;
function* decodeCalldataReferenceStatic(definition, pointer, info) {
    const { state } = info;
    debug("static");
    debug("pointer %o", pointer);
    switch (DecodeUtils.Definition.typeClass(definition)) {
        case "array":
            //we're in the static case, so we know the array must be statically sized
            const length = DecodeUtils.Definition.staticLength(definition);
            let size = calldata_1.calldataSize(definition, info.referenceDeclarations, info.calldataAllocations)[0];
            let baseDefinition = definition.baseType || definition.typeName.baseType;
            //I'm deliberately not using the DecodeUtils function for this, because
            //we should *not* need a faked-up type here!
            // replace erroneous `_storage_` type identifiers with `_calldata_`
            baseDefinition = DecodeUtils.Definition.spliceLocation(baseDefinition, "calldata");
            let baseSize = calldata_1.calldataSize(baseDefinition, info.referenceDeclarations, info.calldataAllocations)[0];
            let decodedChildren = [];
            for (let index = 0; index < length; index++) {
                decodedChildren.push(yield* decodeCalldata(baseDefinition, { calldata: {
                        start: pointer.calldata.start + index * baseSize,
                        length: baseSize
                    } }, info)); //static case so don't need base
            }
            return decodedChildren;
        case "struct":
            return yield* decodeCalldataStructByPosition(definition, pointer.calldata.start, info);
        default:
            // debug("Unknown calldata reference type: %s", DecodeUtils.typeIdentifier(definition));
            return undefined;
    }
}
exports.decodeCalldataReferenceStatic = decodeCalldataReferenceStatic;
//note that this function takes the start position as a *number*; it does not take a calldata pointer
function* decodeCalldataStructByPosition(definition, startPosition, info) {
    const { state, referenceDeclarations, calldataAllocations } = info;
    const referencedDeclaration = definition.typeName
        ? definition.typeName.referencedDeclaration
        : definition.referencedDeclaration;
    const structAllocation = calldataAllocations[referencedDeclaration];
    if (structAllocation == null) {
        return undefined; //this should never happen
    }
    let decodedMembers = {};
    for (let memberAllocation of Object.values(structAllocation.members)) {
        const memberPointer = memberAllocation.pointer;
        const childPointer = {
            calldata: {
                start: startPosition + memberPointer.calldata.start,
                length: memberPointer.calldata.length
            }
        };
        let memberDefinition = memberAllocation.definition;
        // replace erroneous `_storage` type identifiers with `_calldata`
        memberDefinition = DecodeUtils.Definition.spliceLocation(memberDefinition, "calldata");
        //there also used to be code here to add on the "_ptr" ending when absent, but we
        //presently ignore that ending, so we'll skip that
        let decoded = yield* decodeCalldata(memberDefinition, childPointer, info);
        decodedMembers[memberDefinition.name] = decoded;
    }
    return decodedMembers;
}
//# sourceMappingURL=calldata.js.map